# Phase 6.1: Dropdown Card Fix - Research

**Researched:** 2026-01-27
**Domain:** dnd-kit event handling, nested sortable contexts, Radix Collapsible integration
**Confidence:** HIGH

## Summary

This phase addresses critical interaction bugs in the dropdown card implementation. After analyzing the current codebase (`dropdown-card.tsx`, `dropdown-sortable.tsx`, `selectable-flow-grid.tsx`) and researching dnd-kit documentation, the root causes are clear:

1. **Toggle broken:** The `onPointerDown={(e) => e.stopPropagation()}` in `dropdown-card.tsx` blocks all pointer events from reaching dnd-kit, preventing drag entirely. The button-based approach captures clicks but makes dragging impossible.

2. **Dropdown not draggable:** `DropdownSortable` wraps the dropdown but doesn't use `useSortable` - it only uses `useDroppable` for receiving cards. The dropdown itself has no sortable behavior.

3. **Child cards not reorderable:** The `SortableFlowCard` inside dropdowns has `useSortable` but the parent applies `touch-none` incorrectly and the dropdown's event blocking prevents drag initiation.

4. **Event conflicts:** dnd-kit's `PointerSensor` captures events at document level, conflicting with React synthetic events and Radix components. Without proper separation of drag handle vs clickable areas, events fight.

**Primary recommendation:** Refactor to use explicit drag handles with `setActivatorNodeRef`, keep clickable areas separate from drag activators, and lift open/close state to parent component to prevent corruption.

## Standard Stack

### Core (Already Installed)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @dnd-kit/core | ^6.3.1 | Drag and drop foundation | Provides `setActivatorNodeRef` for drag handles |
| @dnd-kit/sortable | ^10.0.0 | Sortable list presets | `useSortable` hook handles all drag state |
| @radix-ui/react-collapsible | ^1.1.12 | Accordion expand/collapse | CSS variable-based animation, accessible |

### No New Dependencies Required

All required functionality exists in current dependencies. The fix is architectural, not library-based.

## Architecture Patterns

### Pattern 1: Drag Handle Separation (CRITICAL)

**What:** Attach drag listeners ONLY to a dedicated drag handle element, NOT the entire card
**When to use:** When a draggable element contains clickable content
**Source:** [dnd-kit useSortable docs](https://docs.dndkit.com/presets/sortable/usesortable)

```typescript
// CORRECT: Drag handle pattern
function SortableDropdownCard({ card, children }: Props) {
  const {
    attributes,
    listeners,
    setNodeRef,
    setActivatorNodeRef,  // KEY: Separate ref for drag handle
    transform,
    transition,
    isDragging,
  } = useSortable({ id: card.id })

  return (
    <div ref={setNodeRef} style={{ transform, transition }}>
      {/* Header - clickable for toggle */}
      <div className="flex items-center justify-between">
        <button onClick={handleToggle} className="flex-1">
          {card.title}
          <ChevronDown />
        </button>

        {/* Drag handle - ONLY this receives drag listeners */}
        <div
          ref={setActivatorNodeRef}
          {...attributes}
          {...listeners}
          className="cursor-grab touch-none"
        >
          <GripVertical />
        </div>
      </div>

      {/* Content - no drag interference */}
      {isOpen && <div>{children}</div>}
    </div>
  )
}
```

**Key insight:** `setActivatorNodeRef` tells dnd-kit where drag gestures should start. Events on other elements pass through normally.

### Pattern 2: Controlled Collapsible State (Prevents Corruption)

**What:** Lift open/close state to parent component, control via props
**When to use:** When dropdown state can get "stuck" after interactions
**Source:** [Radix Collapsible docs](https://www.radix-ui.com/primitives/docs/components/collapsible)

```typescript
// Parent (DropdownSortable.tsx)
function DropdownSortable({ dropdown, childCards }: Props) {
  const [isOpen, setIsOpen] = useState(false)

  // Auto-collapse when drag starts
  const handleDragStart = () => {
    setIsOpen(false)
  }

  return (
    <SortableDropdownCard
      card={dropdown}
      isOpen={isOpen}
      onOpenChange={setIsOpen}
      onDragStart={handleDragStart}
    >
      {/* Child sortable context */}
    </SortableDropdownCard>
  )
}

// Child (dropdown-card.tsx)
function DropdownCard({ card, isOpen, onOpenChange, children }: Props) {
  return (
    <Collapsible open={isOpen} onOpenChange={onOpenChange}>
      <CollapsibleTrigger>...</CollapsibleTrigger>
      <CollapsibleContent className="overflow-hidden">
        {children}
      </CollapsibleContent>
    </Collapsible>
  )
}
```

**Why:** Local `useState` in a component that re-renders during drag can lose state. Lifting to parent preserves it.

### Pattern 3: Nested SortableContext Structure

**What:** Single DndContext with nested SortableContext for dropdown children
**When to use:** When child cards should be reorderable within dropdown
**Source:** [dnd-kit SortableContext docs](https://docs.dndkit.com/presets/sortable/sortable-context)

```typescript
// selectable-flow-grid.tsx structure
<DndContext sensors={sensors} onDragEnd={handleDragEnd}>
  {/* Main canvas SortableContext - includes dropdown card IDs */}
  <SortableContext items={mainCanvasIds}>
    {cards.map(card => (
      card.card_type === 'dropdown' ? (
        <SortableDropdownCard key={card.id} card={card}>
          {/* Nested SortableContext for children */}
          <SortableContext items={getChildIds(card.id)}>
            {getChildren(card.id).map(child => (
              <SortableChildCard key={child.id} card={child} />
            ))}
          </SortableContext>
        </SortableDropdownCard>
      ) : (
        <SortableCard key={card.id} card={card} />
      )
    ))}
  </SortableContext>
  <DragOverlay />
</DndContext>
```

**Critical:** Main canvas SortableContext MUST include dropdown card IDs for dropdowns to be draggable.

### Pattern 4: Animation with CSS (Not JS)

**What:** Use Radix CSS variables for expand/collapse animation
**When to use:** Dropdown toggle animation (~200ms as specified in CONTEXT.md)

```css
/* globals.css */
.dropdown-content[data-state="open"] {
  animation: slideDown 200ms ease-out;
}

.dropdown-content[data-state="closed"] {
  animation: slideUp 200ms ease-out;
}

@keyframes slideDown {
  from {
    height: 0;
    opacity: 0;
  }
  to {
    height: var(--radix-collapsible-content-height);
    opacity: 1;
  }
}

@keyframes slideUp {
  from {
    height: var(--radix-collapsible-content-height);
    opacity: 1;
  }
  to {
    height: 0;
    opacity: 0;
  }
}
```

### Anti-Patterns to Avoid

- **`onPointerDown stopPropagation` on entire element:** This blocks dnd-kit completely. Only use on specific non-draggable areas.
- **`useState` for open state inside dragged component:** State resets during re-renders caused by drag transforms.
- **Putting drag listeners on button elements:** Buttons have special accessibility behaviors that conflict with drag.
- **Using `touch-none` on entire card:** Prevents all touch interactions including scrolling inside dropdown.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Drag handle behavior | Custom mouse tracking | `setActivatorNodeRef` from useSortable | dnd-kit handles keyboard, touch, mouse consistently |
| Accordion animation | Manual height calculation | Radix `--radix-collapsible-content-height` | Auto-measures content, handles unmounting |
| Click vs drag detection | Manual distance tracking | PointerSensor `activationConstraint.distance` | Already configured at 8px in codebase |
| Nested reordering | Custom drag context | Nested SortableContext | dnd-kit handles collision detection |

**Key insight:** The codebase already has the tools configured correctly. The bug is in how components use (or block) these tools.

## Common Pitfalls

### Pitfall 1: Event Blocking Kills Drag
**What goes wrong:** `stopPropagation()` on parent element prevents drag from starting
**Why it happens:** Developer wants to prevent click bubbling but doesn't realize dnd-kit uses same events
**How to avoid:**
- Use `stopPropagation()` only on the specific interactive element, not its container
- Check `isDragging` state before calling `stopPropagation`
- Use drag handles so click areas don't need event blocking
**Warning signs:** Drag doesn't start at all, no visual feedback when attempting to drag

### Pitfall 2: Dropdown Not in Main SortableContext
**What goes wrong:** Dropdown can receive cards but can't be reordered itself
**Why it happens:** `DropdownSortable` uses `useDroppable` but dropdown ID not in parent `SortableContext.items`
**How to avoid:** Include dropdown card IDs in the main canvas `SortableContext.items` array
**Warning signs:** Dropdown accepts drops but dragging it shows no position indicator

### Pitfall 3: State Lost During Drag Transforms
**What goes wrong:** Open/close state resets to default during or after drag
**Why it happens:** Component with `useState` unmounts or re-renders with fresh state during drag
**How to avoid:**
- Lift state to component that doesn't get drag transforms
- Use controlled component pattern (`open` and `onOpenChange` props)
**Warning signs:** Dropdown opens then immediately closes, state inconsistent after drag

### Pitfall 4: Click Fires After Drag
**What goes wrong:** Card gets selected/clicked after completing a drag
**Why it happens:** `onClick` handler fires when mouse released, even after drag
**How to avoid:**
- Check `isDragging` ref in click handler: `if (isDraggingRef.current) return`
- Already implemented in `selectable-flow-grid.tsx` - ensure all click handlers use it
**Warning signs:** Card opens editor panel immediately after being dropped

### Pitfall 5: Child Cards Get Wrong Width
**What goes wrong:** Cards inside dropdown render at wrong size
**Why it happens:** Width classes based on `size` don't account for nested container width
**How to avoid:**
- Force child cards to full width inside dropdown (dropdown is already full width)
- Use `w-full` for all child cards regardless of `size` property
**Warning signs:** Small cards render at 50% of dropdown width (half of already-narrow container)

## Code Examples

### Refactored SortableDropdownCard (Full Implementation)

```typescript
// Source: dnd-kit docs + existing codebase patterns
"use client"

import { useSortable } from "@dnd-kit/sortable"
import { CSS } from "@dnd-kit/utilities"
import { GripVertical, ChevronDown } from "lucide-react"
import { cn } from "@/lib/utils"
import { Collapsible, CollapsibleTrigger, CollapsibleContent } from "@/components/ui/collapsible"
import type { Card } from "@/types/card"

interface SortableDropdownCardProps {
  card: Card
  isOpen: boolean
  onOpenChange: (open: boolean) => void
  children?: React.ReactNode
}

export function SortableDropdownCard({
  card,
  isOpen,
  onOpenChange,
  children
}: SortableDropdownCardProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    setActivatorNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: card.id })

  const style = {
    transform: CSS.Translate.toString(transform),
    transition: transition ?? 'transform 200ms ease',
  }

  // Auto-collapse when drag starts (per CONTEXT.md)
  // This is handled by parent via onOpenChange(false) in onDragStart

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={cn(
        "w-full",
        isDragging && "opacity-50 z-50"
      )}
    >
      <Collapsible open={isOpen} onOpenChange={onOpenChange}>
        <div className="flex items-center bg-card/50 border border-border/50 rounded-lg">
          {/* Clickable header - NOT a button to avoid a11y conflicts */}
          <CollapsibleTrigger asChild>
            <div
              className="flex-1 flex items-center justify-between px-4 py-3 cursor-pointer hover:bg-accent/30 transition-colors"
            >
              <span className="text-sm font-medium">{card.title || "Dropdown"}</span>
              <ChevronDown
                className={cn(
                  "h-4 w-4 text-muted-foreground/70 transition-transform duration-200",
                  isOpen && "rotate-180"
                )}
              />
            </div>
          </CollapsibleTrigger>

          {/* Drag handle - separate from toggle trigger */}
          <div
            ref={setActivatorNodeRef}
            {...attributes}
            {...listeners}
            className="px-2 py-3 cursor-grab active:cursor-grabbing touch-none hover:bg-accent/30 rounded-r-lg"
            aria-label="Drag to reorder"
          >
            <GripVertical className="h-4 w-4 text-muted-foreground" />
          </div>
        </div>

        <CollapsibleContent className="dropdown-content overflow-hidden">
          <div className="pt-2 pl-3 space-y-2">
            {children}
          </div>
        </CollapsibleContent>
      </Collapsible>
    </div>
  )
}
```

### Detecting Cross-Container Drag in onDragEnd

```typescript
// Source: Existing codebase + dnd-kit patterns
function handleDragEnd(event: DragEndEvent) {
  const { active, over } = event
  if (!over) return

  const activeId = active.id as string
  const overId = over.id as string

  // Find which container each card is in
  const activeCard = cards.find(c => c.id === activeId)
  const overCard = cards.find(c => c.id === overId)

  if (!activeCard) return

  // Case: Reordering WITHIN a dropdown
  if (activeCard.parentDropdownId && overCard?.parentDropdownId === activeCard.parentDropdownId) {
    reorderCardsInDropdown(activeCard.parentDropdownId, oldIndex, newIndex)
    return
  }

  // Case: Reordering dropdowns on main canvas
  if (activeCard.card_type === 'dropdown' && !overCard?.parentDropdownId) {
    reorderCards(oldIndex, newIndex)
    return
  }

  // Other cases...
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Entire element as drag activator | Explicit drag handles | dnd-kit best practice | Click and drag don't conflict |
| Local useState for collapsible | Lifted/controlled state | React patterns | Prevents state corruption during re-renders |
| stopPropagation everywhere | Minimal event blocking | Understanding event flow | Drag actually works |

**Deprecated/outdated:**
- Using `onPointerDown stopPropagation` to prevent dnd-kit: Blocks drag entirely
- Button element as drag activator: Accessibility conflicts

## Open Questions

1. **Child card width inside dropdown**
   - What we know: Child cards currently use same width logic as main canvas
   - What's unclear: Should small cards be 50% of dropdown width (very narrow) or full width?
   - Recommendation: Force `w-full` for all child cards inside dropdown - they're already in a narrower container

2. **Mobile touch target size for drag handle**
   - What we know: Drag handle needs to be touchable on mobile
   - What's unclear: Minimum size for reliable touch (44px recommended by Apple HIG)
   - Recommendation: Make drag handle at least 44x44px touch target on mobile

## Sources

### Primary (HIGH confidence)
- [dnd-kit useSortable docs](https://docs.dndkit.com/presets/sortable/usesortable) - setActivatorNodeRef pattern
- [dnd-kit SortableContext docs](https://docs.dndkit.com/presets/sortable/sortable-context) - Nested context usage
- [Radix Collapsible docs](https://www.radix-ui.com/primitives/docs/components/collapsible) - CSS animation variables
- [GitHub Issue #591](https://github.com/clauderic/dnd-kit/issues/591) - Click vs drag separation
- [GitHub Issue #800](https://github.com/clauderic/dnd-kit/issues/800) - onClick event handling

### Secondary (MEDIUM confidence)
- Existing codebase analysis (`preview-sortable-card.tsx`) - Working drag handle pattern
- Phase 6 RESEARCH.md - Prior nested container patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Using existing installed libraries
- Architecture patterns: HIGH - Verified against official docs and working codebase examples
- Pitfalls: HIGH - Directly observed in current implementation and documented in dnd-kit issues
- Code examples: HIGH - Based on docs + existing working code in codebase

**Research date:** 2026-01-27
**Valid until:** 60 days (stable patterns, no library changes expected)
