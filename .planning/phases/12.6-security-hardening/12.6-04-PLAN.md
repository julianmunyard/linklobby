---
phase: 12.6-security-hardening
plan: 04
type: execute
wave: 2
depends_on: ["12.6-03"]
files_modified:
  - src/app/(dashboard)/settings/page.tsx
  - src/components/settings/change-password-form.tsx
  - src/components/settings/change-email-form.tsx
  - src/app/(auth)/verify-email/page.tsx
  - src/app/auth/callback/route.ts
  - supabase/migrations/20260225_confirm_existing_users.sql
  - src/lib/supabase/publish-gate.ts
autonomous: true

must_haves:
  truths:
    - "Settings page has Account section with change password and change email forms"
    - "Change password requires current password confirmation before updating"
    - "Change email sends verification to new address via Supabase before switching"
    - "Verify email page shows confirmation message after email verification link is clicked"
    - "Auth callback handles type=signup by redirecting to editor (email confirmed)"
    - "Existing users have email_confirmed_at set via migration so they aren't locked out"
    - "Publishing is gated behind email verification — users with null email_confirmed_at cannot set is_published to true"
  artifacts:
    - path: "src/components/settings/change-password-form.tsx"
      provides: "Change password form requiring current password"
      exports: ["ChangePasswordForm"]
    - path: "src/components/settings/change-email-form.tsx"
      provides: "Change email form that triggers Supabase verification"
      exports: ["ChangeEmailForm"]
    - path: "src/app/(auth)/verify-email/page.tsx"
      provides: "Email verification confirmation page"
    - path: "supabase/migrations/20260225_confirm_existing_users.sql"
      provides: "Migration to set email_confirmed_at for existing users"
  key_links:
    - from: "src/app/(dashboard)/settings/page.tsx"
      to: "src/components/settings/change-password-form.tsx"
      via: "renders ChangePasswordForm in Account section"
      pattern: "ChangePasswordForm"
    - from: "src/components/settings/change-password-form.tsx"
      to: "supabase.auth.signInWithPassword"
      via: "re-authenticates with current password before updating"
      pattern: "signInWithPassword"
    - from: "src/components/settings/change-email-form.tsx"
      to: "supabase.auth.updateUser"
      via: "calls updateUser with new email (triggers verification)"
      pattern: "updateUser.*email"
---

<objective>
Build the settings account management section (change password, change email) and email verification flow.

Purpose: Users need to manage their credentials in settings. Email verification ensures valid email addresses before allowing page publishing. The change-password flow requires re-authentication for security.
Output: Change password form, change email form, expanded settings page, email verification page, SQL migration for existing users.
</objective>

<execution_context>
@/Users/julianmunyard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianmunyard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.6-security-hardening/12.6-RESEARCH.md
@src/app/(dashboard)/settings/page.tsx
@src/app/(dashboard)/settings/username-form.tsx
@src/app/auth/callback/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create change password form, change email form, and expand settings page</name>
  <files>src/components/settings/change-password-form.tsx, src/components/settings/change-email-form.tsx, src/app/(dashboard)/settings/page.tsx</files>
  <action>
**Step 1: Create `src/components/settings/change-password-form.tsx`.**

A client component with react-hook-form and zod validation. Three fields: current password, new password, confirm new password.

Flow:
1. User enters current password, new password, confirm password
2. On submit, first call `supabase.auth.signInWithPassword({ email: user.email, password: currentPassword })` to verify current password
3. If re-auth fails, show "Current password is incorrect" error
4. If re-auth succeeds, call `supabase.auth.updateUser({ password: newPassword })`
5. Show success toast/message

Zod schema:
```typescript
const changePasswordSchema = z.object({
  currentPassword: z.string().min(1, 'Current password is required'),
  newPassword: z.string().min(8, 'New password must be at least 8 characters'),
  confirmPassword: z.string().min(1, 'Please confirm your new password'),
}).refine(data => data.newPassword === data.confirmPassword, {
  message: "Passwords don't match",
  path: ['confirmPassword'],
})
```

Props: `userEmail: string` (passed from server-rendered settings page).

Use the existing UI component patterns: Card with CardHeader/CardContent, Input, Label, Button. Show success state with a green "Password updated" message that auto-clears after 3 seconds.

**Step 2: Create `src/components/settings/change-email-form.tsx`.**

A client component. Two fields: new email, current password (for re-auth).

Flow:
1. User enters new email and current password
2. On submit, verify current password via `signInWithPassword`
3. If re-auth succeeds, call `supabase.auth.updateUser({ email: newEmail })`
4. Supabase sends a verification email to the new address automatically
5. Show success message: "Verification email sent to [new email]. Please check your inbox to confirm the change."

Props: `userEmail: string` (current email, displayed as read-only context).

**Step 3: Expand `src/app/(dashboard)/settings/page.tsx`.**

The current settings page only has UsernameForm. Restructure to add sections:

```tsx
<main className="max-w-md space-y-8">
  {/* Profile section */}
  <section>
    <h2 className="text-lg font-semibold mb-4">Profile</h2>
    <UsernameForm currentUsername={profile?.username || ''} />
  </section>

  {/* Account section */}
  <section>
    <h2 className="text-lg font-semibold mb-4">Account</h2>
    <div className="space-y-6">
      <ChangePasswordForm userEmail={user.email || ''} />
      <ChangeEmailForm userEmail={user.email || ''} />
    </div>
  </section>

  {/* Security section - placeholder for 2FA and sessions (Plans 05, 06) */}
</main>
```

Import the new components. The settings page is a server component that fetches user data — pass `user.email` as a prop to the client form components.
  </action>
  <verify>
- `ls src/components/settings/change-password-form.tsx src/components/settings/change-email-form.tsx` — both exist
- `grep "ChangePasswordForm" src/app/\(dashboard\)/settings/page.tsx` — imported and rendered
- `grep "ChangeEmailForm" src/app/\(dashboard\)/settings/page.tsx` — imported and rendered
- `grep "signInWithPassword" src/components/settings/change-password-form.tsx` — re-auth before update
- `grep "updateUser" src/components/settings/change-password-form.tsx` — password update
- `grep "updateUser" src/components/settings/change-email-form.tsx` — email update
- `npx tsc --noEmit` — no type errors
  </verify>
  <done>
Settings page expanded with Account section containing change password and change email forms. Change password requires re-authentication via current password. Change email triggers Supabase verification flow. All forms use existing UI patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create email verification page, update auth callback, and create migration for existing users</name>
  <files>src/app/(auth)/verify-email/page.tsx, src/app/auth/callback/route.ts, supabase/migrations/20260225_confirm_existing_users.sql</files>
  <action>
**Step 1: Create `src/app/(auth)/verify-email/page.tsx`.**

A simple server-rendered page that shows after a user signs up (when email confirmation is enabled). This is NOT the page they land on after clicking the verification link — that goes through /auth/callback which redirects to /editor.

This is the "check your email" interim page shown right after signup:

```tsx
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import Link from 'next/link'
import { Button } from '@/components/ui/button'

export default function VerifyEmailPage() {
  return (
    <Card>
      <CardHeader className="text-center">
        <CardTitle className="text-2xl">Check your email</CardTitle>
        <CardDescription>
          We&apos;ve sent you a verification link. Please check your inbox and click the link to verify your email address.
        </CardDescription>
      </CardHeader>
      <CardContent className="text-center space-y-4">
        <p className="text-sm text-muted-foreground">
          Didn&apos;t receive the email? Check your spam folder.
        </p>
        <Button variant="outline" asChild>
          <Link href="/login">Back to login</Link>
        </Button>
      </CardContent>
    </Card>
  )
}
```

This page uses the (auth) layout so it's centered on screen.

**Step 2: Update auth callback for email verification.**

In `src/app/auth/callback/route.ts`, the callback should already handle `type=signup` (email confirmation). The current code (after Plan 03 modifications) handles `type=recovery`. Ensure `type=signup` or `type=email_change` is handled properly:

- `type=signup`: Email verification complete — redirect to `/editor` (user is now confirmed)
- `type=email_change`: Email change verified — redirect to `/settings` with a success query param
- `type=recovery`: Already handled by Plan 03 — redirect to `/reset-password`

Update the callback:
```typescript
if (type === 'recovery') {
  return NextResponse.redirect(`${origin}/reset-password`)
}
if (type === 'email_change') {
  return NextResponse.redirect(`${origin}/settings?email_updated=true`)
}
// Default: redirect to next (covers type=signup and OAuth)
return NextResponse.redirect(`${origin}${next}`)
```

NOTE: Plan 03 (Wave 1) runs before this plan (Wave 2, depends_on 12.6-03) and adds the `type === 'recovery'` case to the callback. That case WILL already be present when this task executes. Your job is to add ONLY the `type === 'email_change'` case after the existing recovery case. Read the file first to confirm Plan 03's recovery handling is in place, then add the email_change redirect.

**Step 3: Create migration for existing users.**

Create `supabase/migrations/20260225_confirm_existing_users.sql`:

```sql
-- Confirm all existing users' emails before enabling email verification
-- This prevents existing users from being locked out when
-- "Require email confirmation" is enabled in Supabase Auth settings.
--
-- Run this BEFORE enabling email confirmation in Supabase Dashboard:
-- Authentication > Providers > Email > Enable email confirmations

UPDATE auth.users
SET email_confirmed_at = NOW()
WHERE email_confirmed_at IS NULL;
```

This migration is CRITICAL — without it, enabling email confirmation in Supabase will lock out all existing users who signed up before the feature was enabled. Add a prominent comment explaining this.

NOTE for the executor: This migration needs to be run manually via `supabase db push` or the Supabase Dashboard SQL editor. The file serves as documentation and version control for the migration. After running it, the user should enable "Require email confirmation" in Supabase Dashboard > Authentication > Providers > Email.

**Step 4: Add email verification gate on publishing.**

Publishing (`is_published = true`) must be blocked for users who haven't verified their email. Since `is_published` is currently toggled via direct Supabase client calls (no custom API route for publish), create a reusable server-side check and also add client-side enforcement.

Create `src/lib/supabase/publish-gate.ts`:

```typescript
import { SupabaseClient } from '@supabase/supabase-js'

/**
 * Check if user is allowed to publish. Returns null if allowed,
 * or an error message string if not.
 */
export async function checkPublishEligibility(
  supabase: SupabaseClient
): Promise<string | null> {
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return 'Not authenticated'
  if (!user.email_confirmed_at) return 'Please verify your email before publishing'
  return null
}
```

Then, find wherever `is_published` is toggled to `true` in the codebase (search for `is_published` in the `src/` directory — likely in an editor component or a publish toggle). Add a check before the update:

1. If the toggle is in a client component: before calling `supabase.from('pages').update({ is_published: true })`, call `supabase.auth.getUser()` and check `user.email_confirmed_at`. If null, show an error toast: "Please verify your email before publishing your page." and don't update.

2. If there's an API route that handles publishing (check `src/app/api/page/route.ts` for a PUT/PATCH handler): add the check in the handler:
```typescript
// Before allowing is_published = true:
if (body.is_published === true) {
  const { data: { user } } = await supabase.auth.getUser()
  if (!user?.email_confirmed_at) {
    return NextResponse.json(
      { error: 'Please verify your email before publishing' },
      { status: 403 }
    )
  }
}
```

Also add a Supabase RLS policy as defense-in-depth. Create an additional SQL statement in the existing migration or a new migration:
```sql
-- Prevent unverified users from publishing
-- This is a safety net; primary enforcement is in application code
CREATE OR REPLACE FUNCTION check_publish_email_verified()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.is_published = TRUE AND OLD.is_published IS DISTINCT FROM TRUE THEN
    IF NOT EXISTS (
      SELECT 1 FROM auth.users WHERE id = NEW.user_id AND email_confirmed_at IS NOT NULL
    ) THEN
      RAISE EXCEPTION 'Email must be verified before publishing';
    END IF;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER enforce_publish_email_verified
  BEFORE UPDATE ON pages
  FOR EACH ROW
  EXECUTE FUNCTION check_publish_email_verified();
```

The application-level check provides a good UX error message; the RLS trigger is the security backstop.
  </action>
  <verify>
- `ls src/app/\(auth\)/verify-email/page.tsx` — exists
- `grep "email_change" src/app/auth/callback/route.ts` — email change redirect handled
- `ls supabase/migrations/20260225_confirm_existing_users.sql` — migration exists
- `grep "email_confirmed_at" supabase/migrations/20260225_confirm_existing_users.sql` — updates existing users
- `ls src/lib/supabase/publish-gate.ts` — publish gate helper exists
- `grep "email_confirmed_at" src/lib/supabase/publish-gate.ts` — checks email verification before publish
- `grep -r "email_confirmed_at\|verify.*email.*publish\|checkPublishEligibility" src/` — publish is gated behind email verification somewhere in the codebase
- `npx tsc --noEmit` — no type errors
  </verify>
  <done>
Email verification page created for post-signup "check your email" flow. Auth callback updated to handle email_change type (redirect to settings). SQL migration prepared to confirm all existing users before enabling email verification. Publishing gated behind email verification — users with unverified emails cannot set is_published to true. Settings page has Account section with change password and change email.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Settings page shows Profile and Account sections
3. Change password form requires current password before updating
4. Change email form triggers Supabase verification
5. Verify-email page shows "check your email" message
6. Auth callback handles recovery, signup, and email_change types
7. Migration file exists to confirm existing users
</verification>

<success_criteria>
- Change password requires re-authentication
- Change email triggers verification to new address
- Settings page properly structured with sections
- Email verification flow has a landing page
- Migration protects existing users from lockout
- No type errors
</success_criteria>

<output>
After completion, create `.planning/phases/12.6-security-hardening/12.6-04-SUMMARY.md`
</output>
