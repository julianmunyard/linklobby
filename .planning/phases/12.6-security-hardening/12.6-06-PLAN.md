---
phase: 12.6-security-hardening
plan: 06
type: execute
wave: 4
depends_on: ["12.6-05"]
files_modified:
  - src/components/auth/session-list.tsx
  - src/app/(dashboard)/settings/page.tsx
  - src/components/legal/cookie-consent-banner.tsx
  - src/app/[username]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Settings page has session management section with 'Sign out all other devices' button"
    - "Clicking 'Sign out all other devices' calls supabase.auth.signOut({ scope: 'others' })"
    - "Cookie consent banner appears on public pages when artist has pixels enabled"
    - "Pixels only fire after user explicitly accepts cookies"
    - "Cookie consent banner matches artist's theme colors"
  artifacts:
    - path: "src/components/auth/session-list.tsx"
      provides: "Session management component with sign out options"
      exports: ["SessionManagement"]
    - path: "src/components/legal/cookie-consent-banner.tsx"
      provides: "Theme-aware cookie consent banner (already exists, needs wiring)"
  key_links:
    - from: "src/app/(dashboard)/settings/page.tsx"
      to: "src/components/auth/session-list.tsx"
      via: "renders SessionManagement in Security section"
      pattern: "SessionManagement"
    - from: "src/app/[username]/page.tsx"
      to: "src/components/legal/cookie-consent-banner.tsx"
      via: "conditionally renders CookieConsentBanner when pixels are enabled"
      pattern: "CookieConsentBanner"
---

<objective>
Build session management UI for settings and wire up the cookie consent banner on public pages.

Purpose: Session management lets users sign out all other devices (important for shared/compromised accounts). Cookie consent is a GDPR requirement that's already 80% built but not wired to public pages. Both are relatively simple additions that depend on the settings page structure from Plan 04.
Output: Session management component in settings, cookie consent banner wired to public pages with pixel gating.
</objective>

<execution_context>
@/Users/julianmunyard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianmunyard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.6-security-hardening/12.6-RESEARCH.md
@.planning/phases/12.6-security-hardening/12.6-04-SUMMARY.md
@src/app/(dashboard)/settings/page.tsx
@src/components/legal/cookie-consent-banner.tsx
@src/app/[username]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session management component and add to settings</name>
  <files>src/components/auth/session-list.tsx, src/app/(dashboard)/settings/page.tsx</files>
  <action>
**Step 1: Create `src/components/auth/session-list.tsx`.**

A client component that provides session management. Supabase does NOT have a public API to list individual sessions, so this is a simplified UI.

Export `SessionManagement` component.

UI layout using Card:
- Title: "Sessions"
- Description: "Manage your active sessions across devices"
- Current session info: show "You are currently signed in" with the user's email
- Two action buttons:
  1. "Sign out all other devices" — calls `supabase.auth.signOut({ scope: 'others' })`. Shows confirmation dialog before executing. On success, show "All other sessions have been signed out" toast/message.
  2. "Sign out everywhere" — calls `supabase.auth.signOut({ scope: 'global' })`. Shows warning dialog ("This will sign you out of all devices including this one"). On confirm, redirects to /login.

Use the existing Button component. "Sign out all other devices" uses variant="outline", "Sign out everywhere" uses variant="destructive".

Add loading states and success/error feedback.

```typescript
'use client'

import { useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'

export function SessionManagement() {
  const supabase = createClient()
  const router = useRouter()
  const [status, setStatus] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)

  async function signOutOthers() {
    setIsLoading(true)
    setStatus(null)
    const { error } = await supabase.auth.signOut({ scope: 'others' })
    if (error) {
      setStatus('Failed to sign out other sessions')
    } else {
      setStatus('All other sessions have been signed out')
    }
    setIsLoading(false)
  }

  async function signOutAll() {
    if (!confirm('This will sign you out of all devices, including this one. Continue?')) return
    setIsLoading(true)
    await supabase.auth.signOut({ scope: 'global' })
    router.push('/login')
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-base">Sessions</CardTitle>
        <CardDescription>Manage your active sessions</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {status && (
          <p className="text-sm text-muted-foreground">{status}</p>
        )}
        <div className="flex flex-col gap-2">
          <Button variant="outline" onClick={signOutOthers} disabled={isLoading}>
            Sign out all other devices
          </Button>
          <Button variant="destructive" onClick={signOutAll} disabled={isLoading}>
            Sign out everywhere
          </Button>
        </div>
      </CardContent>
    </Card>
  )
}
```

**Step 2: Add SessionManagement to settings page.**

In `src/app/(dashboard)/settings/page.tsx`, add SessionManagement to the Security section (which was added by Plan 05, or add it if not present):

```tsx
import { SessionManagement } from '@/components/auth/session-list'

// In the Security section, after TwoFactorStatus:
<SessionManagement />
```

If Plan 05 hasn't added the Security section yet, add it:
```tsx
<section>
  <h2 className="text-lg font-semibold mb-4">Security</h2>
  <div className="space-y-6">
    {/* TwoFactorStatus will be here from Plan 05 */}
    <SessionManagement />
  </div>
</section>
```

The executor should check the current state of the settings page and adapt accordingly.
  </action>
  <verify>
- `ls src/components/auth/session-list.tsx` — exists
- `grep "SessionManagement" src/app/\(dashboard\)/settings/page.tsx` — rendered in settings
- `grep "scope: 'others'" src/components/auth/session-list.tsx` — sign out others
- `grep "scope: 'global'" src/components/auth/session-list.tsx` — sign out everywhere
- `npx tsc --noEmit` — no type errors
  </verify>
  <done>
Session management component created with "Sign out all other devices" and "Sign out everywhere" buttons. Component renders in settings Security section. Uses Supabase signOut with scope options.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire cookie consent banner to public pages with pixel gating</name>
  <files>src/components/legal/cookie-consent-banner.tsx, src/app/[username]/page.tsx</files>
  <action>
**Step 1: Review and update `src/components/legal/cookie-consent-banner.tsx`.**

The cookie consent banner component already exists and is mostly complete. Review it and make these updates:

1. Remove "Cookie Preferences (coming soon)" text — replace with a link to privacy policy if one exists, or just remove it
2. Ensure the `onAccept` handler dispatches `consent-granted` event (already does)
3. Ensure the `onDecline` handler dispatches `consent-declined` event (already does)
4. The component already reads theme CSS custom properties — this is correct behavior for public pages

The component already handles:
- Theme-aware styling via CSS custom properties
- Scroll-triggered display (after 100px)
- Accept/Reject buttons with proper styling
- Cookie persistence via react-cookie-consent

**Step 2: Wire CookieConsentBanner to public pages.**

In `src/app/[username]/page.tsx` (the public page for each user), conditionally render the cookie consent banner when the artist has pixels enabled.

First, read the file to understand the current structure. The public page likely fetches the user's page data including pixel configuration.

Check if the page data includes pixel IDs (Facebook Pixel ID, Google Analytics ID). If either is present AND the page is published, render the cookie consent banner:

```tsx
import { CookieConsentBanner } from '@/components/legal/cookie-consent-banner'

// Inside the page component, after the main content:
{(pageData.facebook_pixel_id || pageData.google_analytics_id) && (
  <CookieConsentBanner />
)}
```

The banner reads theme CSS custom properties that should already be set by the theme system on public pages. If the theme sets `--theme-background`, `--theme-text`, `--theme-accent`, `--theme-border` CSS variables, the banner will pick them up automatically.

If the public page doesn't set these CSS custom properties, pass explicit theme colors via the `themeColors` prop based on the page's theme configuration.

**Step 3: Verify pixel components respect consent.**

Check that the existing PixelLoader component (which loads Facebook Pixel and Google Analytics) listens for the `consent-granted` event before firing. Read the PixelLoader component to verify this is already in place. If it is, no changes needed. If not, add the consent check:

```typescript
// PixelLoader should only fire after consent
useEffect(() => {
  const handleConsent = () => {
    // Initialize pixels here
  }
  window.addEventListener('consent-granted', handleConsent)
  return () => window.removeEventListener('consent-granted', handleConsent)
}, [])
```

According to the RESEARCH.md, the PixelLoader already listens for `consent-granted`. Verify this is true by reading the file — if it's already correct, no changes needed.
  </action>
  <verify>
- `grep "CookieConsentBanner" src/app/\\[username\\]/page.tsx` — banner rendered on public pages
- `grep "facebook_pixel_id\|google_analytics_id" src/app/\\[username\\]/page.tsx` — conditional on pixels being enabled
- `grep "consent-granted" src/components/legal/cookie-consent-banner.tsx` — event dispatched on accept
- `grep "consent-granted" src/components/pixels/pixel-loader.tsx` — PixelLoader listens for consent event (confirms pixels are actually gated behind consent, not just the banner)
- `npx tsc --noEmit` — no type errors
  </verify>
  <done>
Cookie consent banner wired to public pages. Banner only appears when artist has pixels (Facebook Pixel or Google Analytics) enabled. Banner dispatches consent-granted/consent-declined events. Pixels only fire after explicit consent. Banner respects artist's theme colors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Session management in settings with sign out options
3. Cookie consent banner renders on public pages with pixels
4. Banner does NOT render on pages without pixels enabled
5. Pixel components respect consent (don't fire before accept)
</verification>

<success_criteria>
- Session management with "sign out other devices" and "sign out everywhere"
- Cookie consent banner conditionally shown on public pages
- Pixels gated behind consent
- No type errors
</success_criteria>

<output>
After completion, create `.planning/phases/12.6-security-hardening/12.6-06-SUMMARY.md`
</output>
