---
phase: 12.6-security-hardening
plan: 05
type: execute
wave: 3
depends_on: ["12.6-04"]
files_modified:
  - src/components/auth/two-factor-setup.tsx
  - src/components/auth/two-factor-verify.tsx
  - src/app/(auth)/mfa-challenge/page.tsx
  - src/app/(auth)/mfa-challenge/mfa-challenge-form.tsx
  - src/app/api/auth/backup-codes/route.ts
  - src/app/api/auth/backup-codes/verify/route.ts
  - src/app/(dashboard)/settings/page.tsx
  - src/middleware.ts
  - supabase/migrations/20260225_mfa_backup_codes.sql
autonomous: true

must_haves:
  truths:
    - "User can enable 2FA in settings: shows QR code, requires TOTP code to confirm enrollment"
    - "After enabling 2FA, 10 backup codes are generated, displayed once, and stored as bcrypt hashes"
    - "Login flow checks MFA status: if user has TOTP enrolled and session is aal1, redirect to MFA challenge page"
    - "MFA challenge page accepts 6-digit TOTP code from authenticator app"
    - "MFA challenge page also accepts backup code as alternative (single-use, marked as used after verification)"
    - "Middleware redirects authenticated aal1 users with enrolled TOTP to /mfa-challenge"
    - "User can disable 2FA from settings (unenrolls TOTP factor)"
  artifacts:
    - path: "src/components/auth/two-factor-setup.tsx"
      provides: "2FA setup component with QR code display and TOTP verification"
      exports: ["TwoFactorSetup"]
    - path: "src/components/auth/two-factor-verify.tsx"
      provides: "2FA disable component with confirmation"
      exports: ["TwoFactorStatus"]
    - path: "src/app/(auth)/mfa-challenge/mfa-challenge-form.tsx"
      provides: "MFA challenge form for login flow"
      exports: ["MfaChallengeForm"]
    - path: "src/app/api/auth/backup-codes/route.ts"
      provides: "Backup codes generation endpoint"
      exports: ["POST"]
    - path: "src/app/api/auth/backup-codes/verify/route.ts"
      provides: "Backup code verification endpoint"
      exports: ["POST"]
    - path: "supabase/migrations/20260225_mfa_backup_codes.sql"
      provides: "mfa_backup_codes table for storing hashed backup codes"
      contains: "CREATE TABLE mfa_backup_codes"
  key_links:
    - from: "src/middleware.ts"
      to: "supabase.auth.mfa.getAuthenticatorAssuranceLevel"
      via: "checks AAL level for MFA enforcement"
      pattern: "getAuthenticatorAssuranceLevel|aal1|aal2"
    - from: "src/components/auth/two-factor-setup.tsx"
      to: "supabase.auth.mfa.enroll"
      via: "enrolls TOTP factor and displays QR code"
      pattern: "mfa.enroll"
    - from: "src/app/api/auth/backup-codes/route.ts"
      to: "supabase/migrations/20260225_mfa_backup_codes.sql"
      via: "stores bcrypt-hashed codes in mfa_backup_codes table"
      pattern: "mfa_backup_codes"
---

<objective>
Implement TOTP-based two-factor authentication with backup codes, MFA challenge page, and middleware enforcement.

Purpose: 2FA is critical for account security. Users who opt in get TOTP (authenticator app) protection with backup codes as fallback. The middleware enforcement ensures 2FA can't be bypassed by navigating directly to protected routes.
Output: 2FA setup/disable UI in settings, MFA challenge page, backup codes API routes, database table, middleware MFA check.
</objective>

<execution_context>
@/Users/julianmunyard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianmunyard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.6-security-hardening/12.6-RESEARCH.md
@.planning/phases/12.6-security-hardening/12.6-04-SUMMARY.md
@src/app/(dashboard)/settings/page.tsx
@src/middleware.ts
@src/app/(auth)/login/login-form.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mfa_backup_codes table, backup codes API routes, and 2FA setup/status components</name>
  <files>supabase/migrations/20260225_mfa_backup_codes.sql, src/app/api/auth/backup-codes/route.ts, src/app/api/auth/backup-codes/verify/route.ts, src/components/auth/two-factor-setup.tsx, src/components/auth/two-factor-verify.tsx</files>
  <action>
**Step 1: Install bcryptjs (pure JS bcrypt — no native compilation needed for Vercel).**

```bash
npm install bcryptjs
npm install -D @types/bcryptjs
```

Use `bcryptjs` NOT `bcrypt` — the native `bcrypt` package requires node-gyp compilation which fails on some Vercel build environments.

**Step 2: Create migration `supabase/migrations/20260225_mfa_backup_codes.sql`.**

```sql
CREATE TABLE IF NOT EXISTS mfa_backup_codes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  code_hash TEXT NOT NULL,
  used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS mfa_backup_codes_user_id_idx ON mfa_backup_codes(user_id);

ALTER TABLE mfa_backup_codes ENABLE ROW LEVEL SECURITY;
-- No public policies — accessed via service role in API routes only
```

**Step 3: Create `src/app/api/auth/backup-codes/route.ts`.**

POST endpoint that generates 10 backup codes, stores bcrypt hashes, returns plaintext codes.

```typescript
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createAdminClient } from '@/lib/supabase/admin'
import crypto from 'crypto'
import bcrypt from 'bcryptjs'

export async function POST() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

  // Generate 10 codes (10-char hex uppercase)
  const codes = Array.from({ length: 10 }, () =>
    crypto.randomBytes(5).toString('hex').toUpperCase()
  )

  // Hash all codes
  const hashes = await Promise.all(codes.map(c => bcrypt.hash(c, 10)))

  const admin = createAdminClient()

  // Delete existing codes for this user (regeneration)
  await admin.from('mfa_backup_codes').delete().eq('user_id', user.id)

  // Insert new hashed codes
  const rows = hashes.map(hash => ({
    user_id: user.id,
    code_hash: hash,
  }))
  await admin.from('mfa_backup_codes').insert(rows)

  // Return plaintext codes — shown ONCE to user
  return NextResponse.json({ codes })
}
```

**Step 4: Create `src/app/api/auth/backup-codes/verify/route.ts`.**

POST endpoint that verifies a backup code, marks it as used, and sets an httpOnly session cookie to bypass the MFA middleware check. This is the ONLY approach for backup code session bypass — Supabase cannot upgrade AAL via backup codes natively, so we use a secure httpOnly cookie.

```typescript
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createAdminClient } from '@/lib/supabase/admin'
import { loginRatelimit, rateLimitResponse } from '@/lib/ratelimit'
import bcrypt from 'bcryptjs'

export async function POST(request: Request) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

  // Rate limit: backup code verification is brute-force sensitive
  const { success, reset, reason } = await loginRatelimit.limit(user.id)
  if (!success && reason !== 'timeout') {
    return rateLimitResponse(reset)
  }

  const { code } = await request.json()
  if (!code) return NextResponse.json({ error: 'Code required' }, { status: 400 })

  const admin = createAdminClient()
  const { data: storedCodes } = await admin
    .from('mfa_backup_codes')
    .select('id, code_hash')
    .eq('user_id', user.id)
    .is('used_at', null)

  if (!storedCodes?.length) {
    return NextResponse.json({ error: 'No valid backup codes' }, { status: 400 })
  }

  // Try each stored hash (bcrypt.compare is constant-time)
  for (const stored of storedCodes) {
    const isValid = await bcrypt.compare(code.toUpperCase(), stored.code_hash)
    if (isValid) {
      // Mark as used
      await admin
        .from('mfa_backup_codes')
        .update({ used_at: new Date().toISOString() })
        .eq('id', stored.id)

      // Set httpOnly cookie to bypass MFA middleware check
      // This cookie tells middleware "user verified identity via backup code"
      const response = NextResponse.json({ valid: true })
      response.cookies.set('mfa_backup_verified', 'true', {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 60 * 60 * 24, // 24 hours
        path: '/',
      })
      return response
    }
  }

  return NextResponse.json({ error: 'Invalid backup code' }, { status: 400 })
}
```

**Step 5: Add rate limiting to `src/app/api/auth/backup-codes/route.ts`.**

Add `generalApiRatelimit` to the backup codes generation endpoint (Step 3 above). After the auth check, before generating codes:

```typescript
import { generalApiRatelimit, rateLimitResponse } from '@/lib/ratelimit'

// After auth check:
const { success, reset, reason } = await generalApiRatelimit.limit(user.id)
if (!success && reason !== 'timeout') {
  return rateLimitResponse(reset)
}
```
```

**Step 5: Create `src/components/auth/two-factor-setup.tsx`.**

A client component for the 2FA enrollment flow in settings. States:

1. **Idle:** "Enable two-factor authentication" button
2. **QR Code:** Shows QR code (from Supabase `mfa.enroll()`) and secret key, 6-digit TOTP input to verify enrollment
3. **Backup Codes:** After successful TOTP verification, calls `/api/auth/backup-codes` to generate codes, displays them in a grid with "Copy all" button
4. **Complete:** Shows "2FA enabled" confirmation

Implementation:
- Call `supabase.auth.mfa.enroll({ factorType: 'totp', friendlyName: 'Authenticator App' })` — returns `data.totp.qr_code` (data URI) and `data.id` (factorId)
- Display QR code as `<img src={data.totp.qr_code} />` — simpler than react-qr-code since Supabase provides the data URI directly
- Also show `data.totp.secret` as text for manual entry
- After user enters 6-digit code, verify: `supabase.auth.mfa.challenge({ factorId })` then `supabase.auth.mfa.verify({ factorId, challengeId, code })`
- On successful verify, call POST `/api/auth/backup-codes` to generate backup codes
- Display codes in a monospace grid with instructions: "Save these backup codes in a safe place. Each code can only be used once."

**Step 6: Create `src/components/auth/two-factor-verify.tsx`.**

A client component showing 2FA status and disable option. Exports `TwoFactorStatus`.

- On mount, check `supabase.auth.mfa.listFactors()` to see if TOTP is enrolled
- If enrolled: show "Two-factor authentication is enabled" with a "Disable" button
- Disable flow: call `supabase.auth.mfa.unenroll({ factorId })` after password confirmation
- Also show "Regenerate backup codes" button that calls POST `/api/auth/backup-codes`
- If not enrolled: render `<TwoFactorSetup />` component

This component wraps TwoFactorSetup and provides the status/disable UI.
  </action>
  <verify>
- `ls supabase/migrations/20260225_mfa_backup_codes.sql` — migration exists
- `grep "mfa_backup_codes" supabase/migrations/20260225_mfa_backup_codes.sql` — table created
- `ls src/app/api/auth/backup-codes/route.ts src/app/api/auth/backup-codes/verify/route.ts` — both exist
- `grep "bcrypt.hash" src/app/api/auth/backup-codes/route.ts` — codes hashed before storage
- `grep "bcrypt.compare" src/app/api/auth/backup-codes/verify/route.ts` — constant-time comparison
- `grep "generalApiRatelimit\|loginRatelimit" src/app/api/auth/backup-codes/route.ts` — rate limiting on generation
- `grep "loginRatelimit" src/app/api/auth/backup-codes/verify/route.ts` — rate limiting on verification
- `grep "mfa_backup_verified" src/app/api/auth/backup-codes/verify/route.ts` — httpOnly cookie set on success
- `grep "cookies.set.*mfa_backup_verified" src/app/api/auth/backup-codes/verify/route.ts` — cookie is set with correct name
- `grep "mfa.enroll" src/components/auth/two-factor-setup.tsx` — TOTP enrollment
- `grep "mfa.unenroll" src/components/auth/two-factor-verify.tsx` — disable functionality
- `npx tsc --noEmit` — no type errors
  </verify>
  <done>
2FA system complete: backup codes table with RLS, backup codes generation and verification API routes using bcrypt, 2FA setup component with QR code and TOTP verification, 2FA status component with disable and regenerate backup codes. Backup codes are hashed before storage and compared using bcrypt's constant-time comparison.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MFA challenge page and add 2FA section to settings</name>
  <files>src/app/(auth)/mfa-challenge/page.tsx, src/app/(auth)/mfa-challenge/mfa-challenge-form.tsx, src/app/(dashboard)/settings/page.tsx</files>
  <action>
**Step 1: Create MFA challenge page.**

Create `src/app/(auth)/mfa-challenge/page.tsx`:
```tsx
import { MfaChallengeForm } from './mfa-challenge-form'

export default function MfaChallengePage() {
  return <MfaChallengeForm />
}
```

Create `src/app/(auth)/mfa-challenge/mfa-challenge-form.tsx`:

A client component that handles the 2FA verification during login. This page is shown when the user has TOTP enrolled but their session is only aal1.

Two input modes:
1. **TOTP code** (default): 6-digit input from authenticator app
2. **Backup code**: 10-character backup code input (toggle with "Use backup code" link)

TOTP verification flow:
```typescript
// Get the enrolled TOTP factor
const { data: factors } = await supabase.auth.mfa.listFactors()
const totpFactor = factors.totp[0]
if (!totpFactor) { /* redirect to login — no factor found */ }

// Challenge + verify
const { data: challenge } = await supabase.auth.mfa.challenge({ factorId: totpFactor.id })
const { error } = await supabase.auth.mfa.verify({
  factorId: totpFactor.id,
  challengeId: challenge.id,
  code: userEnteredCode,
})
// On success: router.push('/editor')
```

Backup code verification flow — uses the httpOnly cookie approach (the ONLY supported approach):
```typescript
// Call backup code verify API — on success, the API sets an httpOnly
// 'mfa_backup_verified' cookie (see Task 1, Step 4). The middleware
// checks this cookie to allow aal1 users through.
const res = await fetch('/api/auth/backup-codes/verify', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ code: userEnteredCode }),
})
if (res.ok) {
  // Cookie is set by the response. Redirect to editor.
  router.push('/editor')
} else {
  const data = await res.json()
  setError(data.error || 'Invalid backup code')
}
```

**Why httpOnly cookie:** Supabase cannot upgrade a session from aal1 to aal2 via backup codes — only TOTP verify can do that. So after backup code verification, the verify endpoint sets an httpOnly `mfa_backup_verified` cookie (SameSite=Strict, 24h expiry). The middleware reads this cookie to allow the user through without aal2. This is the pragmatic solution.

**Step 2: Add Security section to settings page.**

In `src/app/(dashboard)/settings/page.tsx`, add a Security section after Account:

```tsx
{/* Security section */}
<section>
  <h2 className="text-lg font-semibold mb-4">Security</h2>
  <TwoFactorStatus />
</section>
```

Import `TwoFactorStatus` from `@/components/auth/two-factor-verify`.
  </action>
  <verify>
- `ls src/app/\(auth\)/mfa-challenge/page.tsx src/app/\(auth\)/mfa-challenge/mfa-challenge-form.tsx` — MFA challenge page exists
- `grep "mfa.challenge" src/app/\(auth\)/mfa-challenge/mfa-challenge-form.tsx` — TOTP challenge
- `grep "mfa.verify" src/app/\(auth\)/mfa-challenge/mfa-challenge-form.tsx` — TOTP verify
- `grep "backup-codes/verify" src/app/\(auth\)/mfa-challenge/mfa-challenge-form.tsx` — backup code option
- `grep "TwoFactorStatus" src/app/\(dashboard\)/settings/page.tsx` — 2FA in settings
- `npx tsc --noEmit` — no type errors
  </verify>
  <done>
MFA challenge page handles both TOTP and backup code verification. Backup codes use httpOnly cookie approach for session bypass. Settings page has Security section with 2FA setup/status.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update middleware for MFA AAL enforcement with redirect loop protection</name>
  <files>src/middleware.ts</files>
  <action>
**This is the highest-risk change in Plan 05.** A mistake here can lock users out or create infinite redirect loops. Be precise.

**Step 1: Add MFA enforcement to middleware.**

In `src/middleware.ts`, after the existing auth check (where `user` is available), add MFA enforcement. The logic goes INSIDE the existing protected route check:

```typescript
// MFA enforcement — check after auth check, only on protected routes
if (isProtectedRoute && user) {
  // Check MFA status
  const { data: aal } = await supabase.auth.mfa.getAuthenticatorAssuranceLevel()

  if (aal && aal.currentLevel === 'aal1' && aal.nextLevel === 'aal2') {
    // User has MFA enrolled but hasn't verified this session
    // Check for backup code bypass cookie
    const mfaBypass = request.cookies.get('mfa_backup_verified')?.value

    if (!mfaBypass && !pathname.startsWith('/mfa-challenge')) {
      return NextResponse.redirect(new URL('/mfa-challenge', request.url))
    }
  }
}
```

**Step 2: Prevent redirect loop.**

CRITICAL exclusions — the middleware must NOT redirect to `/mfa-challenge` when the user is already on `/mfa-challenge`. The `!pathname.startsWith('/mfa-challenge')` check in the code above handles this.

Also ensure these paths are NOT subject to the MFA redirect:
- `/mfa-challenge` — the MFA challenge page itself
- `/login`, `/signup`, `/forgot-password`, `/reset-password` — auth pages (unauthenticated)
- `/auth/callback` — OAuth/email callback
- `/api/auth/backup-codes/verify` — backup code verification API (called FROM mfa-challenge page)

The existing middleware likely already excludes auth pages from the protected route check. Verify that `/mfa-challenge` is in the same exclusion list, or add it.

**Step 3: Ensure `/mfa-challenge` requires authentication.**

The MFA challenge page should only be accessible to authenticated users (aal1). If an unauthenticated user hits `/mfa-challenge`, redirect to `/login`. This is likely already handled by the existing auth gate in middleware that checks `user` on protected routes. Add `/mfa-challenge` to the list of routes that require authentication if it's not already covered.

**Step 4: Handle the `mfa_backup_verified` cookie cleanup.**

When a user signs out, the `mfa_backup_verified` cookie should be cleared. Check the sign-out route (`src/app/api/auth/signout/route.ts`) and add cookie deletion:

```typescript
// In signout handler, after supabase.auth.signOut():
const response = NextResponse.redirect(new URL('/login', request.url))
response.cookies.delete('mfa_backup_verified')
return response
```

If the signout route doesn't create a response object (just calls signOut and redirects), update it to clear the cookie.
  </action>
  <verify>
- `grep "getAuthenticatorAssuranceLevel\|aal1\|aal2" src/middleware.ts` — MFA check in middleware
- `grep "mfa-challenge" src/middleware.ts` — excluded from MFA redirect loop
- `grep "mfa_backup_verified" src/middleware.ts` — backup cookie checked in middleware
- `grep "mfa_backup_verified" src/app/api/auth/backup-codes/verify/route.ts` — cookie set on verify (from Task 1)
- Manually test: authenticated user without MFA can access /editor (no redirect)
- Manually test: authenticated user WITH MFA enrolled at aal1 gets redirected to /mfa-challenge
- Manually test: user on /mfa-challenge does NOT get redirected again (no loop)
- `npx tsc --noEmit` — no type errors
  </verify>
  <done>
Middleware enforces aal2 for users with enrolled TOTP factors. Backup code bypass cookie checked alongside aal2. MFA challenge page excluded from redirect loop. Sign-out clears backup cookie. No infinite redirect possible.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. 2FA setup in settings shows QR code and verifies TOTP enrollment
3. Backup codes generated, hashed with bcrypt, stored in mfa_backup_codes table
4. Middleware redirects aal1 users with enrolled TOTP to /mfa-challenge
5. MFA challenge accepts both TOTP code and backup code
6. Settings page has Security section with TwoFactorStatus
7. /mfa-challenge excluded from MFA redirect loop
</verification>

<success_criteria>
- Users can enable/disable 2FA in settings
- 10 backup codes generated and shown once
- Middleware enforces MFA for users with enrolled TOTP
- MFA challenge page works with both TOTP and backup codes
- bcryptjs used for backup code hashing (not native bcrypt)
- No type errors
</success_criteria>

<output>
After completion, create `.planning/phases/12.6-security-hardening/12.6-05-SUMMARY.md`
</output>
