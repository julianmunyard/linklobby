---
phase: 12.6-security-hardening
plan: 07
type: execute
wave: 5
depends_on: ["12.6-02", "12.6-06"]
files_modified:
  - src/app/api/audio/upload/route.ts
  - src/app/api/audio/delete/route.ts
  - src/app/api/cards/[id]/route.ts
  - src/app/(dashboard)/settings/page.tsx
  - src/components/settings/storage-usage-bar.tsx
  - src/lib/supabase/storage.ts
  - supabase/migrations/20260225_storage_quota.sql
autonomous: true

must_haves:
  truths:
    - "Audio upload validates MIME type server-side (only audio/mpeg, audio/wav, audio/ogg, audio/mp4, audio/x-m4a accepted)"
    - "Image uploads validate MIME type (only image/jpeg, image/png, image/webp, image/gif accepted)"
    - "Audio upload checks storage quota before allowing upload — rejects with 413 if would exceed 500MB"
    - "Storage usage is tracked in profiles.storage_used_bytes column"
    - "Deleting a card also deletes its associated storage files (audio, images)"
    - "Settings page shows storage usage bar (e.g., '120 MB / 500 MB used')"
    - "Audio delete route decrements storage_used_bytes by querying Supabase Storage metadata for file size before deletion"
  artifacts:
    - path: "src/components/settings/storage-usage-bar.tsx"
      provides: "Visual storage quota usage indicator"
      exports: ["StorageUsageBar"]
    - path: "supabase/migrations/20260225_storage_quota.sql"
      provides: "Adds storage_used_bytes column to profiles table"
      contains: "storage_used_bytes"
  key_links:
    - from: "src/app/api/audio/upload/route.ts"
      to: "profiles.storage_used_bytes"
      via: "increments storage_used_bytes after successful upload"
      pattern: "storage_used_bytes"
    - from: "src/app/api/audio/delete/route.ts"
      to: "profiles.storage_used_bytes"
      via: "decrements storage_used_bytes after successful delete"
      pattern: "storage_used_bytes"
    - from: "src/app/api/cards/[id]/route.ts"
      to: "supabase.storage"
      via: "deletes associated files when card is deleted"
      pattern: "storage.*delete|remove"
---

<objective>
Add server-side MIME validation on audio uploads, implement storage quota tracking with a usage bar in settings, and clean up orphaned files on card deletion.

Purpose: File upload security prevents malicious file types from being uploaded. Storage quotas prevent abuse and excessive costs. Orphaned file cleanup ensures storage stays tidy when cards are deleted.
Output: MIME validation on uploads, storage_used_bytes tracking in profiles, storage usage bar component, orphaned file cleanup on card delete.
</objective>

<execution_context>
@/Users/julianmunyard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianmunyard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.6-security-hardening/12.6-RESEARCH.md
@src/app/api/audio/upload/route.ts
@src/app/api/audio/delete/route.ts
@src/app/api/cards/[id]/route.ts
@src/app/(dashboard)/settings/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MIME validation to audio upload, create storage quota migration, and implement quota checking</name>
  <files>src/app/api/audio/upload/route.ts, supabase/migrations/20260225_storage_quota.sql</files>
  <action>
**Step 1: Create migration `supabase/migrations/20260225_storage_quota.sql`.**

```sql
-- Add storage usage tracking to profiles
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS storage_used_bytes BIGINT DEFAULT 0;

-- Storage quota constant: 500MB for free tier
-- This is enforced in application code, not in the database
COMMENT ON COLUMN profiles.storage_used_bytes IS 'Tracks total storage used across all buckets. 500MB free tier limit enforced in API routes.';
```

**Step 2: Add MIME type validation to `src/app/api/audio/upload/route.ts`.**

After the file size check and before any processing, validate the MIME type:

```typescript
// Allowed audio MIME types
const ALLOWED_AUDIO_TYPES = [
  'audio/mpeg',      // .mp3
  'audio/wav',       // .wav
  'audio/x-wav',     // .wav (alternative)
  'audio/ogg',       // .ogg
  'audio/mp4',       // .m4a
  'audio/x-m4a',     // .m4a (alternative)
  'audio/aac',       // .aac
  'audio/flac',      // .flac
  'audio/webm',      // .webm
]

// Validate MIME type
if (!ALLOWED_AUDIO_TYPES.includes(file.type)) {
  return NextResponse.json(
    { error: `Unsupported audio format: ${file.type}. Supported formats: MP3, WAV, OGG, M4A, AAC, FLAC, WebM.` },
    { status: 415 }
  )
}
```

Place this check AFTER the file size check but BEFORE `file.arrayBuffer()` (no need to read the whole file if the type is wrong).

NOTE: The `file.type` comes from the browser's Content-Type header for the FormData part. This is a best-effort check — a determined attacker could forge it. But it catches accidental uploads of wrong file types (images, videos, documents) which is the primary concern.

**Step 3: Add MIME type validation to image uploads.**

Image uploads go directly from client to Supabase Storage (no server-side API route). Add client-side MIME validation in `src/lib/supabase/storage.ts` (or wherever `uploadCardImageBlob`, `uploadCardImage`, `uploadProfileImage` are defined).

Add a MIME check before the Supabase storage upload call:

```typescript
const ALLOWED_IMAGE_TYPES = [
  'image/jpeg',
  'image/png',
  'image/webp',
  'image/gif',
]

// Before uploading:
if (!ALLOWED_IMAGE_TYPES.includes(file.type)) {
  throw new Error(`Unsupported image format: ${file.type}. Supported formats: JPEG, PNG, WebP, GIF.`)
}
```

Apply this check to ALL image upload functions in the storage utility file. Search for `upload` calls to `card-images`, `profile-images` buckets and add the MIME check before each one.

This is client-side enforcement since image uploads bypass the server. For defense-in-depth, also configure Supabase Storage bucket policies (via Supabase Dashboard) to restrict allowed MIME types on `card-images` and `profile-images` buckets. Document this as a user_setup step:

NOTE for executor: After implementing the client-side check, the user should also configure bucket-level MIME restrictions in Supabase Dashboard -> Storage -> card-images -> Policies -> Add restriction for allowed MIME types. This provides server-side enforcement that can't be bypassed.

**Step 4 (was Step 3): Add storage quota check to audio upload route.**

After the auth check, query the user's current storage usage and check against the 500MB limit:

```typescript
const STORAGE_QUOTA_BYTES = 500 * 1024 * 1024 // 500MB

// Check storage quota
const { data: profile } = await supabase
  .from('profiles')
  .select('storage_used_bytes')
  .eq('id', user.id)
  .single()

const currentUsage = profile?.storage_used_bytes || 0
if (currentUsage + file.size > STORAGE_QUOTA_BYTES) {
  const usedMB = Math.round(currentUsage / (1024 * 1024))
  const fileMB = Math.round(file.size / (1024 * 1024))
  return NextResponse.json(
    { error: `Storage quota exceeded. You're using ${usedMB}MB of 500MB. This file is ${fileMB}MB.` },
    { status: 413 }
  )
}
```

**Step 5 (was Step 4): Increment storage_used_bytes after successful upload.**

After the successful upload (after getting the public URL), update the storage usage. Use the `finalBuffer.length` (the actual stored size, after MP3 conversion) not `file.size` (the original upload size):

```typescript
// Update storage usage
await supabase
  .from('profiles')
  .update({ storage_used_bytes: currentUsage + finalBuffer.length })
  .eq('id', user.id)
```

This uses the server Supabase client which has the user's auth context, so RLS allows the update.
  </action>
  <verify>
- `ls supabase/migrations/20260225_storage_quota.sql` — migration exists
- `grep "storage_used_bytes" supabase/migrations/20260225_storage_quota.sql` — column added
- `grep "ALLOWED_AUDIO_TYPES" src/app/api/audio/upload/route.ts` — audio MIME validation
- `grep "ALLOWED_IMAGE_TYPES" src/lib/supabase/storage.ts` — image MIME validation
- `grep "image/jpeg\|image/png\|image/webp\|image/gif" src/lib/supabase/storage.ts` — all 4 image types checked
- `grep "STORAGE_QUOTA_BYTES\|storage quota" src/app/api/audio/upload/route.ts` — quota check
- `grep "storage_used_bytes" src/app/api/audio/upload/route.ts` — usage tracking
- `npx tsc --noEmit` — no type errors
  </verify>
  <done>
Audio upload now validates MIME type (rejects non-audio files with 415), checks storage quota before upload (rejects with 413 if would exceed 500MB), and increments storage_used_bytes after successful upload. Migration adds storage_used_bytes column to profiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement orphaned file cleanup on card delete, storage decrement on audio delete, and storage usage bar</name>
  <files>src/app/api/cards/[id]/route.ts, src/app/api/audio/delete/route.ts, src/components/settings/storage-usage-bar.tsx, src/app/(dashboard)/settings/page.tsx</files>
  <action>
**Step 1: Add orphaned file cleanup to card DELETE handler.**

In `src/app/api/cards/[id]/route.ts`, when a card is deleted, also delete its associated storage files. Read the file first to understand the current delete handler structure.

After the card is deleted from the database, clean up associated storage:

```typescript
// After successful card deletion from DB, clean up storage files
// Audio files are stored at: card-audio/{cardId}/
// Image files are stored at: card-images/{cardId}/

// List and delete audio files for this card
const { data: audioFiles } = await supabase.storage
  .from('card-audio')
  .list(cardId)

if (audioFiles?.length) {
  const audioFilePaths = audioFiles.map(f => `${cardId}/${f.name}`)
  await supabase.storage.from('card-audio').remove(audioFilePaths)

  // Calculate total bytes removed for storage tracking
  const audioBytes = audioFiles.reduce((sum, f) => sum + (f.metadata?.size || 0), 0)
  if (audioBytes > 0) {
    const { data: profile } = await supabase
      .from('profiles')
      .select('storage_used_bytes')
      .eq('id', user.id)
      .single()
    const newUsage = Math.max(0, (profile?.storage_used_bytes || 0) - audioBytes)
    await supabase
      .from('profiles')
      .update({ storage_used_bytes: newUsage })
      .eq('id', user.id)
  }
}

// List and delete image files for this card
const { data: imageFiles } = await supabase.storage
  .from('card-images')
  .list(cardId)

if (imageFiles?.length) {
  const imageFilePaths = imageFiles.map(f => `${cardId}/${f.name}`)
  await supabase.storage.from('card-images').remove(imageFilePaths)
}
```

Do NOT let storage cleanup failures prevent the card deletion response — wrap in try/catch and log errors but don't fail the request. The card is already deleted from the DB at this point.

**Step 2: Add storage decrement to audio delete route.**

In `src/app/api/audio/delete/route.ts`, BEFORE deleting the audio file from storage, query Supabase Storage to get the file's metadata (including size). Then delete the file, then decrement `storage_used_bytes`.

Read the file first to understand the current structure. The route likely takes a storage path and deletes it.

**File size source: Query Supabase Storage metadata BEFORE deletion.** Do NOT rely on the client sending file_size_bytes (untrusted). Do NOT skip the size lookup (causes quota drift).

```typescript
// BEFORE deleting: get file size from Supabase Storage metadata
// The storage path is something like "{userId}/{cardId}/audio.mp3"
const { data: fileList } = await supabase.storage
  .from('card-audio')
  .list(directoryPath, { limit: 100 })

// Find the specific file and get its size from metadata
const fileInfo = fileList?.find(f => f.name === fileName)
const fileSize = fileInfo?.metadata?.size || 0

// Now delete the file
await supabase.storage.from('card-audio').remove([storagePath])

// Decrement storage usage
if (fileSize > 0) {
  const { data: profile } = await supabase
    .from('profiles')
    .select('storage_used_bytes')
    .eq('id', user.id)
    .single()

  if (profile) {
    const newUsage = Math.max(0, (profile.storage_used_bytes || 0) - fileSize)
    await supabase
      .from('profiles')
      .update({ storage_used_bytes: newUsage })
      .eq('id', user.id)
  }
}
```

The `list()` call returns file metadata including `size` in the `metadata` field. If `list()` doesn't return size in metadata, use an alternative: call `supabase.storage.from('card-audio').info(storagePath)` if available in the SDK version, or fall back to accepting the inaccuracy with a logged warning. But always TRY to get the size first.

**Step 3: Create `src/components/settings/storage-usage-bar.tsx`.**

A visual component showing storage usage as a progress bar.

Props: `usedBytes: number, quotaBytes: number`

```typescript
'use client'

interface StorageUsageBarProps {
  usedBytes: number
  quotaBytes: number
}

export function StorageUsageBar({ usedBytes, quotaBytes }: StorageUsageBarProps) {
  const usedMB = Math.round(usedBytes / (1024 * 1024))
  const quotaMB = Math.round(quotaBytes / (1024 * 1024))
  const percentage = Math.min(100, Math.round((usedBytes / quotaBytes) * 100))

  // Color: green < 50%, yellow 50-80%, red > 80%
  const barColor = percentage > 80 ? 'bg-red-500' : percentage > 50 ? 'bg-yellow-500' : 'bg-green-500'

  return (
    <div className="space-y-2">
      <div className="flex justify-between text-sm">
        <span className="text-muted-foreground">Storage</span>
        <span>{usedMB} MB / {quotaMB} MB</span>
      </div>
      <div className="h-2 rounded-full bg-muted overflow-hidden">
        <div
          className={`h-full rounded-full transition-all ${barColor}`}
          style={{ width: `${percentage}%` }}
        />
      </div>
    </div>
  )
}
```

**Step 4: Add StorageUsageBar to settings page.**

In `src/app/(dashboard)/settings/page.tsx`, add a Storage section. Fetch `storage_used_bytes` from the profile query (expand the existing query to include it):

```tsx
const { data: profile } = await supabase
  .from('profiles')
  .select('username, storage_used_bytes')
  .eq('id', user.id)
  .single()

// In the render:
<section>
  <h2 className="text-lg font-semibold mb-4">Storage</h2>
  <StorageUsageBar
    usedBytes={profile?.storage_used_bytes || 0}
    quotaBytes={500 * 1024 * 1024}
  />
</section>
```

Import `StorageUsageBar` from `@/components/settings/storage-usage-bar`.
  </action>
  <verify>
- `grep "card-audio.*remove\|storage.*remove" src/app/api/cards/\\[id\\]/route.ts` — file cleanup on card delete
- `grep "storage_used_bytes" src/app/api/audio/delete/route.ts` — decrement on audio delete
- `ls src/components/settings/storage-usage-bar.tsx` — exists
- `grep "StorageUsageBar" src/app/\(dashboard\)/settings/page.tsx` — rendered in settings
- `grep "storage_used_bytes" src/app/\(dashboard\)/settings/page.tsx` — fetched from profile
- `npx tsc --noEmit` — no type errors
  </verify>
  <done>
Card deletion now cleans up associated audio and image files from storage. Audio delete decrements storage_used_bytes. Storage usage bar shows visual progress in settings. Storage quota is tracked per-user in profiles.storage_used_bytes column.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Audio upload validates MIME type (rejects non-audio with 415)
3. Image upload validates MIME type (rejects non-image types)
4. Audio upload checks quota (rejects over 500MB with 413)
5. Audio upload increments storage_used_bytes
6. Audio delete queries file size from Storage metadata BEFORE deletion, then decrements storage_used_bytes
7. Card delete cleans up associated storage files
8. Settings shows storage usage bar with correct data
</verification>

<success_criteria>
- Audio MIME validation rejects non-audio file types
- Image MIME validation rejects non-image file types (jpeg, png, webp, gif only)
- Storage quota enforced at 500MB per user
- Storage usage tracked and displayed in settings
- Audio delete gets file size from Supabase Storage metadata before deleting
- Card deletion cleans up orphaned files
- No type errors
</success_criteria>

<output>
After completion, create `.planning/phases/12.6-security-hardening/12.6-07-SUMMARY.md`
</output>
