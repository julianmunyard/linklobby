---
phase: 12.6-security-hardening
plan: 02
type: execute
wave: 2
depends_on: ["12.6-01"]
files_modified:
  - src/lib/ratelimit/index.ts
  - src/app/api/auth/signout/route.ts
  - src/app/api/cards/route.ts
  - src/app/api/cards/[id]/route.ts
  - src/app/api/cards/bulk/route.ts
  - src/app/api/theme/route.ts
  - src/app/api/profile/route.ts
  - src/app/api/audio/upload/route.ts
  - src/app/api/audio/delete/route.ts
  - src/app/api/page/route.ts
  - src/app/api/emails/route.ts
  - src/app/api/analytics/track/route.ts
  - src/app/api/analytics/stats/route.ts
  - src/app/api/legal/delete-account/route.ts
  - src/app/api/templates/apply/route.ts
  - src/app/api/import/linktree/route.ts
  - src/app/api/mailchimp/sync/route.ts
autonomous: true

user_setup:
  - service: upstash
    why: "Serverless Redis for rate limiting — Upstash is the standard Redis provider for Vercel"
    env_vars:
      - name: UPSTASH_REDIS_REST_URL
        source: "Upstash Console -> Create Database -> REST URL"
      - name: UPSTASH_REDIS_REST_TOKEN
        source: "Upstash Console -> Create Database -> REST Token"
    dashboard_config:
      - task: "Create a new Redis database (free tier is fine for dev)"
        location: "https://console.upstash.com/ -> Create Database -> Select region closest to Vercel deployment"

must_haves:
  truths:
    - "Login/signup attempts are rate-limited to prevent brute force (5/15min login, 3/hr signup)"
    - "Audio uploads are rate-limited to 5/hour per user"
    - "Public endpoints (email collection, analytics) are rate-limited by IP"
    - "General API routes are rate-limited to 60/min per user"
    - "Rate limiting fails open if Redis is unavailable (requests are allowed through)"
    - "429 responses include Retry-After header"
  artifacts:
    - path: "src/lib/ratelimit/index.ts"
      provides: "Pre-configured rate limit instances for all endpoint categories"
      exports: ["loginRatelimit", "signupRatelimit", "passwordResetRatelimit", "emailCollectionRatelimit", "audioUploadRatelimit", "generalApiRatelimit", "analyticsRatelimit"]
  key_links:
    - from: "src/app/api/cards/route.ts"
      to: "src/lib/ratelimit/index.ts"
      via: "imports generalApiRatelimit for POST handler"
      pattern: "generalApiRatelimit"
    - from: "src/app/api/audio/upload/route.ts"
      to: "src/lib/ratelimit/index.ts"
      via: "imports audioUploadRatelimit for POST handler"
      pattern: "audioUploadRatelimit"
    - from: "src/app/api/analytics/track/route.ts"
      to: "src/lib/ratelimit/index.ts"
      via: "imports analyticsRatelimit for POST handler"
      pattern: "analyticsRatelimit"
---

<objective>
Install Upstash Redis rate limiting and apply endpoint-specific rate limits to all API routes.

Purpose: Rate limiting prevents brute force attacks on auth endpoints, abuse of upload/email endpoints, and general API abuse. This is a critical security layer before going to production.
Output: Rate limit library with pre-configured instances, all API routes wrapped with appropriate rate limits.
</objective>

<execution_context>
@/Users/julianmunyard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianmunyard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.6-security-hardening/12.6-RESEARCH.md
@src/app/api/cards/route.ts
@src/app/api/audio/upload/route.ts
@src/app/api/analytics/track/route.ts
@src/app/api/emails/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Upstash packages and create rate limit instances</name>
  <files>src/lib/ratelimit/index.ts</files>
  <action>
**Step 1: Install Upstash packages.**

```bash
npm install @upstash/ratelimit @upstash/redis
```

**Step 2: Create `src/lib/ratelimit/index.ts`.**

Create all rate limit instances at module level (NOT inside request handlers — this would create new Redis connections per request). Each instance uses a different prefix and sliding window configuration.

Use `Redis.fromEnv()` which reads `UPSTASH_REDIS_REST_URL` and `UPSTASH_REDIS_REST_TOKEN` automatically.

Set `timeout: 3000` on ALL instances for fail-open behavior: if Redis doesn't respond in 3 seconds, the request is allowed through.

```typescript
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

const redis = Redis.fromEnv()

// Auth endpoints
export const loginRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(5, '15 m'),
  timeout: 3000,
  prefix: 'rl:login',
})

export const signupRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(3, '1 h'),
  timeout: 3000,
  prefix: 'rl:signup',
})

export const passwordResetRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(3, '15 m'),
  timeout: 3000,
  prefix: 'rl:reset',
})

// Public endpoints (keyed by IP)
export const emailCollectionRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '1 m'),
  timeout: 3000,
  prefix: 'rl:email',
})

export const analyticsRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(30, '1 m'),
  timeout: 3000,
  prefix: 'rl:analytics',
})

// Authenticated endpoints (keyed by user ID)
export const audioUploadRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(5, '1 h'),
  timeout: 3000,
  prefix: 'rl:audio',
})

export const generalApiRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(60, '1 m'),
  timeout: 3000,
  prefix: 'rl:api',
})
```

Also export a helper to get client IP from request headers (Vercel uses x-forwarded-for):

```typescript
export function getClientIp(request: Request): string {
  return request.headers.get('x-forwarded-for')?.split(',')[0].trim()
    ?? request.headers.get('x-real-ip')
    ?? '127.0.0.1'
}
```

And export a helper to create a 429 response:

```typescript
import { NextResponse } from 'next/server'

export function rateLimitResponse(reset: number) {
  const retryAfter = Math.ceil((reset - Date.now()) / 1000)
  return NextResponse.json(
    { error: 'Too many requests. Please try again later.' },
    { status: 429, headers: { 'Retry-After': String(retryAfter) } }
  )
}
```
  </action>
  <verify>
- `ls src/lib/ratelimit/index.ts` — exists
- `grep "@upstash/ratelimit" package.json` — dependency installed
- `grep "@upstash/redis" package.json` — dependency installed
- `grep "timeout: 3000" src/lib/ratelimit/index.ts` — fail-open configured
- `grep "getClientIp" src/lib/ratelimit/index.ts` — IP helper exists
- `npx tsc --noEmit` — no type errors
  </verify>
  <done>
Upstash packages installed. Rate limit instances created for all 7 endpoint categories with sliding window algorithms and fail-open timeout. IP extraction helper and 429 response helper exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply rate limits to all API routes</name>
  <files>src/app/api/cards/route.ts, src/app/api/cards/[id]/route.ts, src/app/api/cards/bulk/route.ts, src/app/api/theme/route.ts, src/app/api/profile/route.ts, src/app/api/audio/upload/route.ts, src/app/api/audio/delete/route.ts, src/app/api/page/route.ts, src/app/api/emails/route.ts, src/app/api/analytics/track/route.ts, src/app/api/analytics/stats/route.ts, src/app/api/legal/delete-account/route.ts, src/app/api/templates/apply/route.ts, src/app/api/import/linktree/route.ts, src/app/api/mailchimp/sync/route.ts, src/app/api/auth/signout/route.ts</files>
  <action>
Apply rate limiting to each API route. The pattern depends on whether the endpoint is public (key by IP) or authenticated (key by user ID).

**Pattern for authenticated routes (keyed by user ID):**

```typescript
import { generalApiRatelimit, rateLimitResponse } from '@/lib/ratelimit'

// Inside the handler, AFTER auth check (so we have user.id), BEFORE business logic:
const { success, reset, reason } = await generalApiRatelimit.limit(user.id)
if (!success && reason !== 'timeout') {
  return rateLimitResponse(reset)
}
```

The `reason !== 'timeout'` check implements fail-open: when Redis is unreachable, the timeout causes the limit() call to return `{ success: false, reason: 'timeout' }`, and we let the request through.

**Pattern for public routes (keyed by IP):**

```typescript
import { emailCollectionRatelimit, getClientIp, rateLimitResponse } from '@/lib/ratelimit'

// At the top of the handler, before any other logic:
const ip = getClientIp(request)
const { success, reset, reason } = await emailCollectionRatelimit.limit(ip)
if (!success && reason !== 'timeout') {
  return rateLimitResponse(reset)
}
```

**Route-to-limiter mapping:**

Authenticated routes (use `generalApiRatelimit`, keyed by `user.id`):
- `src/app/api/cards/route.ts` — POST handler
- `src/app/api/cards/[id]/route.ts` — PUT and DELETE handlers
- `src/app/api/cards/bulk/route.ts` — POST handler
- `src/app/api/theme/route.ts` — POST/PUT handler
- `src/app/api/profile/route.ts` — POST/PUT handler
- `src/app/api/page/route.ts` — POST/PUT handler
- `src/app/api/analytics/stats/route.ts` — GET handler (authenticated dashboard stats)
- `src/app/api/legal/delete-account/route.ts` — POST/DELETE handler
- `src/app/api/legal/export-data/route.ts` — does NOT need rate limiting (already heavy, infrequent)
- `src/app/api/templates/apply/route.ts` — POST handler
- `src/app/api/import/linktree/route.ts` — POST handler
- `src/app/api/mailchimp/sync/route.ts` — POST handler
- `src/app/api/auth/signout/route.ts` — POST handler

Special authenticated routes (use specific limiters, keyed by `user.id`):
- `src/app/api/audio/upload/route.ts` — use `audioUploadRatelimit` (5/hour)
- `src/app/api/audio/delete/route.ts` — use `generalApiRatelimit` (60/min)
- `src/app/api/auth/backup-codes/route.ts` — use `generalApiRatelimit` (60/min) — created by Plan 05, but add rate limiting here when it exists
- `src/app/api/auth/backup-codes/verify/route.ts` — use `loginRatelimit` (5/15min, keyed by `user.id`) — brute force sensitive, treat like login

Public routes (keyed by IP):
- `src/app/api/emails/route.ts` — use `emailCollectionRatelimit` (10/min per IP)
- `src/app/api/analytics/track/route.ts` — use `analyticsRatelimit` (30/min per IP)

NOTE: The backup code routes are created by Plan 05 (Wave 3). When this plan (Wave 2) runs, these routes won't exist yet. Plan 05 Task 1 is responsible for adding rate limiting to both backup code routes at creation time. The mapping above documents which limiter each route should use.

NOTE on auth rate limiters: `loginRatelimit`, `signupRatelimit`, and `passwordResetRatelimit` are defined here but NOT applied in this plan. Auth flows (login, signup, forgot-password) are client-side Supabase calls — they go directly from the browser to Supabase's API, not through our Next.js API routes. Supabase's own infrastructure rate-limits these endpoints. The instances are exported for potential future use if auth flows are ever routed through custom API endpoints, but for now they serve as documented configuration only. Do NOT create dummy routes just to apply them.

For GET-only routes that are authenticated (e.g., `src/app/api/cards/route.ts` GET), apply `generalApiRatelimit` to the GET handler as well to prevent excessive polling.

Place the rate limit check AFTER auth check (for authenticated routes) so we can use `user.id` as the key. For public routes, place it at the very top of the handler.
  </action>
  <verify>
- `grep "generalApiRatelimit" src/app/api/cards/route.ts` — rate limit in cards
- `grep "audioUploadRatelimit" src/app/api/audio/upload/route.ts` — specific limiter for audio
- `grep "emailCollectionRatelimit" src/app/api/emails/route.ts` — IP-based limit on public email
- `grep "analyticsRatelimit" src/app/api/analytics/track/route.ts` — IP-based limit on analytics
- `grep "getClientIp" src/app/api/emails/route.ts` — IP extraction used for public endpoint
- `grep "reason !== 'timeout'" src/app/api/cards/route.ts` — fail-open check present
- `npx tsc --noEmit` — no type errors
  </verify>
  <done>
All API routes have appropriate rate limiting applied. Authenticated routes use user ID as key, public routes use client IP. Audio uploads have stricter limits (5/hour). Fail-open behavior ensures Redis outages don't block all requests. 429 responses include Retry-After header.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Rate limit instances created at module level (not inside handlers)
3. All authenticated mutation routes use generalApiRatelimit or specific limiter
4. Audio upload uses audioUploadRatelimit (5/hour)
5. Public endpoints use IP-based rate limiting
6. fail-open check (`reason !== 'timeout'`) present in all rate limit usages
7. 429 responses include Retry-After header
</verification>

<success_criteria>
- @upstash/ratelimit and @upstash/redis installed
- 7 rate limit instances configured with correct sliding windows
- All API routes have rate limiting applied
- Fail-open behavior works (timeout = allow through)
- No type errors
</success_criteria>

<output>
After completion, create `.planning/phases/12.6-security-hardening/12.6-02-SUMMARY.md`
</output>
