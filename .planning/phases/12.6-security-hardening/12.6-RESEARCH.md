# Phase 12.6: Security Hardening & Auth Completion - Research

**Researched:** 2026-02-25
**Domain:** Authentication, Rate Limiting, Security Headers, Input Sanitization, CSRF, Cookie Consent
**Confidence:** HIGH (most areas verified with official docs or Context7)

---

## Summary

Phase 12.6 covers a wide surface: completing the auth system, protecting API endpoints, hardening HTTP headers, sanitizing input, and wiring cookie consent. Research confirmed that most of the standard stack is already present or straightforward to add, but there are two important surprises that will affect planning.

**Surprise 1 — Backup codes don't exist in Supabase MFA.** Supabase explicitly does not support backup/recovery codes. Their recommendation is to have users enroll a second TOTP factor as backup. The CONTEXT.md specifies "10 backup codes, show once, single-use" — this cannot be implemented with Supabase Auth natively. Custom backup codes require generating them server-side, hashing and storing them in the database, and verifying against them during login. This is the most complex non-obvious task in the phase.

**Surprise 2 — CSP with nonces forces dynamic rendering.** Next.js recommends nonce-based CSP for strict security, but this disables static generation for all pages. Given this app has complex public pages with third-party embeds (Spotify, YouTube, SoundCloud, Superpowered WASM), a simpler `'unsafe-inline'` + trusted host whitelist approach is more practical. This avoids performance regression on public pages.

**Primary recommendation:** Implement the 20 items in sequence across 4 areas: auth flows first (unblocks UX), then rate limiting (protects endpoints), then security headers + sanitization (hardening), then storage quotas + cleanup (data management). Cookie consent is already 80% done — it just needs wiring to the `is_published` gate.

---

## Standard Stack

### Core (already in package.json or trivially added)

| Library | Version | Purpose | Status |
|---------|---------|---------|--------|
| `@supabase/supabase-js` | 2.91.0 (installed) | Auth: OAuth, MFA, password reset, session management | Already installed |
| `@supabase/ssr` | 0.8.0 (installed) | Server-side Supabase client | Already installed |
| `react-cookie-consent` | 10.0.1 (installed) | Cookie consent banner | Already installed, partially wired |
| `react-qr-code` | already installed | QR code display for 2FA setup | Already installed, used in fan-tools |
| `@upstash/ratelimit` | 2.0.8 | Rate limiting for API routes | Not installed, needs `npm install` |
| `@upstash/redis` | 1.36.2 | Redis client for Upstash | Not installed, needs `npm install` |
| `isomorphic-dompurify` | latest | Server-side HTML sanitization (wraps DOMPurify + jsdom) | Not installed, needs `npm install` |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `zod` | 4.3.6 (installed) | Input validation schemas | Already used in several API routes |
| `react-hook-form` | 7.71.1 (installed) | Auth form management | Already used in login/signup forms |
| `@hookform/resolvers` | 5.2.2 (installed) | Zod-hookform integration | Already installed |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| `isomorphic-dompurify` | `sanitize-html` | `sanitize-html` is simpler API but less battle-tested for XSS |
| `@upstash/ratelimit` | Custom Redis or in-memory | Not serverless-compatible; Upstash is the standard for Vercel |
| Supabase MFA backup codes | Custom DB backup codes | Supabase has no native backup codes — must build custom |

**Installation:**
```bash
npm install @upstash/ratelimit @upstash/redis isomorphic-dompurify
npm install -D @types/dompurify  # if needed
```

---

## Architecture Patterns

### Recommended Project Structure for New Files

```
src/
├── lib/
│   ├── ratelimit/
│   │   └── index.ts          # Ratelimit instances (login, signup, general, etc.)
│   ├── sanitize/
│   │   └── index.ts          # DOMPurify sanitize helpers
│   └── csrf/
│       └── index.ts          # Origin header validation helper
├── app/
│   ├── (auth)/
│   │   ├── login/            # Add: Google OAuth button, "Forgot password?" link
│   │   ├── signup/           # Add: Google OAuth button, email verification prompt
│   │   ├── forgot-password/  # New page
│   │   ├── reset-password/   # New page (handles recovery redirect)
│   │   └── verify-email/     # New page (handles email confirmation redirect)
│   ├── auth/
│   │   └── callback/         # Already exists — handles OAuth + recovery redirects
│   └── (dashboard)/
│       └── settings/
│           ├── page.tsx      # Expand with security sections
│           ├── account/      # Change email, change password
│           ├── security/     # 2FA setup, session management
│           └── storage/      # Storage quota display
└── components/
    ├── auth/
    │   ├── google-oauth-button.tsx
    │   ├── two-factor-setup.tsx
    │   ├── two-factor-verify.tsx
    │   └── session-list.tsx
    └── settings/
        ├── change-password-form.tsx
        ├── change-email-form.tsx
        └── storage-usage-bar.tsx
```

### Pattern 1: Rate Limiting — Reusable Helper

Create rate limit instances once at module level (not inside request handlers). Each instance is configured for a specific use case.

```typescript
// Source: https://upstash.com/docs/redis/sdks/ratelimit-ts/features
// src/lib/ratelimit/index.ts
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

const redis = Redis.fromEnv()

export const loginRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(5, '15 m'),
  timeout: 3000, // fail-open: allow request if Redis doesn't respond in 3s
  prefix: 'rl:login',
})

export const signupRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(3, '1 h'),
  timeout: 3000,
  prefix: 'rl:signup',
})

export const passwordResetRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(3, '15 m'),
  timeout: 3000,
  prefix: 'rl:reset',
})

export const emailCollectionRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '1 m'),
  timeout: 3000,
  prefix: 'rl:email',
})

export const audioUploadRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(5, '1 h'),
  timeout: 3000,
  prefix: 'rl:audio',
})

export const generalApiRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(60, '1 m'),
  timeout: 3000,
  prefix: 'rl:api',
})

export const analyticsRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(30, '1 m'),
  timeout: 3000,
  prefix: 'rl:analytics',
})
```

### Pattern 2: Rate Limit Usage in API Route

```typescript
// Source: https://upstash.com/docs/redis/sdks/ratelimit-ts/methods
export async function POST(request: NextRequest) {
  // Get identifier (IP for public, userId for authenticated)
  const ip = request.headers.get('x-forwarded-for')?.split(',')[0].trim()
    ?? request.headers.get('x-real-ip')
    ?? '127.0.0.1'

  const { success, reset, remaining, reason } = await loginRatelimit.limit(ip)

  if (!success && reason !== 'timeout') {
    const retryAfter = Math.ceil((reset - Date.now()) / 1000)
    return NextResponse.json(
      { error: 'Too many attempts. Please try again later.' },
      {
        status: 429,
        headers: { 'Retry-After': String(retryAfter) }
      }
    )
  }
  // ... rest of handler
}
```

The `reason === 'timeout'` check implements fail-open: when Redis is unreachable, the `timeout` option causes the request to be allowed through with `reason: 'timeout'`.

### Pattern 3: Google OAuth

```typescript
// Source: https://supabase.com/docs/guides/auth/social-login/auth-google
// In login-form.tsx — add button:
async function signInWithGoogle() {
  const supabase = createClient()
  await supabase.auth.signInWithOAuth({
    provider: 'google',
    options: {
      redirectTo: `${window.location.origin}/auth/callback`,
      // scopes: 'profile email' is default
    },
  })
}
```

The existing `/auth/callback/route.ts` already handles the OAuth code exchange correctly via `exchangeCodeForSession(code)`. No changes needed to callback route.

### Pattern 4: Password Reset Flow

```typescript
// Source: https://supabase.com/docs/guides/auth/passwords
// Step 1: Request reset
await supabase.auth.resetPasswordForEmail(email, {
  redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/reset-password`,
})

// Step 2: On /auth/reset-password page, after callback exchanges token:
await supabase.auth.updateUser({ password: newPassword })
```

The callback route handles the `type=recovery` case. When a recovery link is clicked, Supabase redirects to `/auth/callback?code=...&type=recovery`. The existing callback already handles `exchangeCodeForSession`, then should redirect to `/auth/reset-password` instead of `/editor` when `type=recovery` is present.

### Pattern 5: Email Verification

Supabase uses `email_confirmed_at` on the user object to track verification status.

```typescript
// Check verification status
const { data: { user } } = await supabase.auth.getUser()
const isEmailVerified = !!user?.email_confirmed_at

// Enable email confirmation in Supabase Dashboard:
// Authentication > Providers > Email > Enable email confirmations

// After signup, redirect to email verification pending page
// Email confirmation link redirects to /auth/callback?type=signup
// Callback then redirects to /editor
```

### Pattern 6: Change Password (requires current password)

Supabase's `updateUser({ password })` does NOT require current password. To enforce re-authentication:

```typescript
// Re-authenticate first, then update
const { error: reAuthError } = await supabase.auth.signInWithPassword({
  email: user.email,
  password: currentPassword,
})
if (reAuthError) return // show error

const { error } = await supabase.auth.updateUser({ password: newPassword })
```

### Pattern 7: TOTP 2FA Enrollment

```typescript
// Source: https://supabase.com/docs/reference/javascript/auth-mfa-enroll
// Step 1: Enroll
const { data, error } = await supabase.auth.mfa.enroll({
  factorType: 'totp',
  friendlyName: 'Authenticator App',
})
const { id: factorId, totp: { qr_code, secret, uri } } = data
// qr_code is a data URI — render with <img src={qr_code} />
// OR use react-qr-code with uri

// Step 2: Verify enrollment
const { data: challenge } = await supabase.auth.mfa.challenge({ factorId })
const { error: verifyError } = await supabase.auth.mfa.verify({
  factorId,
  challengeId: challenge.id,
  code: totpCode, // 6 digits from authenticator app
})

// Step 3: Login challenge (after password auth succeeds, if AAL1 and factor enrolled)
const { data: { currentLevel, nextLevel } } = await supabase.auth.mfa.getAuthenticatorAssuranceLevel()
if (currentLevel === 'aal1' && nextLevel === 'aal2') {
  // Prompt for TOTP code
}
```

### Pattern 8: Backup Codes (Custom Implementation Required)

Supabase has NO native backup code support. Custom implementation:

```typescript
// Migration: add mfa_backup_codes table
// CREATE TABLE mfa_backup_codes (
//   id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
//   user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
//   code_hash TEXT NOT NULL,  -- bcrypt hash of the code
//   used_at TIMESTAMPTZ,
//   created_at TIMESTAMPTZ DEFAULT NOW()
// );

// Server-side generation (in API route):
import crypto from 'crypto'
import bcrypt from 'bcrypt'

function generateBackupCodes(count = 10): string[] {
  return Array.from({ length: count }, () =>
    crypto.randomBytes(5).toString('hex').toUpperCase() // 10-char codes like "A3F9B2C1D0"
  )
}

// Store hashed codes, return plaintext once to user
const codes = generateBackupCodes(10)
const hashes = await Promise.all(codes.map(c => bcrypt.hash(c, 10)))
// INSERT hashes into mfa_backup_codes

// Verification: try each stored hash against submitted code
const isValid = await bcrypt.compare(submittedCode, storedHash)
if (isValid) {
  // Mark as used: UPDATE mfa_backup_codes SET used_at = NOW() WHERE id = ...
}
```

**Note:** This requires adding `bcrypt` or `bcryptjs` to dependencies.

### Pattern 9: Session Management

Supabase `signOut` supports three scopes. No native "list sessions" API exists.

```typescript
// Source: https://supabase.com/docs/guides/auth/signout
await supabase.auth.signOut({ scope: 'global' })   // all sessions
await supabase.auth.signOut({ scope: 'local' })    // current session only
await supabase.auth.signOut({ scope: 'others' })   // all except current
```

For "view active sessions" UI: Supabase does not expose a public API to list sessions. The `auth.sessions` table exists internally but is not accessible via the JS client. Options:
1. Show simplified UI: "Current session" + "Sign out other sessions" button (uses `scope: 'others'`)
2. If a detailed session list is required, it needs Supabase Admin API (service role key, server-side only)

**Recommendation:** Build simplified session management UI with "Sign out all other devices" button. This satisfies the requirement without requiring service role access.

### Pattern 10: Security Headers in next.config.ts

```typescript
// Source: https://nextjs.org/docs/app/api-reference/config/next-config-js/headers
// Without nonces (appropriate for this app — avoids breaking static generation)
const isDev = process.env.NODE_ENV === 'development'

// CSP must allow: Supabase, YouTube, Vimeo, Spotify, SoundCloud, TikTok,
// Facebook Pixel, Google Analytics, Superpowered WASM
const cspHeader = `
  default-src 'self';
  script-src 'self' 'unsafe-inline'${isDev ? " 'unsafe-eval'" : ''}
    https://*.supabase.co
    https://connect.facebook.net
    https://www.googletagmanager.com
    https://www.google-analytics.com;
  style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
  img-src 'self' blob: data: https://*.supabase.co https://i.ytimg.com
    https://i.vimeocdn.com https://p16-sign-sg.tiktokcdn.com
    https://www.facebook.com https://www.google-analytics.com;
  font-src 'self' https://fonts.gstatic.com;
  connect-src 'self' https://*.supabase.co https://www.google-analytics.com
    https://graph.facebook.com wss://*.supabase.co;
  frame-src https://www.youtube.com https://player.vimeo.com
    https://open.spotify.com https://w.soundcloud.com
    https://www.tiktok.com;
  media-src 'self' blob: https://*.supabase.co;
  worker-src 'self' blob:;
  wasm-src 'self' blob:;
  object-src 'none';
  base-uri 'self';
  frame-ancestors 'none';
  upgrade-insecure-requests;
`.replace(/\s+/g, ' ').trim()
```

**Important:** `frame-ancestors 'none'` is the modern replacement for `X-Frame-Options: DENY`. Both can be set for belt-and-suspenders. Note that `X-Frame-Options` has been superseded by CSP `frame-ancestors` in modern browsers.

### Pattern 11: Input Sanitization with isomorphic-dompurify

```typescript
// Source: https://github.com/kkomelin/isomorphic-dompurify
// Works on both server (Node.js via jsdom) and client (browser DOM)
import DOMPurify from 'isomorphic-dompurify'

// Sanitize user text (strip all HTML tags for plain text fields)
export function sanitizeText(input: string): string {
  return DOMPurify.sanitize(input, { ALLOWED_TAGS: [], ALLOWED_ATTR: [] })
}

// For fields that should allow no HTML at all, just trim and escape
// Use in API routes before storing to DB: display_name, bio, card title, description
```

**Note on DOMPurify in Node.js:** The plain `dompurify` package requires a DOM and throws in Node.js API routes. `isomorphic-dompurify` wraps it with jsdom for server-side use. Long-running processes may need `clearWindow()` calls to prevent memory accumulation, but in serverless (Vercel), each invocation is fresh.

### Pattern 12: CSRF Protection for API Routes

Next.js Server Actions get automatic CSRF protection (Origin vs Host header check). Custom Route Handlers (`route.ts`) do NOT — they require manual protection.

```typescript
// Source: https://nextjs.org/blog/security-nextjs-server-components-actions
// src/lib/csrf/index.ts
export function validateCsrfOrigin(request: Request): boolean {
  const origin = request.headers.get('origin')
  const host = request.headers.get('host')

  if (!origin || !host) return false

  try {
    const originHost = new URL(origin).host
    return originHost === host
  } catch {
    return false
  }
}

// Usage in mutation API routes:
if (!validateCsrfOrigin(request)) {
  return NextResponse.json({ error: 'CSRF validation failed' }, { status: 403 })
}
```

Apply to: POST/PUT/PATCH/DELETE routes in `/api/cards`, `/api/profile`, `/api/theme`, `/api/audio`, `/api/legal`. NOT needed on public-facing routes like `/api/analytics/track` (no auth, unauthenticated callers).

### Anti-Patterns to Avoid

- **Creating Ratelimit instance inside request handler:** Creates new Redis connection per request. Create at module level.
- **Using nonce-based CSP:** Forces dynamic rendering on all pages, killing static optimization. Use `'unsafe-inline'` for this app's needs.
- **Calling `updateUser({ password })` without re-auth:** Supabase doesn't enforce current password — must re-authenticate manually first.
- **Exposing backup codes in plaintext in DB:** Always store bcrypt hashes. Show plaintext exactly once, then discard.
- **Using `supabase.auth.getSession()` on server:** Returns unvalidated JWT. Always use `getUser()` server-side.
- **Applying CSRF check to public analytics/pixel endpoints:** These are intentionally public and would break third-party integrations.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Rate limiting | Custom Redis counter | `@upstash/ratelimit` | Handles sliding window math, race conditions, serverless compatibility |
| HTML sanitization | Custom regex stripping | `isomorphic-dompurify` | XSS bypasses are notoriously subtle; DOMPurify is audited by security professionals |
| TOTP secret generation + QR | Custom TOTP | Supabase `mfa.enroll()` | Supabase handles the TOTP standard, secret generation, QR URI encoding |
| OAuth token exchange | Custom OAuth flow | Supabase `signInWithOAuth` | Complex PKCE flow already handled by Supabase |
| Password hashing | Custom bcrypt | Supabase handles passwords | Supabase stores all passwords — you never touch them directly |

**Exception:** Backup codes must be custom-built because Supabase doesn't support them natively.

**Key insight:** In the auth + security domain, custom implementations almost always miss edge cases that mature libraries handle — timing attacks in hash comparison, TOTP clock drift, OAuth PKCE verification, Redis race conditions in distributed rate limiting.

---

## Common Pitfalls

### Pitfall 1: CSP Breaks Superpowered WASM
**What goes wrong:** Adding a strict CSP breaks the Superpowered AudioWorklet because WASM requires `wasm-unsafe-eval` and the processor script is loaded as a blob worker.
**Why it happens:** CSP `worker-src` and `script-src` block blob: URLs and WASM execution.
**How to avoid:** Include `worker-src 'self' blob:` and `wasm-src 'self' blob:` in CSP. Test audio playback after applying headers.
**Warning signs:** Console errors about "Content Security Policy: The page's settings blocked the loading of a resource..."

### Pitfall 2: CSP Breaks Third-Party Embeds
**What goes wrong:** Spotify, YouTube, Vimeo, SoundCloud iframes stop loading on public pages.
**Why it happens:** `frame-src` directive restricts which origins can be iframed. If not explicitly allowed, they're blocked.
**How to avoid:** Enumerate all embed domains in `frame-src`. Check `/src/components/cards/video-card.tsx` and other embed components for iframe src patterns.
**Warning signs:** Blank iframes, "Refused to frame..." console errors.

### Pitfall 3: Google OAuth Callback URL Not Configured
**What goes wrong:** OAuth redirects fail with "redirect_uri_mismatch" error.
**Why it happens:** Google Cloud Console requires authorized redirect URIs. Both the Supabase callback URL and app callback must be configured.
**How to avoid:** Add `https://[project].supabase.co/auth/v1/callback` as authorized redirect URI in Google Cloud Console. Also add it in Supabase Dashboard > Auth > URL Configuration.
**Warning signs:** Google OAuth shows error page with redirect_uri_mismatch.

### Pitfall 4: Email Verification Breaks Existing Users
**What goes wrong:** Enabling "Require email confirmation" in Supabase blocks existing users whose `email_confirmed_at` is null (users who signed up before the feature was enabled).
**Why it happens:** Supabase enforces confirmation check on every `signInWithPassword` call when the setting is enabled.
**How to avoid:** Before enabling the setting, run a SQL migration to mark all existing users as confirmed, OR implement a grace period UI that lets existing users verify without being locked out.
**Warning signs:** Existing users get "Email not confirmed" error on login.

### Pitfall 5: Rate Limiting by IP Fails Behind Vercel
**What goes wrong:** All requests appear to come from the same IP (Vercel's edge IP).
**Why it happens:** Must use `x-forwarded-for` header, not request.ip, when running on Vercel.
**How to avoid:** Use `request.headers.get('x-forwarded-for')?.split(',')[0].trim()` for the client IP.
**Warning signs:** Rate limit hits immediately for first user because all IPs are the same.

### Pitfall 6: 2FA AAL Level Not Checked on Protected Routes
**What goes wrong:** User enables 2FA but can still access editor without completing TOTP challenge.
**Why it happens:** After password login, session is `aal1`. The TOTP challenge upgrades to `aal2`. Without checking `getAuthenticatorAssuranceLevel()`, the app doesn't enforce the second factor.
**How to avoid:** In middleware, after user is authenticated, check if MFA is enrolled AND session is only `aal1` — if so, redirect to `/auth/mfa-challenge`.
**Warning signs:** User bypasses 2FA by directly navigating to `/editor` after password login.

### Pitfall 7: Backup Code Timing Attack
**What goes wrong:** Naive backup code comparison leaks information via timing differences.
**Why it happens:** String comparison short-circuits on first mismatch — attacker can measure timing to infer correct characters.
**How to avoid:** Use `bcrypt.compare()` which is constant-time, or `crypto.timingSafeEqual()` for HMAC-based codes.
**Warning signs:** None visible until audit — must prevent proactively.

### Pitfall 8: Storage Quota Not Checked Server-Side
**What goes wrong:** Client-side quota display shows 450MB/500MB but user bypasses via direct API call and uploads another 200MB.
**Why it happens:** Quota check only happens in UI, not in upload API route.
**How to avoid:** In `/api/audio/upload/route.ts` and image upload routes, query current storage usage before processing upload. Reject with 413 if would exceed quota.
**Warning signs:** Users can exceed quota by uploading via curl or modified client.

---

## Code Examples

Verified patterns from official sources:

### Rate Limit with Fail-Open
```typescript
// Source: https://upstash.com/docs/redis/sdks/ratelimit-ts/features
const { success, reset, reason } = await ratelimit.limit(identifier)

if (!success && reason !== 'timeout') {
  return NextResponse.json(
    { error: 'Rate limit exceeded' },
    { status: 429, headers: { 'Retry-After': String(Math.ceil((reset - Date.now()) / 1000)) } }
  )
}
// reason === 'timeout' means Redis was unavailable — fail open (allow request)
```

### Google OAuth Button
```typescript
// Source: https://supabase.com/docs/guides/auth/social-login/auth-google
const supabase = createClient()
await supabase.auth.signInWithOAuth({
  provider: 'google',
  options: { redirectTo: `${window.location.origin}/auth/callback` },
})
// No redirect() needed — Supabase handles the browser redirect
```

### Password Reset — Request
```typescript
// Source: https://supabase.com/docs/guides/auth/passwords
await supabase.auth.resetPasswordForEmail(email, {
  redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/reset-password`,
})
```

### Password Reset — Update (on reset page after callback)
```typescript
// Source: https://supabase.com/docs/guides/auth/passwords
// After callback exchanges code for session (type=recovery):
const { error } = await supabase.auth.updateUser({ password: newPassword })
```

### Change Email
```typescript
// Source: https://supabase.com/docs/guides/auth/passwords
// updateUser sends verification email to new address
const { error } = await supabase.auth.updateUser({ email: newEmail })
// Supabase sends verification email to new address before switching
```

### Sign Out Scopes
```typescript
// Source: https://supabase.com/docs/guides/auth/signout
await supabase.auth.signOut({ scope: 'global' })   // all devices
await supabase.auth.signOut({ scope: 'others' })   // all except current
await supabase.auth.signOut({ scope: 'local' })    // current only
```

### MFA Enroll
```typescript
// Source: https://supabase.com/docs/reference/javascript/auth-mfa-enroll
const { data } = await supabase.auth.mfa.enroll({ factorType: 'totp' })
const { id: factorId, totp: { qr_code, secret } } = data
// Display: <img src={qr_code} /> or use react-qr-code with totp.uri
```

### MFA Verify Enrollment
```typescript
// Source: https://supabase.com/docs/reference/javascript/auth-mfa-enroll
const { data: challenge } = await supabase.auth.mfa.challenge({ factorId })
const { error } = await supabase.auth.mfa.verify({
  factorId,
  challengeId: challenge.data.id,
  code: userEnteredCode,
})
// On success: session upgrades to aal2, all other sessions logged out
```

### Check MFA Status
```typescript
// Source: https://supabase.com/docs/reference/javascript/auth-mfa-api
const { data } = await supabase.auth.mfa.getAuthenticatorAssuranceLevel()
// data.currentLevel: 'aal1' | 'aal2'
// data.nextLevel: 'aal1' | 'aal2' (what's achievable)
const hasMfaEnrolled = data.nextLevel === 'aal2'
const hasMfaVerified = data.currentLevel === 'aal2'

const { data: factors } = await supabase.auth.mfa.listFactors()
// factors.totp: array of enrolled TOTP factors
```

### Security Headers in next.config.ts
```typescript
// Source: https://nextjs.org/docs/app/api-reference/config/next-config-js/headers
async headers() {
  return [
    {
      source: '/(.*)',
      headers: [
        { key: 'Strict-Transport-Security', value: 'max-age=31536000; includeSubDomains' },
        { key: 'X-Content-Type-Options', value: 'nosniff' },
        { key: 'X-Frame-Options', value: 'DENY' },
        { key: 'Referrer-Policy', value: 'strict-origin-when-cross-origin' },
        { key: 'Permissions-Policy', value: 'camera=(), microphone=(), geolocation=()' },
        { key: 'Content-Security-Policy', value: cspHeader },
      ],
    },
  ]
}
```

---

## Existing Codebase State

Critical context for planning tasks:

### Already Done / Partially Done

| Feature | State | What's Needed |
|---------|-------|---------------|
| Auth callback route | Done (`/src/app/auth/callback/route.ts`) | Extend to handle `type=recovery` redirect to reset-password page |
| Login form | Done (email/password) | Add Google OAuth button, "Forgot password?" link |
| Signup form | Done (email/password/username) | Add Google OAuth button, email verification pending state |
| Sign out | Done (`/api/auth/signout/route.ts`) | Add scope options |
| Cookie consent banner | Done (`/src/components/legal/cookie-consent-banner.tsx`) | Wire to `is_published` gate, verify pixel integration works |
| PixelLoader | Done (listens for `consent-granted` event) | Already correct; test end-to-end |
| Settings page | Minimal (username only) | Add full security sections |
| Storage buckets | Done (`card-images`, `card-audio`, `profile-images`, `card-videos`) | Add server-side MIME validation and quota tracking |
| Audio upload | Done but lacks MIME validation | Add MIME type check server-side |
| Image upload | Client-side only, lacks server-side validation | Client uploads to storage directly — add RLS or server-side check |
| Middleware | Done (auth gates `/editor`, `/settings`) | Add MFA challenge redirect |
| `next.config.ts` | Has WASM headers only | Add security headers |

### Not Started

| Feature | Notes |
|---------|-------|
| Google OAuth provider config | Needs Supabase Dashboard config + env vars |
| Forgot password / reset flow | New pages needed |
| Email verification flow | New pages, Supabase config change |
| Change password (in settings) | New component |
| Change email (in settings) | New component |
| 2FA setup + verify | New components + DB table for backup codes |
| Session management UI | New component |
| Rate limiting | `@upstash/ratelimit` not installed, no rate limit on any route |
| Security headers | Only WASM headers in `next.config.ts` |
| Input sanitization | No DOMPurify anywhere |
| CSRF validation | No Origin header checks on mutation routes |
| Storage quota tracking | No `storage_used_bytes` column on profiles |
| Orphaned file cleanup | Card delete doesn't clean up storage files |

---

## State of the Art

| Old Approach | Current Approach | Impact |
|--------------|------------------|--------|
| `X-Frame-Options` for clickjacking | CSP `frame-ancestors` | Both can coexist; CSP takes precedence in modern browsers |
| `X-XSS-Protection` header | Deprecated; CSP is the solution | Don't bother setting X-XSS-Protection: 0 vs 1 is moot |
| Storing sessions in localStorage | Cookie-based sessions (Supabase SSR) | Already correct; Supabase SSR uses httpOnly cookies |
| Manual CSRF tokens | SameSite cookies + Origin header check | Supabase uses SameSite by default; supplement with Origin check for API routes |
| PBKDF2/SHA-256 for backup codes | bcrypt/argon2 | Use bcrypt for backup code hashing |

**Deprecated/outdated:**
- `X-XSS-Protection` header: Removed from browsers. Skip it or set to `0`.
- nonce-based CSP for this app: Forces dynamic rendering everywhere. Use `'unsafe-inline'` + domain allowlist instead.
- `supabase.auth.getSession()` on server: Does not validate JWT. Use `getUser()` exclusively.

---

## Open Questions

1. **Server-side image upload MIME validation**
   - What we know: Image uploads go directly from client to Supabase Storage (client-side SDK), bypassing API routes. The audio upload does go through `/api/audio/upload/route.ts` which can validate.
   - What's unclear: How to validate MIME on direct-to-storage client uploads without routing through server.
   - Recommendation: Add Supabase Storage RLS policies that restrict file types, OR route image uploads through a server API endpoint (migration needed). Simpler: add MIME check in `uploadCardImageBlob()` and `uploadCardImage()` client-side functions as best-effort, acknowledging server-side enforcement requires routing change.

2. **2FA during login flow — where to intercept**
   - What we know: After `signInWithPassword`, if user has a TOTP factor enrolled, session is `aal1`. App should prompt for TOTP before proceeding.
   - What's unclear: Best intercept point — middleware vs login form callback vs dedicated `/auth/mfa-challenge` page.
   - Recommendation: Handle in login form: after successful `signInWithPassword`, check `getAuthenticatorAssuranceLevel()`. If `nextLevel === 'aal2'`, redirect to `/auth/mfa-challenge` before proceeding to editor.

3. **Email verification for existing users**
   - What we know: Enabling "require email confirmation" in Supabase blocks all unconfirmed users, including existing ones.
   - What's unclear: How many existing test/real users have unconfirmed emails.
   - Recommendation: When enabling email confirmation, run SQL to confirm all existing users: `UPDATE auth.users SET email_confirmed_at = NOW() WHERE email_confirmed_at IS NULL`.

4. **Storage quota: track in profiles vs calculate on-the-fly**
   - What we know: Supabase doesn't natively enforce per-user storage quotas. Must track manually.
   - Options: (a) Track `storage_used_bytes` in profiles table, increment/decrement on upload/delete. (b) Calculate by listing all user storage objects on demand (expensive).
   - Recommendation: Track in `profiles.storage_used_bytes` column. Increment in upload API routes, decrement in delete routes. Accept slight inaccuracy if delete fails silently (reconcile in a cleanup job later).

---

## Sources

### Primary (HIGH confidence)
- Supabase Auth MFA docs — https://supabase.com/docs/guides/auth/auth-mfa (MFA enrollment, challenge, verify APIs)
- Supabase MFA JS Reference — https://supabase.com/docs/reference/javascript/auth-mfa-api (listFactors, getAuthenticatorAssuranceLevel)
- Supabase signOut reference — https://supabase.com/docs/guides/auth/signout (scope: global/local/others)
- Supabase password docs — https://supabase.com/docs/guides/auth/passwords (reset, updateUser)
- Supabase Google OAuth — https://supabase.com/docs/guides/auth/social-login/auth-google (signInWithOAuth, callback)
- Upstash ratelimit algorithms — https://upstash.com/docs/redis/sdks/ratelimit-ts/algorithms (slidingWindow, fixedWindow, tokenBucket)
- Upstash ratelimit features — https://upstash.com/docs/redis/sdks/ratelimit-ts/features (timeout/fail-open)
- Next.js headers config — https://nextjs.org/docs/app/api-reference/config/next-config-js/headers (all security headers)
- Next.js CSP guide — https://nextjs.org/docs/app/guides/content-security-policy (nonce vs static approach)
- Next.js security guide — https://nextjs.org/blog/security-nextjs-server-components-actions (CSRF for route handlers)

### Secondary (MEDIUM confidence)
- WebSearch: DOMPurify in Next.js server routes → confirmed `isomorphic-dompurify` is the standard solution
- WebSearch: Supabase MFA backup codes → confirmed Supabase does NOT support backup codes; multiple sources agree
- WebSearch: `@upstash/ratelimit` latest version → 2.0.8 (verified via `npm show`)
- Supabase sessions → signOut scope options confirmed, listSessions confirmed as not available in public JS client

### Tertiary (LOW confidence)
- Session list "view active sessions" UI: Supabase has no public `listSessions()` API. Only Admin API (service role) has access to `auth.sessions`. Building simplified "sign out all other devices" UI is the practical alternative.

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — all library versions verified via npm, official docs consulted
- Architecture: HIGH — patterns from official Supabase and Next.js docs
- Pitfalls: HIGH — several verified with direct API investigation (e.g., confirmed backup codes not in Supabase, confirmed session list not in public API)
- Backup codes implementation: MEDIUM — design pattern is standard but needs implementation detail decisions (bcrypt vs argon2, code format)

**Research date:** 2026-02-25
**Valid until:** 2026-03-25 (stable domain; Supabase and Upstash APIs change slowly)
