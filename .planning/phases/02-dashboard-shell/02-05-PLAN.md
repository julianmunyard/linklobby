---
phase: 02-dashboard-shell
plan: 05
type: execute
wave: 4
depends_on: ["02-01", "02-02", "02-03", "02-04"]
files_modified:
  - src/hooks/use-unsaved-changes.ts
  - src/components/dashboard/unsaved-changes-dialog.tsx
  - src/components/editor/preview-panel.tsx
  - src/app/(dashboard)/editor/page.tsx
  - src/components/editor/editor-client-wrapper.tsx

autonomous: false

must_haves:
  truths:
    - "User sees save/discard prompt when leaving with unsaved changes"
    - "Browser close/refresh shows native beforeunload warning"
    - "Back button navigation blocked with prompt"
    - "Internal link clicks blocked with prompt"
  artifacts:
    - path: "src/hooks/use-unsaved-changes.ts"
      provides: "Hook for navigation blocking"
      min_lines: 40
      contains: "beforeunload"
    - path: "src/components/dashboard/unsaved-changes-dialog.tsx"
      provides: "Save/discard confirmation dialog"
      min_lines: 30
  key_links:
    - from: "src/hooks/use-unsaved-changes.ts"
      to: "src/stores/page-store.ts"
      via: "usePageStore subscription"
      pattern: "usePageStore"
    - from: "src/app/(dashboard)/editor/page.tsx"
      to: "src/hooks/use-unsaved-changes.ts"
      via: "useUnsavedChanges hook"
      pattern: "useUnsavedChanges"
---

<objective>
Implement the unsaved changes protection: hook for navigation blocking, confirmation dialog, and integration with the editor. Also enable the iframe preview with postMessage sync.

Purpose: Prevent accidental data loss and complete the live preview experience.
Output: Working save/discard flow, active preview iframe with state sync.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-dashboard-shell/02-RESEARCH.md
@.planning/phases/02-dashboard-shell/02-01-SUMMARY.md
@.planning/phases/02-dashboard-shell/02-03-SUMMARY.md
@.planning/phases/02-dashboard-shell/02-04-SUMMARY.md

@src/stores/page-store.ts
@src/components/editor/preview-panel.tsx
@src/app/(dashboard)/editor/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useUnsavedChanges hook</name>
  <files>src/hooks/use-unsaved-changes.ts</files>
  <action>
Create the hook that blocks navigation when there are unsaved changes:

src/hooks/use-unsaved-changes.ts:
```typescript
"use client"

import { useEffect, useCallback, useState } from "react"
import { useRouter } from "next/navigation"
import { usePageStore } from "@/stores/page-store"

interface UseUnsavedChangesReturn {
  showDialog: boolean
  setShowDialog: (show: boolean) => void
  pendingNavigation: string | null
  confirmNavigation: () => void
  cancelNavigation: () => void
}

export function useUnsavedChanges(): UseUnsavedChangesReturn {
  const router = useRouter()
  const hasChanges = usePageStore((state) => state.hasChanges)
  const [showDialog, setShowDialog] = useState(false)
  const [pendingNavigation, setPendingNavigation] = useState<string | null>(null)

  // Handle browser close/refresh (native browser dialog)
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (hasChanges) {
        e.preventDefault()
        // Modern browsers ignore custom messages, but returnValue is required
        e.returnValue = ""
        return ""
      }
    }

    window.addEventListener("beforeunload", handleBeforeUnload)
    return () => window.removeEventListener("beforeunload", handleBeforeUnload)
  }, [hasChanges])

  // Handle browser back/forward buttons
  useEffect(() => {
    if (!hasChanges) return

    // Push a state to detect back button
    window.history.pushState(null, "", window.location.href)

    const handlePopState = () => {
      if (hasChanges) {
        // Restore the URL (prevents navigation)
        window.history.pushState(null, "", window.location.href)
        setPendingNavigation("back")
        setShowDialog(true)
      }
    }

    window.addEventListener("popstate", handlePopState)
    return () => window.removeEventListener("popstate", handlePopState)
  }, [hasChanges])

  // Intercept internal link clicks
  const handleLinkClick = useCallback(
    (e: MouseEvent) => {
      if (!hasChanges) return

      const target = e.target as HTMLElement
      const link = target.closest("a")

      if (!link) return

      // Only intercept internal links
      const href = link.getAttribute("href")
      if (!href) return

      // Check if it's an internal link (same origin or relative)
      const isInternal =
        href.startsWith("/") ||
        href.startsWith(window.location.origin) ||
        (!href.startsWith("http") && !href.startsWith("mailto:"))

      // Don't intercept links that open in new tabs
      const opensNewTab =
        link.target === "_blank" ||
        e.metaKey ||
        e.ctrlKey

      if (isInternal && !opensNewTab) {
        e.preventDefault()
        e.stopPropagation()
        setPendingNavigation(href)
        setShowDialog(true)
      }
    },
    [hasChanges]
  )

  useEffect(() => {
    // Use capture phase to intercept before other handlers
    document.addEventListener("click", handleLinkClick, true)
    return () => document.removeEventListener("click", handleLinkClick, true)
  }, [handleLinkClick])

  const confirmNavigation = useCallback(() => {
    // User confirmed they want to leave - discard changes and navigate
    usePageStore.getState().discardChanges()
    setShowDialog(false)

    if (pendingNavigation === "back") {
      // Go back in history
      window.history.back()
    } else if (pendingNavigation) {
      // Navigate to the pending URL
      router.push(pendingNavigation)
    }
    setPendingNavigation(null)
  }, [pendingNavigation, router])

  const cancelNavigation = useCallback(() => {
    // User cancelled - stay on page
    setShowDialog(false)
    setPendingNavigation(null)
  }, [])

  return {
    showDialog,
    setShowDialog,
    pendingNavigation,
    confirmNavigation,
    cancelNavigation,
  }
}
```

Key patterns:
- beforeunload for browser close/refresh (shows native dialog)
- popstate listener for back/forward buttons
- Click capture phase to intercept link clicks early
- Checks for internal links only (external links open normally)
- Does not intercept cmd/ctrl+click (new tab)
  </action>
  <verify>
File compiles: `npx tsc --noEmit src/hooks/use-unsaved-changes.ts`
  </verify>
  <done>useUnsavedChanges hook blocks navigation with dialog when hasChanges is true</done>
</task>

<task type="auto">
  <name>Task 2: Create UnsavedChangesDialog component</name>
  <files>src/components/dashboard/unsaved-changes-dialog.tsx</files>
  <action>
Create the confirmation dialog for unsaved changes:

src/components/dashboard/unsaved-changes-dialog.tsx:
```typescript
"use client"

import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog"

interface UnsavedChangesDialogProps {
  open: boolean
  onSave: () => void
  onDiscard: () => void
  onCancel: () => void
}

export function UnsavedChangesDialog({
  open,
  onSave,
  onDiscard,
  onCancel,
}: UnsavedChangesDialogProps) {
  return (
    <AlertDialog open={open} onOpenChange={(open) => !open && onCancel()}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Unsaved changes</AlertDialogTitle>
          <AlertDialogDescription>
            You have unsaved changes to your page. Would you like to save them
            before leaving?
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter className="gap-2 sm:gap-0">
          <AlertDialogCancel onClick={onCancel}>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={onDiscard}
            className="bg-transparent border border-destructive text-destructive hover:bg-destructive hover:text-destructive-foreground"
          >
            Discard
          </AlertDialogAction>
          <AlertDialogAction onClick={onSave}>Save</AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  )
}
```

Key patterns:
- Three actions: Cancel (stay), Discard (leave without saving), Save (save then leave)
- Discard styled with destructive colors to warn user
- onOpenChange handles clicking outside/escape
  </action>
  <verify>
File compiles: `npx tsc --noEmit src/components/dashboard/unsaved-changes-dialog.tsx`
  </verify>
  <done>UnsavedChangesDialog with Cancel, Discard, Save options</done>
</task>

<task type="auto">
  <name>Task 3: Enable iframe preview and wire unsaved changes</name>
  <files>src/components/editor/preview-panel.tsx, src/app/(dashboard)/editor/page.tsx</files>
  <action>
Update PreviewPanel to enable the iframe and wire the unsaved changes dialog to the editor page.

First, update src/components/editor/preview-panel.tsx to enable the iframe:
```typescript
"use client"

import { useState, useRef, useEffect } from "react"
import { PreviewToggle, type PreviewMode } from "./preview-toggle"
import { usePageStore } from "@/stores/page-store"
import { cn } from "@/lib/utils"

const PREVIEW_SIZES = {
  mobile: { width: 375, height: 667 },
  desktop: { width: "100%", height: "100%" },
} as const

export function PreviewPanel() {
  const [previewMode, setPreviewMode] = useState<PreviewMode>("desktop")
  const [previewReady, setPreviewReady] = useState(false)
  const iframeRef = useRef<HTMLIFrameElement>(null)
  const getSnapshot = usePageStore((state) => state.getSnapshot)

  // Send state to preview iframe
  const sendToPreview = () => {
    const iframe = iframeRef.current
    if (iframe?.contentWindow && previewReady) {
      const snapshot = getSnapshot()
      iframe.contentWindow.postMessage(
        { type: "STATE_UPDATE", payload: snapshot },
        window.location.origin
      )
    }
  }

  // Listen for PREVIEW_READY message from iframe
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      if (event.origin !== window.location.origin) return
      if (event.data.type === "PREVIEW_READY") {
        setPreviewReady(true)
      }
    }

    window.addEventListener("message", handleMessage)
    return () => window.removeEventListener("message", handleMessage)
  }, [])

  // Send initial state when preview becomes ready
  useEffect(() => {
    if (previewReady) {
      sendToPreview()
    }
  }, [previewReady])

  // Subscribe to store changes and send updates to preview
  useEffect(() => {
    const unsubscribe = usePageStore.subscribe(() => {
      sendToPreview()
    })
    return () => unsubscribe()
  }, [previewReady])

  const size = PREVIEW_SIZES[previewMode]
  const isMobile = previewMode === "mobile"

  return (
    <div className="h-full flex flex-col bg-muted/30">
      {/* Preview toolbar */}
      <div className="flex items-center justify-between border-b px-4 py-2 bg-background">
        <span className="text-sm font-medium text-muted-foreground">
          Preview
        </span>
        <PreviewToggle mode={previewMode} onModeChange={setPreviewMode} />
      </div>

      {/* Preview area */}
      <div className="flex-1 overflow-auto p-4">
        <div
          className={cn(
            "mx-auto bg-background rounded-lg shadow-lg overflow-hidden transition-all duration-300",
            isMobile && "border-4 border-foreground/10 rounded-[2rem]"
          )}
          style={{
            width: isMobile ? size.width : "100%",
            height: isMobile ? size.height : "100%",
            maxWidth: "100%",
          }}
        >
          <iframe
            ref={iframeRef}
            src="/preview"
            className="w-full h-full border-0"
            title="Page preview"
          />
        </div>
      </div>
    </div>
  )
}
```

Then update src/app/(dashboard)/editor/page.tsx to include the unsaved changes dialog:
```typescript
import { createClient } from "@/lib/supabase/server"
import { redirect } from "next/navigation"
import { TooltipProvider } from "@/components/ui/tooltip"
import { DashboardHeader } from "@/components/dashboard/dashboard-header"
import { EditorLayout } from "@/components/editor/editor-layout"
import { EditorClientWrapper } from "@/components/editor/editor-client-wrapper"

export default async function EditorPage() {
  const supabase = await createClient()

  const {
    data: { user },
  } = await supabase.auth.getUser()

  if (!user) {
    redirect("/login")
  }

  const { data: profile } = await supabase
    .from("profiles")
    .select("username")
    .eq("id", user.id)
    .single()

  if (!profile?.username) {
    redirect("/signup")
  }

  return (
    <EditorClientWrapper username={profile.username} />
  )
}
```

Create a new client wrapper component to handle client-side hooks:

src/components/editor/editor-client-wrapper.tsx:
```typescript
"use client"

import { TooltipProvider } from "@/components/ui/tooltip"
import { DashboardHeader } from "@/components/dashboard/dashboard-header"
import { EditorLayout } from "@/components/editor/editor-layout"
import { UnsavedChangesDialog } from "@/components/dashboard/unsaved-changes-dialog"
import { useUnsavedChanges } from "@/hooks/use-unsaved-changes"
import { usePageStore } from "@/stores/page-store"
import { toast } from "sonner"

interface EditorClientWrapperProps {
  username: string
}

export function EditorClientWrapper({ username }: EditorClientWrapperProps) {
  const {
    showDialog,
    setShowDialog,
    confirmNavigation,
    cancelNavigation,
  } = useUnsavedChanges()

  const markSaved = usePageStore((state) => state.markSaved)

  const handleSave = async () => {
    // TODO: Implement actual save to Supabase in later phases
    // For now, just mark as saved
    markSaved()
    toast.success("Changes saved")
    setShowDialog(false)
    // If there was pending navigation, proceed
    confirmNavigation()
  }

  const handleDiscard = () => {
    confirmNavigation()
  }

  return (
    <TooltipProvider>
      <div className="flex flex-col h-[calc(100vh-3.5rem)]">
        {/* Editor header */}
        <div className="flex items-center h-12 px-4 border-b bg-background">
          <DashboardHeader username={username} />
        </div>

        {/* Split-screen editor */}
        <div className="flex-1 overflow-hidden">
          <EditorLayout />
        </div>
      </div>

      {/* Unsaved changes dialog */}
      <UnsavedChangesDialog
        open={showDialog}
        onSave={handleSave}
        onDiscard={handleDiscard}
        onCancel={cancelNavigation}
      />
    </TooltipProvider>
  )
}
```

Files to create/modify:
1. src/components/editor/preview-panel.tsx - Enable iframe
2. src/components/editor/editor-client-wrapper.tsx - New file, handles client hooks
3. src/app/(dashboard)/editor/page.tsx - Simplified to use wrapper
  </action>
  <verify>
Run `npm run dev` and test:
1. Visit /editor - should see split-screen with preview iframe loading /preview
2. Preview should show empty state
3. Open browser console and run:
   ```javascript
   // Simulate adding a card to trigger hasChanges
   const store = window.__ZUSTAND_DEVTOOLS_STORE__ || (await import('@/stores/page-store')).usePageStore.getState()
   // Actually, just click around the app - the store is internal
   ```
4. Test unsaved changes:
   - Open DevTools Console
   - In the editor page context, the store should be accessible
   - For manual testing: We need to temporarily add a button to trigger hasChanges

Better test approach - add temporary test button to EditorPanel (can remove later):
In editor-panel.tsx, add a test button that triggers hasChanges:
```typescript
// Temporary for testing - remove after Phase 2
<Button onClick={() => usePageStore.getState().addCard({ id: Date.now().toString(), type: 'test', position: { x: 0, y: 0 }, content: {} })}>
  Add Test Card (DEV)
</Button>
```

5. After clicking test button:
   - Header should show "Unsaved changes" indicator
   - Click Settings link - dialog should appear
   - Click Cancel - should stay on page
   - Click Settings again - dialog appears
   - Click Discard - should navigate to Settings
6. Test back button:
   - Add another test card
   - Press browser back button - dialog should appear
7. Test browser close:
   - Add test card
   - Try to close tab - native browser warning should appear
  </verify>
  <done>Preview iframe active with postMessage sync, unsaved changes dialog wired to editor</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. /editor shows live preview in iframe
3. Preview receives state updates via postMessage
4. Clicking internal link with unsaved changes shows dialog
5. Back button with unsaved changes shows dialog
6. Browser close/refresh with unsaved changes shows native warning
7. Save button in dialog marks changes as saved
8. Discard button allows navigation without saving
</verification>

<success_criteria>
- DASH-01: Dashboard displays split-screen layout - COMPLETE
- DASH-02: Preview updates in real-time - COMPLETE (via postMessage)
- DASH-03: Mobile/desktop preview toggle - COMPLETE
- DASH-04: Save/discard prompt on exit - COMPLETE
- DASH-05: Three tabs (Cards, Design, Insights) - COMPLETE
- DASH-06: Username and public URL in header - COMPLETE
</success_criteria>

<output>
After completion, create `.planning/phases/02-dashboard-shell/02-05-SUMMARY.md`
</output>
