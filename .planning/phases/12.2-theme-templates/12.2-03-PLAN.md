---
phase: 12.2-theme-templates
plan: 03
type: execute
wave: 2
depends_on: ["12.2-01"]
files_modified:
  - src/app/api/templates/apply/route.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/templates/apply uploads template media assets to user's Supabase storage"
    - "Card content imageUrl/storagePath and audioUrl/storagePath are replaced with user-scoped Supabase URLs"
    - "Cards are batch-inserted into user's page via Supabase"
    - "Theme state and profile defaults are returned for client-side store hydration"
    - "Existing cards can be replaced or kept based on mode parameter"
  artifacts:
    - path: "src/app/api/templates/apply/route.ts"
      provides: "Template application API route"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/templates/apply/route.ts"
      to: "src/lib/templates/index.ts"
      via: "getTemplate(templateId)"
      pattern: "getTemplate"
    - from: "src/app/api/templates/apply/route.ts"
      to: "supabase.storage"
      via: "upload template assets to user buckets"
      pattern: "storage.*from.*upload"
    - from: "src/app/api/templates/apply/route.ts"
      to: "supabase.from('cards')"
      via: "batch insert cards"
      pattern: "\\.insert\\("
---

<objective>
Build the server-side template application API route that handles asset upload and card creation.

Purpose: This is the core engine that transforms a static template definition into a user's live page. It uploads template media to the user's Supabase storage, creates cards with correct storage paths, and returns theme/profile data for client hydration.
Output: POST /api/templates/apply endpoint.
</objective>

<execution_context>
@/Users/julianmunyard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianmunyard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.2-theme-templates/12.2-RESEARCH.md
@src/lib/templates/types.ts (from Plan 01)
@src/lib/templates/index.ts (from Plan 01)
@src/app/api/import/linktree/route.ts
@src/app/api/audio/upload/route.ts
@src/lib/supabase/storage.ts
@src/lib/supabase/server.ts
@src/types/card.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auth, template lookup, and asset upload</name>
  <files>src/app/api/templates/apply/route.ts</files>
  <action>
Create `src/app/api/templates/apply/route.ts` as a Node.js runtime API route (NOT Edge — needs fs access).

Use `export const runtime = 'nodejs'` at the top of the file (same as audio upload route).

**Request body:**
```typescript
{ templateId: string, mode: 'replace' | 'add' }
```

**This task covers steps 1-3 of the route:**

1. **Auth check** — Use the same pattern as `src/app/api/import/linktree/route.ts`: create server Supabase client, call `getUser()`, fetch user's page from `pages` table. Return 401 if not authenticated, 404 if no page.

2. **Load template** — Import `getTemplate` from `@/lib/templates`. Call `getTemplate(templateId)`. Return 404 if template not found.

3. **Upload media assets** — For each file in `template.mediaAssets`:
   - Read the file from disk: `fs.readFileSync(path.join(process.cwd(), 'public', 'templates', template.id, assetFilename))`
   - Determine the bucket based on file extension:
     - `.mp3` -> `card-audio` bucket
     - `.jpg`, `.jpeg`, `.png`, `.gif`, `.webp` -> `card-images` bucket
   - Generate a unique path for upload: `{userId}/{uuid}.{ext}`
   - Upload to Supabase storage using the server-side Supabase client
   - Get the public URL
   - Store the mapping in a Map or object: `urlMap[assetFilename] = { newUrl: publicUrl, newStoragePath: uploadPath }`
   - Wrap each upload in try/catch — if an upload fails, log the error but continue. A missing image is better than a failed template apply.

Import `createServerClient` or the server-side Supabase client pattern from the existing codebase (check `src/lib/supabase/server.ts` or the pattern used in other API routes).
  </action>
  <verify>Run `npx tsc --noEmit` — file compiles. Auth pattern matches existing API routes.</verify>
  <done>Route file created with auth check, template lookup, and asset upload logic that reads from public/templates/{id}/ directory and uploads to user-scoped Supabase storage. URL mapping built for use in Task 2.</done>
</task>

<task type="auto">
  <name>Task 2: Card building with path replacement, mode handling, and response</name>
  <files>src/app/api/templates/apply/route.ts</files>
  <action>
Continue building the route file from Task 1. This task covers steps 4-7: card building, mode handling, batch insert, and response.

4. **Build card records** — For each card in `template.cards`:
   - Generate a new UUID for `id`
   - Set `page_id` to the user's page ID
   - Set `created_at` and `updated_at` to current ISO timestamp
   - Deep-clone the card's `content` object
   - **Replace media references in content using all 3 path-replacement shapes:**

     **Shape A — imageUrl (hero/link cards):**
     If `content.imageUrl` starts with `/templates/`, look up the filename (last segment of the path) in the urlMap. Replace `content.imageUrl` with `urlMap[filename].newUrl`. Set `content.storagePath` to `urlMap[filename].newStoragePath`.

     **Shape B — tracks[] (audio cards):**
     If `content.tracks` exists and is an array, iterate each track. For tracks where `track.audioUrl` starts with `/templates/`, look up filename in urlMap. Replace `track.audioUrl` with `urlMap[filename].newUrl` and `track.storagePath` with `urlMap[filename].newStoragePath`.

     **Shape C — images[] (gallery cards):**
     If `content.images` exists and is an array, iterate each image. For images where `image.imageUrl` starts with `/templates/`, look up filename in urlMap. Replace `image.imageUrl` with `urlMap[filename].newUrl` and `image.storagePath` with `urlMap[filename].newStoragePath`.

   - Map field names for DB insertion: `sortKey` -> `sort_key`, `position` -> `position_x` (using the same mapping as linktree import route)

5. **Handle existing cards:**
   If `mode === 'replace'`:
   - Delete all existing cards for this page: `supabase.from('cards').delete().eq('page_id', pageId)`
   - Then insert new cards

   If `mode === 'add'`:
   - Generate sort keys that come AFTER existing cards (fetch the last card's sort_key, generate new keys starting after it using fractional-indexing)
   - Insert new cards alongside existing

6. **Batch insert** — Insert all card records in one batch (same as linktree import pattern):
   ```typescript
   const { data: insertedCards, error } = await supabase
     .from('cards')
     .insert(cardRecords)
     .select()
   ```
   Return 500 with descriptive error message if card insertion fails.

7. **Map response** — Map inserted DB rows back to Card type (same pattern as linktree import). Return JSON:
   ```typescript
   {
     cards: mappedCards,
     theme: template.theme,
     profile: template.profile,
     templateName: template.name
   }
   ```

Import `generateSortKeys` or the fractional-indexing helper used elsewhere in the codebase for generating sort keys. Check how the linktree import generates sort keys and follow the same pattern.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors.
Test with build:
```bash
npm run build
```
The route should compile without errors. Full integration testing happens in Plan 04.
  </verify>
  <done>POST /api/templates/apply route handles: auth, template lookup, asset upload to user storage, all 3 path-replacement shapes (imageUrl, tracks[], images[]), batch card insertion with both 'replace' and 'add' modes, and returns cards + theme + profile for client hydration.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- Route uses Node.js runtime (not Edge) for fs access
- Asset upload creates user-scoped paths, not shared template paths
- All 3 content path-replacement shapes handled: imageUrl, tracks[], images[]
- Both imageUrl + storagePath are replaced in card content
</verification>

<success_criteria>
- Template assets uploaded to user's Supabase storage with correct bucket routing
- Card content media paths replaced with user-scoped Supabase URLs for all 3 shapes (imageUrl, tracks[], images[])
- Batch card insertion works for both replace and add modes
- Response includes theme state and profile defaults for client hydration
- Route follows existing API patterns (auth, error handling, Supabase client)
</success_criteria>

<output>
After completion, create `.planning/phases/12.2-theme-templates/12.2-03-SUMMARY.md`
</output>
