---
phase: 12.2-theme-templates
plan: 03
type: execute
wave: 2
depends_on: ["12.2-01"]
files_modified:
  - src/app/api/templates/apply/route.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/templates/apply uploads template media assets to user's Supabase storage"
    - "Card content imageUrl/storagePath and audioUrl/storagePath are replaced with user-scoped Supabase URLs"
    - "Cards are batch-inserted into user's page via Supabase"
    - "Theme state and profile defaults are returned for client-side store hydration"
    - "Existing cards can be replaced or kept based on mode parameter"
  artifacts:
    - path: "src/app/api/templates/apply/route.ts"
      provides: "Template application API route"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/templates/apply/route.ts"
      to: "src/lib/templates/index.ts"
      via: "getTemplate(templateId)"
      pattern: "getTemplate"
    - from: "src/app/api/templates/apply/route.ts"
      to: "supabase.storage"
      via: "upload template assets to user buckets"
      pattern: "storage.*from.*upload"
    - from: "src/app/api/templates/apply/route.ts"
      to: "supabase.from('cards')"
      via: "batch insert cards"
      pattern: "\\.insert\\("
---

<objective>
Build the server-side template application API route that handles asset upload and card creation.

Purpose: This is the core engine that transforms a static template definition into a user's live page. It uploads template media to the user's Supabase storage, creates cards with correct storage paths, and returns theme/profile data for client hydration.
Output: POST /api/templates/apply endpoint.
</objective>

<execution_context>
@/Users/julianmunyard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianmunyard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.2-theme-templates/12.2-RESEARCH.md
@src/lib/templates/types.ts (from Plan 01)
@src/lib/templates/index.ts (from Plan 01)
@src/app/api/import/linktree/route.ts
@src/app/api/audio/upload/route.ts
@src/lib/supabase/storage.ts
@src/lib/supabase/server.ts
@src/types/card.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create template apply API route</name>
  <files>src/app/api/templates/apply/route.ts</files>
  <action>
Create `src/app/api/templates/apply/route.ts` as a Node.js runtime API route (NOT Edge — needs fs access).

**Request body:**
```typescript
{ templateId: string, mode: 'replace' | 'add' }
```

**Implementation steps:**

1. **Auth check** — Use the same pattern as `src/app/api/import/linktree/route.ts`: create server Supabase client, call `getUser()`, fetch user's page from `pages` table. Return 401 if not authenticated, 404 if no page.

2. **Load template** — Import `getTemplate` from `@/lib/templates`. Call `getTemplate(templateId)`. Return 404 if template not found.

3. **Upload media assets** — For each file in `template.mediaAssets`:
   - Read the file from disk: `fs.readFileSync(path.join(process.cwd(), 'public', 'templates', template.id, assetFilename))`
   - Determine the bucket based on file extension:
     - `.mp3` -> `card-audio` bucket
     - `.jpg`, `.jpeg`, `.png`, `.gif`, `.webp` -> `card-images` bucket
   - Generate a new card ID (uuid) for this card's assets
   - Upload to Supabase storage with path `{cardId}/{uuid}.{ext}` using the server-side Supabase client
   - Get the public URL
   - Store the mapping: `{ originalPath: assetFilename, newUrl: publicUrl, newStoragePath: uploadPath }`

4. **Build card records** — For each card in `template.cards`:
   - Generate a new UUID for `id`
   - Set `page_id` to the user's page ID
   - Set `created_at` and `updated_at` to current ISO timestamp
   - Deep-clone the card's `content` object
   - Replace any media references in content:
     - If `content.imageUrl` contains a template path (starts with `/templates/`), replace with the uploaded Supabase URL. Also set `content.storagePath` to the new storage path.
     - If `content.tracks` exists (audio card), iterate tracks and replace `audioUrl` and `storagePath` for each track that has a matching template asset.
     - If `content.images` exists (gallery card), iterate and replace `imageUrl` and `storagePath`.
   - Map field names for DB insertion: `sortKey` -> `sort_key`, `position` -> `position_x` (using the same mapping as linktree import route)

5. **Handle existing cards** — If `mode === 'replace'`:
   - Delete all existing cards for this page: `supabase.from('cards').delete().eq('page_id', pageId)`
   - Then insert new cards
   If `mode === 'add'`:
   - Generate sort keys that come AFTER existing cards (fetch the last card's sort_key, generate new keys starting after it using fractional-indexing)
   - Insert new cards alongside existing

6. **Batch insert** — Insert all card records in one batch (same as linktree import pattern):
   ```typescript
   const { data: insertedCards, error } = await supabase
     .from('cards')
     .insert(cardRecords)
     .select()
   ```

7. **Map response** — Map inserted DB rows back to Card type (same pattern as linktree import). Return JSON:
   ```typescript
   {
     cards: mappedCards,
     theme: template.theme,
     profile: template.profile,
     templateName: template.name
   }
   ```

**Error handling:**
- Wrap asset uploads in try/catch — if an upload fails, continue with remaining assets but log the error. A missing image is better than a failed template apply.
- Return 500 with descriptive error message if card insertion fails.

**Important:** Use `export const runtime = 'nodejs'` at the top of the file (same as audio upload route) since we need `fs` access.

Import `generateSortKeys` or the fractional-indexing helper used elsewhere in the codebase for generating sort keys. Check how the linktree import generates sort keys and follow the same pattern.

Import `createServerClient` or the server-side Supabase client pattern from the existing codebase (check `src/lib/supabase/server.ts` or the pattern used in other API routes).
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors.
Test with curl (requires auth cookie, so mainly verify the build):
```bash
npm run build
```
The route should compile without errors. Full integration testing happens in Plan 04.
  </verify>
  <done>POST /api/templates/apply route handles: auth, template lookup, asset upload to user storage, path replacement in card content, batch card insertion, and returns cards + theme + profile for client hydration. Both 'replace' and 'add' modes work.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- Route uses Node.js runtime (not Edge) for fs access
- Asset upload creates user-scoped paths, not shared template paths
- Both imageUrl + storagePath are replaced in card content
</verification>

<success_criteria>
- Template assets uploaded to user's Supabase storage with correct bucket routing
- Card content media paths replaced with user-scoped Supabase URLs
- Batch card insertion works for both replace and add modes
- Response includes theme state and profile defaults for client hydration
- Route follows existing API patterns (auth, error handling, Supabase client)
</success_criteria>

<output>
After completion, create `.planning/phases/12.2-theme-templates/12.2-03-SUMMARY.md`
</output>
