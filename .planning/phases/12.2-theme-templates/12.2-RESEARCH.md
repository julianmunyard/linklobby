# Phase 12.2: Theme Templates - Research

**Researched:** 2026-02-18
**Domain:** Static template data format, Zustand store hydration, Supabase Storage file copy, Next.js API routes, dev-gated UI
**Confidence:** HIGH

---

## Summary

Phase 12.2 ships curated artist-inspired page templates as built-in options. The dev-only builder lets the developer design pages in the live editor and snapshot them as template JSON files that ship with the app. Users then pick a template in a new UI layer integrated into the existing theme picker, and a "Use Template" action hydrates their Zustand stores and persists to Supabase via existing API routes.

The core implementation challenge is **not UI frameworks** — those are all already present (Radix, Vaul, motion/react, Tailwind). The challenge is:
1. Designing the **template JSON schema** that captures all relevant state from three stores (page, theme, profile)
2. Implementing **template application** that correctly hydrates stores and handles Supabase asset upload for template media
3. Implementing the **dev-only snapshot tool** that reads three Zustand stores and serializes them into the JSON format

No new dependencies are needed. The entire feature is built on top of existing infrastructure.

**Primary recommendation:** Ship templates as static TypeScript files in `src/lib/templates/` (not JSON, not a database table). TypeScript gives type safety and tree-shaking. Template assets live in `public/templates/{template-id}/`. Application calls existing bulk API routes.

---

## Standard Stack

### Core (already installed, no additions needed)

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| zustand | ^5.0.10 | Read store snapshots for dev tool, hydrate stores on apply | Already the state layer |
| @supabase/supabase-js | ^2.91.0 | Upload template assets to user storage on apply | Already the storage layer |
| motion/react | ^12.29.3 | Animate template picker UI (same as theme-presets.tsx) | Already used in theme picker |
| vaul | ^1.1.2 | Mobile bottom sheet for template picker | Already the mobile drawer |
| @radix-ui/react-alert-dialog | ^1.1.15 | Confirmation dialog before overwriting existing cards | Already installed |
| sonner | ^2.0.7 | Toast feedback during template application | Already the toast system |

### No New Dependencies Required

The feature requires zero new npm packages. All UI patterns, animation patterns, and API patterns are already established.

**Installation:**
```bash
# Nothing to install
```

---

## Architecture Patterns

### Recommended Project Structure

```
src/
├── lib/
│   └── templates/
│       ├── index.ts            # getAllTemplates(), getTemplatesByTheme(themeId)
│       ├── types.ts            # TemplateDefinition, TemplateCard, TemplateTheme, TemplateProfile
│       └── data/
│           ├── mac-os/
│           │   ├── template-asap-rocky.ts
│           │   └── template-minimal.ts
│           ├── instagram-reels/
│           │   └── template-indie.ts
│           └── ... (one folder per ThemeId)
├── app/
│   └── api/
│       └── templates/
│           └── apply/
│               └── route.ts    # POST: upload assets, create cards, apply theme
│
public/
└── templates/
    ├── mac-os-asap-rocky/
    │   ├── hero.jpg            # Card images (optimized for web)
    │   ├── album-art.jpg       # Audio card album art
    │   └── audio.mp3           # Audio track (used by dev tool, application uploads to user storage)
    └── instagram-reels-indie/
        └── hero.jpg
```

### Pattern 1: Template Definition as TypeScript (not JSON)

**What:** Each template is a strongly-typed TS object that captures all three store states (page, theme, profile) plus metadata.
**When to use:** Always — TypeScript gives compile-time validation, tree-shaking, and IDE autocomplete vs raw JSON files.

```typescript
// Source: derived from existing type definitions in src/types/
// src/lib/templates/types.ts

import type { Card } from '@/types/card'
import type { ThemeState } from '@/types/theme'
import type { Profile } from '@/types/profile'

// A card within a template — same shape as Card, but without DB-specific fields
// id, page_id, created_at, updated_at are omitted (generated fresh on apply)
export interface TemplateCard
  extends Omit<Card, 'id' | 'page_id' | 'created_at' | 'updated_at'> {
  // Media fields reference RELATIVE paths under public/templates/{templateId}/
  // e.g., content.imageUrl = '/templates/mac-os-asap-rocky/hero.jpg'
  // On apply, these are uploaded to user's Supabase storage and URLs replaced
}

// Theme state to apply — full ThemeState minus DB-only fields
export type TemplateTheme = Omit<ThemeState, 'pixels'>

// Profile defaults — partial, only fields a template should set
export interface TemplateProfile
  extends Partial<
    Pick<
      Profile,
      | 'profileLayout'
      | 'showAvatar'
      | 'showTitle'
      | 'titleSize'
      | 'showSocialIcons'
      | 'showLogo'
      | 'headerTextColor'
      | 'socialIconColor'
    >
  > {}

export interface TemplateDefinition {
  id: string                      // e.g., 'mac-os-asap-rocky'
  themeId: string                 // Matches ThemeId — for grouping
  name: string                    // e.g., 'ASAP Rocky Vibes'
  description: string             // Short blurb for picker
  energyLabel?: string            // e.g., 'hip-hop', 'indie folk', 'techno DJ'
  thumbnailPath: string           // '/templates/{id}/thumbnail.jpg' — static image
  cards: TemplateCard[]
  theme: TemplateTheme
  profile: TemplateProfile
  // Asset paths that need to be uploaded to Supabase on apply
  // Key = relative path in template, used to find the file in public/templates/{id}/
  mediaAssets: string[]           // e.g., ['hero.jpg', 'album-art.jpg', 'audio.mp3']
}
```

### Pattern 2: Template Application via API Route

**What:** POST `/api/templates/apply` handles the server-side work: read template file from public, upload assets to Supabase Storage per-user, create cards, save theme.
**When to use:** When the user confirms "Use Template".

```typescript
// Source: derived from existing patterns in src/app/api/import/linktree/route.ts
// and src/app/api/audio/upload/route.ts

// POST /api/templates/apply
// Body: { templateId: string, confirmOverwrite: boolean }
// 1. Auth check (existing pattern)
// 2. Load template definition from src/lib/templates/data/{themeId}/{id}.ts
// 3. Fetch each asset from /public/templates/{id}/{file} via fs.readFileSync
// 4. Upload each asset to appropriate Supabase bucket with user-scoped path
//    - Images → card-images bucket (existing)
//    - Audio → card-audio bucket (existing)
//    - Profile images → profile-images bucket (existing)
// 5. Replace relative asset paths with Supabase public URLs in card content
// 6. If confirmOverwrite, delete existing cards first (or add after)
// 7. Batch insert cards via existing bulk insert pattern
// 8. Return: { cards, themeState, profileDefaults }
// 9. Client: useThemeStore.getState().loadFromDatabase(themeState)
//            useProfileStore.getState().initializeProfile(profileDefaults)
//            usePageStore.getState().setCards(cards)
```

### Pattern 3: Template Picker UI — Extends Existing theme-presets.tsx Pattern

**What:** Add a "Templates" tab to the existing ThemePanel tabs, displayed after selecting a theme in the Presets tab. Follows the exact same two-level navigation pattern (category → detail) already in `theme-presets.tsx`.
**When to use:** Integrating into the existing editor's design panel.

```typescript
// Source: src/components/editor/theme-presets.tsx (existing two-level navigation pattern)

// ThemePanel currently has tabs: Presets | Colors | Fonts | Style
// Add: Templates tab that shows templates for the ACTIVE themeId
// This avoids needing a separate route — templates filtered by useThemeStore().themeId

// Template picker shows:
// - Grid of TemplateCard tiles (thumbnail, name, energy label)
// - Click tile → TemplatePreviewModal (full-screen or large dialog with Apply button)
// - Apply button → confirmation AlertDialog if user has existing cards
// - On confirm → POST /api/templates/apply → reload stores → toast success
```

### Pattern 4: Dev-Only Snapshot Tool (NEXT_PUBLIC_DEV_TOOLS=true)

**What:** A dev-only button in the editor header that reads current Zustand store state and generates a template TypeScript object. The dev copies the output and saves it as a template file.
**When to use:** Dev designing new templates in the editor.

```typescript
// Source: reading store snapshot from existing getSnapshot() methods
// Both theme-store.ts and page-store.ts have getSnapshot() already

function DevTemplateSaver() {
  // Gated by environment variable
  if (process.env.NEXT_PUBLIC_DEV_TOOLS !== 'true') return null

  const handleSave = () => {
    const themeSnapshot = useThemeStore.getState().getSnapshot()
    const pageSnapshot = usePageStore.getState().getSnapshot()  // cards + theme
    const profileSnapshot = useProfileStore.getState().getSnapshot()

    // Build TemplateDefinition object
    const template: TemplateDefinition = {
      id: 'FILL-IN-' + Date.now(),
      themeId: themeSnapshot.themeId,
      name: 'FILL IN NAME',
      description: 'FILL IN DESC',
      energyLabel: 'FILL IN',
      thumbnailPath: '/templates/FILL-IN/thumbnail.jpg',
      cards: pageSnapshot.cards.map(card => ({
        card_type: card.card_type,
        title: card.title,
        // ... etc, omitting id/page_id/timestamps
        // Flag media asset paths for manual replacement
      })),
      theme: themeSnapshot,
      profile: {
        profileLayout: profileSnapshot.profileLayout,
        showAvatar: profileSnapshot.showAvatar,
        // ... etc
      },
      mediaAssets: [], // Manually populated after download
    }

    // Output as formatted TypeScript to browser console + clipboard
    const output = JSON.stringify(template, null, 2)
    navigator.clipboard.writeText(output)
    console.log('Template snapshot copied to clipboard:', output)
    toast.success('Template snapshot copied to clipboard')
  }

  return (
    <Button onClick={handleSave} variant="outline" size="sm">
      Save as Template (DEV)
    </Button>
  )
}
```

### Recommended Project Structure for Template Files

```
src/lib/templates/data/
├── instagram-reels/
│   ├── dark-minimal.ts
│   ├── indie-folk.ts
│   └── neon-pop.ts
├── system-settings/
│   ├── poolsuite-classic.ts
│   └── retrowave.ts
├── blinkies/
│   └── y2k-nostalgia.ts
├── mac-os/
│   └── dark-studio.ts
... (one folder per ThemeId)
```

### Anti-Patterns to Avoid

- **Storing templates in Supabase database:** Templates are static data curated by the developer. Storing in the database adds needless complexity and requires migrations per template. Static TypeScript files are the right level.
- **Serving template assets via API routes:** Next.js static files in `/public` are served directly by the CDN. Don't proxy them through an API route for reads.
- **Re-uploading on every page load:** Template application uploads assets to Supabase once. After apply, the user's cards point to their own Supabase storage URLs — not to the public template path.
- **Sharing Supabase storage paths across users:** Each user must get their own copy of media assets in their user-scoped storage path. `{cardId}/{uuid}.ext` is the existing pattern — follow it.
- **Skipping the Supabase upload step:** You cannot just point card content at `public/templates/` paths. Public paths are relative URLs that don't survive Supabase URL storage patterns, and the media needs to live in the user's storage bucket for deletion tracking.
- **Blocking the UI during asset upload:** Template application may upload multiple files. Use a loading state + optimistic UI — the API route handles uploads server-side (same pattern as linktree import).

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Alert dialog for overwrite confirmation | Custom modal | `@radix-ui/react-alert-dialog` (already installed) | Accessibility, keyboard nav built in |
| Mobile template picker sheet | Custom bottom drawer | `vaul` via existing `MobileBottomSheet` component | Already handles swipe-to-dismiss |
| Animated tab transitions | CSS transitions | `motion/react` AnimatePresence (same as theme-presets.tsx) | Already used in exact same context |
| Asset upload | Custom fetch + blob handling | Existing Supabase storage patterns from `src/lib/supabase/storage.ts` | Exact same bucket/path conventions |
| Bulk card insertion | Sequential card creates | `/api/cards/bulk` POST (existing route) | Handles batch upsert atomically |
| Toast feedback | Custom notification | `sonner` (already installed, used everywhere) | Consistent UX |

**Key insight:** This phase is an integration task, not a new infrastructure task. Every primitive exists. The work is: design the data format, wire up the snapshot tool, build the picker UI, implement the apply route.

---

## Common Pitfalls

### Pitfall 1: Template Cards Reference Static Paths That Break After Apply

**What goes wrong:** Template card `content.imageUrl` points to `/templates/mac-os-asap-rocky/hero.jpg` (a public static path). After apply, the card is saved to the database with this static path. The image renders on the public page, but when the user deletes the card, `deleteCardImage()` tries to remove a path that doesn't exist in Supabase Storage — silent failure. Worse, the user can't replace the image through normal upload flow because there's no `storagePath` set.

**Why it happens:** Forgetting that card content fields like `imageUrl` pair with `storagePath` for deletion. The apply route MUST upload each asset to the user's Supabase storage and replace both `imageUrl` and `storagePath` in card content before insertion.

**How to avoid:** The apply API route fetches each media file from the filesystem (via `fs.readFileSync` from `public/templates/{id}/`), uploads to the appropriate Supabase bucket, then replaces paths in the card content before bulk-inserting.

**Warning signs:** Cards after template apply have no `storagePath` field but have a static `/templates/...` URL.

### Pitfall 2: Theme Store State Contains Fields Not in ThemeState Type

**What goes wrong:** `useThemeStore.getState()` returns a `ThemeStore` (extends `ThemeState` + extra action fields). The dev snapshot tool accidentally captures action functions in the JSON output.

**Why it happens:** Zustand stores mix state and actions into one object. `getSnapshot()` on `theme-store.ts` already solves this correctly — it returns a plain `ThemeState` object.

**How to avoid:** Always call `useThemeStore.getState().getSnapshot()` (the existing method), not `useThemeStore.getState()` directly. Same for page store.

**Warning signs:** Template JSON contains function fields.

### Pitfall 3: Audio Card Content in Templates Is Complex

**What goes wrong:** Audio cards reference `AudioTrack[]` each with `audioUrl` (Supabase public URL) and `storagePath`. The dev's audio is stored in the dev's Supabase account. When a user applies the template, the audio URL is the dev's, not the user's — it may work for playback but the user can never delete it, and it's in the wrong bucket path.

**Why it happens:** Audio is the most complex media asset because it requires the audio API route for MP3 conversion, has `storagePath` separate from `audioUrl`, and is stored in the `card-audio` bucket with path `{cardId}/{trackId}.mp3`.

**How to avoid:** For the apply route, fetch the audio MP3 from `public/templates/{id}/audio.mp3` via `fs.readFileSync`, upload to `card-audio` bucket with path `{newCardId}/{newTrackId}.mp3`, then replace `audioUrl` and `storagePath` in the track object. Use the server-side Supabase client (same as the audio upload API route).

**Warning signs:** After applying a template with audio, the user can't delete the audio track, or the audio URL points to a different user's storage path.

### Pitfall 4: Confirmation Dialog Skipped When No Existing Cards

**What goes wrong:** The confirmation dialog ("This will add X cards to your page. You have Y existing cards. Replace or add?") always shows, even when the user has zero cards — creating needless friction.

**Why it happens:** Applying the confirmation check unconditionally.

**How to avoid:** Only show the confirmation dialog if `usePageStore.getState().cards.length > 0`. If the canvas is empty, apply immediately.

**Warning signs:** User sees a scary confirmation dialog on a blank page.

### Pitfall 5: Template Thumbnails Are Unoptimized GIFs/JPEGs

**What goes wrong:** Template thumbnail images are full-res JPEGs or GIFs, causing the template picker grid to download megabytes of images.

**Why it happens:** Using source media directly as thumbnails.

**How to avoid:** Thumbnails must be small, optimized static images (max 400x300px, JPEG 80% quality, ~20-50KB). Use Next.js `<Image>` component with `width` and `height` props. Generate thumbnails manually during template creation.

**Warning signs:** Template picker grid takes >2s to appear on mobile.

### Pitfall 6: ThemeId in ROADMAP Doesn't Match ThemeId in Code

**What goes wrong:** The ROADMAP lists "System Settings" (Poolsuite feel), but the ThemeId is `'system-settings'`. The ROADMAP mentions "Word Art" and "Lanyard Badge" themes not listed in the phase's 10 template themes.

**Why it happens:** Roadmap was written before all themes were finalized.

**How to avoid:** Use the canonical `ThemeId` type from `src/types/theme.ts` as the source of truth. The 10 themes in the ROADMAP phase description (`instagram-reels`, `system-settings`, `blinkies`, `mac-os`, `macintosh`, `classified`, `departures-board`, `receipt`, `ipod-classic`, `vcr-menu`) map cleanly to existing ThemeIds. `word-art` and `lanyard-badge` are out of scope for this phase.

---

## Code Examples

### Loading Template Assets Server-Side

```typescript
// Source: Node.js fs module (standard, no dependency needed)
// In /api/templates/apply/route.ts
import * as fs from 'fs'
import * as path from 'path'

async function fetchTemplateAsset(templateId: string, assetPath: string): Promise<Buffer> {
  // public/ directory is accessible at build/runtime via process.cwd()
  const fullPath = path.join(process.cwd(), 'public', 'templates', templateId, assetPath)
  return fs.readFileSync(fullPath)
}
```

### Existing getSnapshot() Methods (Already Implemented)

```typescript
// Source: src/stores/theme-store.ts getSnapshot() (line 472)
// Returns clean ThemeState (no action methods) — use this for template capture

const themeSnapshot = useThemeStore.getState().getSnapshot()
// Returns: ThemeState (themeId, paletteId, colors, fonts, style, background,
//          cardTypeFontSizes, centerCards, vcrCenterContent, receiptPrice,
//          receiptStickers, ..., scatterMode, visitorDrag)

// Source: src/stores/page-store.ts getSnapshot() (line 474)
const pageSnapshot = usePageStore.getState().getSnapshot()
// Returns: { cards: Card[], theme: Theme }

// Source: src/stores/profile-store.ts getSnapshot()
const profileSnapshot = useProfileStore.getState().getSnapshot()
// Returns: Profile
```

### Applying Theme State From Template

```typescript
// Source: src/stores/theme-store.ts loadFromDatabase() (line 438)
// Already handles all ThemeState fields with safe defaults

// On client after successful template apply:
useThemeStore.getState().loadFromDatabase(themeStateFromTemplate)
// This sets all theme fields AND sets hasChanges: false

// For profile defaults:
useProfileStore.getState().initializeProfile(profileDefaultsFromTemplate)

// For cards:
usePageStore.getState().setCards(cardsFromApplyResponse)
```

### Filtering Templates by Active Theme

```typescript
// Source: existing pattern from theme-presets.tsx line 44-51
// src/lib/templates/index.ts

import { macOsTemplates } from './data/mac-os'
import { instagramReelsTemplates } from './data/instagram-reels'
// ... etc

const ALL_TEMPLATES: TemplateDefinition[] = [
  ...macOsTemplates,
  ...instagramReelsTemplates,
  // ...
]

export function getTemplatesByTheme(themeId: ThemeId): TemplateDefinition[] {
  return ALL_TEMPLATES.filter(t => t.themeId === themeId)
}

export function getTemplate(id: string): TemplateDefinition | undefined {
  return ALL_TEMPLATES.find(t => t.id === id)
}
```

### Bulk Card Insert (Existing Pattern)

```typescript
// Source: src/app/api/import/linktree/route.ts (lines 127-135)
// This is the exact pattern to use for template card creation

const { data: insertedCards, error: insertError } = await supabase
  .from('cards')
  .insert(cardRecords)  // Array of DB-formatted card objects
  .select()

// cardRecords format (same as linktree import):
// { id, page_id, card_type, title, description, url, content,
//   size, position_x, sort_key, is_visible }
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Template JSON stored in DB | Static TypeScript files in codebase | Design decision for this phase | Templates are dev-curated, static — no DB needed |
| Separate template route | Tab in existing ThemePanel | Design decision | Fewer navigation steps, contextual to active theme |

**Deprecated/outdated:**
- No deprecated patterns apply here — this is a new feature built on existing infrastructure.

---

## Open Questions

1. **Template media that requires conversion (audio WAV/AIFF)**
   - What we know: The audio upload API route handles MP3 conversion via ffmpeg. Template audio stored in `public/templates/` should already be MP3 to avoid conversion overhead on apply.
   - What's unclear: Whether the apply route should re-use the audio upload API route (adding complexity) or directly upload the pre-converted MP3.
   - Recommendation: Store audio as MP3 in the template assets. The apply route uploads it directly to `card-audio` without conversion — simplest path.

2. **How many templates per theme to design first**
   - What we know: ROADMAP says 3-6 per theme, 10 themes = 30-60 total templates. That's a lot of design work.
   - What's unclear: How many templates to ship in v1 vs stub out.
   - Recommendation: Ship 1-2 templates per theme in the first iteration. The infrastructure works the same for 1 or 60. More templates can be added as content without code changes.

3. **Template thumbnail generation approach**
   - What we know: Static screenshot approach (manually take screenshot, optimize) is simplest. Auto-generation from a headless browser is complex (Puppeteer in serverless is hard).
   - What's unclear: Whether the thumbnails need to be animated/live previews or static images.
   - Recommendation: Static JPEG thumbnails manually designed or screenshotted. Live previews are a Phase 2 concern.

4. **Confirmation behavior: Replace vs. Append**
   - What we know: Linktree import appends cards (doesn't delete existing). The ROADMAP says "Confirmation dialog if user has existing cards."
   - What's unclear: Should templates replace all existing cards, or append alongside them?
   - Recommendation: Offer two options: "Replace my page" (delete existing cards, apply template) and "Add to my page" (append template cards). Most users picking a template want a clean start.

5. **Profile photo handling**
   - What we know: Templates can set profile layout/visibility defaults, but should NOT set the user's profile photo — users must supply their own. The template profile config should only include non-media fields (layout, visibility flags, color overrides).
   - What's unclear: Nothing — this is a clear design decision.
   - Recommendation: Never include `avatarUrl` or `logoUrl` in template profile defaults. Profile photos are user-supplied always.

---

## Sources

### Primary (HIGH confidence)
- Direct codebase inspection — `src/types/theme.ts`, `src/types/card.ts`, `src/types/audio.ts`, `src/types/profile.ts` — all type shapes verified
- `src/stores/theme-store.ts` — `getSnapshot()` method at line 472, `loadFromDatabase()` at line 438, confirmed both exist and are usable
- `src/stores/page-store.ts` — `getSnapshot()` at line 474, `setCards()`, store structure confirmed
- `src/app/api/import/linktree/route.ts` — bulk insert pattern verified, asset upload to Supabase during import confirmed
- `src/app/api/audio/upload/route.ts` — audio upload to `card-audio` bucket pattern confirmed
- `src/lib/supabase/storage.ts` — all bucket names and upload patterns confirmed (`card-images`, `profile-images`, `card-videos`, `card-audio`)
- `src/components/editor/theme-presets.tsx` — two-level navigation pattern, AnimatePresence usage confirmed
- `src/components/editor/theme-panel.tsx` — tab structure for Design panel confirmed
- `package.json` — all dependencies confirmed present

### Secondary (MEDIUM confidence)
- Next.js `fs` module access from API routes — standard Node.js capability, confirmed `export const runtime = 'nodejs'` is already used in `audio/upload/route.ts`

### Tertiary (LOW confidence)
- None — all findings are directly from codebase inspection

---

## Metadata

**Confidence breakdown:**
- Template data format: HIGH — derived from existing type definitions, all shapes verified
- Store hydration: HIGH — existing `getSnapshot()` / `loadFromDatabase()` / `initializeProfile()` methods confirmed
- Asset upload pattern: HIGH — linktree import and audio upload routes provide exact pattern
- UI integration: HIGH — theme-presets.tsx and ThemePanel structure verified
- Number of templates to ship: LOW — design/content decision, not a technical question

**Research date:** 2026-02-18
**Valid until:** 2026-03-20 (stable domain, no external dependencies)
