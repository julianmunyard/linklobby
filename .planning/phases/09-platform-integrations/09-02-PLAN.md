---
phase: 09-platform-integrations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/providers/embed-provider.tsx
  - src/app/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Only one embed can play at a time across the page"
    - "Starting a new embed pauses any currently playing embed"
    - "Embeds can register and unregister from the coordination system"
  artifacts:
    - path: "src/components/providers/embed-provider.tsx"
      provides: "React context for playback coordination"
      exports: ["EmbedPlaybackProvider", "useEmbedPlayback"]
    - path: "src/app/layout.tsx"
      provides: "Provider wrapped around app"
      contains: "EmbedPlaybackProvider"
  key_links:
    - from: "src/components/providers/embed-provider.tsx"
      to: "embedsRef"
      via: "Map of pause functions"
      pattern: "embedsRef.*Map"
    - from: "src/app/layout.tsx"
      to: "EmbedPlaybackProvider"
      via: "provider import and usage"
      pattern: "EmbedPlaybackProvider"
---

<objective>
Create the playback coordination context for one-at-a-time embed playback.

Purpose: Per CONTEXT.md, "Only one embed plays at a time - starting a new embed pauses any currently playing." This context manages active embeds and provides pause callbacks.

Output: `EmbedPlaybackProvider` context that embed components can use to coordinate playback.
</objective>

<execution_context>
@/Users/julianmunyard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianmunyard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-platform-integrations/09-CONTEXT.md
@.planning/phases/09-platform-integrations/09-RESEARCH.md
@src/app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EmbedPlaybackProvider context</name>
  <files>src/components/providers/embed-provider.tsx</files>
  <action>
Create the playback coordination context:

```typescript
// src/components/providers/embed-provider.tsx
'use client'

import { createContext, useContext, useCallback, useRef, useState, type ReactNode } from 'react'

interface EmbedPlaybackContextValue {
  // Currently playing embed ID (null if nothing playing)
  activeEmbedId: string | null

  // Register an embed with its pause function
  // Called when embed mounts
  registerEmbed: (id: string, pauseFn: () => void) => void

  // Unregister an embed
  // Called when embed unmounts
  unregisterEmbed: (id: string) => void

  // Set this embed as active, pausing all others
  // Called when embed starts playing
  setActiveEmbed: (id: string) => void

  // Clear active state (when user pauses manually)
  clearActiveEmbed: (id: string) => void
}

const EmbedPlaybackContext = createContext<EmbedPlaybackContextValue | null>(null)

export function EmbedPlaybackProvider({ children }: { children: ReactNode }) {
  const [activeEmbedId, setActiveEmbedId] = useState<string | null>(null)

  // Map of embed ID -> pause function
  // Use ref to avoid re-renders when registering/unregistering
  const embedsRef = useRef<Map<string, () => void>>(new Map())

  const registerEmbed = useCallback((id: string, pauseFn: () => void) => {
    embedsRef.current.set(id, pauseFn)
  }, [])

  const unregisterEmbed = useCallback((id: string) => {
    embedsRef.current.delete(id)
    // If this was the active embed, clear active state
    setActiveEmbedId(prev => prev === id ? null : prev)
  }, [])

  const setActiveEmbed = useCallback((id: string) => {
    // Pause all other embeds
    embedsRef.current.forEach((pauseFn, embedId) => {
      if (embedId !== id) {
        pauseFn()
      }
    })
    setActiveEmbedId(id)
  }, [])

  const clearActiveEmbed = useCallback((id: string) => {
    setActiveEmbedId(prev => prev === id ? null : prev)
  }, [])

  return (
    <EmbedPlaybackContext.Provider value={{
      activeEmbedId,
      registerEmbed,
      unregisterEmbed,
      setActiveEmbed,
      clearActiveEmbed,
    }}>
      {children}
    </EmbedPlaybackContext.Provider>
  )
}

export function useEmbedPlayback() {
  const context = useContext(EmbedPlaybackContext)
  if (!context) {
    throw new Error('useEmbedPlayback must be used within EmbedPlaybackProvider')
  }
  return context
}

// Optional hook for embeds that may not be in a provider context
// (e.g., public pages where coordination isn't critical)
export function useOptionalEmbedPlayback() {
  return useContext(EmbedPlaybackContext)
}
```

**Key implementation notes from RESEARCH.md:**

1. Spotify has iFrame API for pause control (requires script load)
2. SoundCloud has Widget API for pause control (requires script load)
3. Apple Music does NOT support programmatic pause - we accept this limitation
4. YouTube supports postMessage for pause control
5. TikTok/Instagram - limited control, best effort

The actual pause implementations will be added to each embed component in later plans. This context provides the coordination mechanism.
  </action>
  <verify>
1. File exists: `ls src/components/providers/embed-provider.tsx`
2. TypeScript compiles: `npx tsc --noEmit`
3. Exports are correct: `grep -n "export" src/components/providers/embed-provider.tsx`
  </verify>
  <done>
EmbedPlaybackProvider exports provider component and useEmbedPlayback hook. Context tracks activeEmbedId and provides register/unregister/setActive functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add EmbedPlaybackProvider to app layout</name>
  <files>src/app/layout.tsx</files>
  <action>
Add the EmbedPlaybackProvider to the root layout so all pages have access:

1. Import at top of file:
   ```typescript
   import { EmbedPlaybackProvider } from '@/components/providers/embed-provider'
   ```

2. Wrap the children inside the existing provider tree. Find where other providers are and add EmbedPlaybackProvider there.

**Typical pattern:**
```tsx
<ThemeProvider>
  <EmbedPlaybackProvider>
    {children}
  </EmbedPlaybackProvider>
</ThemeProvider>
```

If there's no ThemeProvider or it's structured differently, add EmbedPlaybackProvider as an inner wrapper around `{children}`.

**Important:** This provider should wrap both the editor and public pages since both can have embeds.

**Do NOT:**
- Remove any existing providers
- Change the order of critical providers (auth, theme)
  </action>
  <verify>
1. `grep -n "EmbedPlaybackProvider" src/app/layout.tsx` shows import and usage
2. App runs without errors: `npm run dev` and check browser console
  </verify>
  <done>
EmbedPlaybackProvider wraps app content in layout.tsx. All pages can access the playback coordination context.
  </done>
</task>

</tasks>

<verification>
- [ ] `src/components/providers/embed-provider.tsx` exists and exports EmbedPlaybackProvider, useEmbedPlayback, useOptionalEmbedPlayback
- [ ] EmbedPlaybackProvider is used in `src/app/layout.tsx`
- [ ] TypeScript compiles without errors
- [ ] App runs without errors in browser
</verification>

<success_criteria>
1. Context provides activeEmbedId state
2. Context provides registerEmbed, unregisterEmbed, setActiveEmbed, clearActiveEmbed functions
3. Provider is available throughout the app
4. useEmbedPlayback hook throws if used outside provider
5. useOptionalEmbedPlayback hook returns null outside provider (for graceful degradation)
</success_criteria>

<output>
After completion, create `.planning/phases/09-platform-integrations/09-02-SUMMARY.md`
</output>
