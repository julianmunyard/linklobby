---
phase: 12-audio-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/audio/engine/audioEngine.ts
  - src/audio/engine/types.ts
  - src/audio/hooks/useAudioPlayer.ts
  - src/audio/hooks/useWaveform.ts
  - public/worklet/audioProcessor.js
  - public/superpowered/README.md
autonomous: true

must_haves:
  truths:
    - "AudioEngine singleton can initialize Superpowered SDK with AudioWorklet"
    - "AudioEngine can load, play, pause, seek audio files"
    - "AudioEngine supports varispeed in both Natural and TimeStretch modes (0.5x-1.5x)"
    - "AudioEngine supports reverb with configurable mix, width, damp, roomSize, predelay"
    - "iOS silent audio unlock pattern keeps media channel active"
    - "useAudioPlayer hook provides play/pause/seek/progress state and integrates with EmbedPlaybackProvider"
    - "useWaveform hook generates waveform data from audio buffer client-side"
  artifacts:
    - path: "src/audio/engine/audioEngine.ts"
      provides: "Singleton AudioEngine class ported from Munyard Mixer"
      exports: ["AudioEngine", "getAudioEngine"]
    - path: "src/audio/hooks/useAudioPlayer.ts"
      provides: "React hook for audio playback control with EmbedPlaybackProvider integration"
      exports: ["useAudioPlayer"]
    - path: "src/audio/hooks/useWaveform.ts"
      provides: "React hook for client-side waveform data generation"
      exports: ["useWaveform"]
    - path: "public/worklet/audioProcessor.js"
      provides: "AudioWorklet processor for Superpowered SDK"
    - path: "src/audio/engine/types.ts"
      provides: "Engine-specific type definitions"
      exports: ["AudioEngineState", "AudioEngineMessage", "VarispeedMode"]
  key_links:
    - from: "src/audio/engine/audioEngine.ts"
      to: "public/worklet/audioProcessor.js"
      via: "AudioWorkletNode creation with processor URL"
      pattern: "createAudioNodeAsync|addModule"
    - from: "src/audio/hooks/useAudioPlayer.ts"
      to: "src/audio/engine/audioEngine.ts"
      via: "import getAudioEngine for playback control"
      pattern: "getAudioEngine"
    - from: "src/audio/hooks/useAudioPlayer.ts"
      to: "src/components/providers/embed-provider.tsx"
      via: "useOptionalEmbedPlayback for one-at-a-time coordination"
      pattern: "useOptionalEmbedPlayback"
---

<objective>
Port the audio engine from Munyard Mixer to LinkLobby and create React hooks for audio playback.

Purpose: This is the core audio processing layer. Without a working audio engine, no audio card can play sound. The engine provides play/pause/seek, varispeed (natural + time-stretch), and reverb -- the core differentiators of LinkLobby's audio system.

Output: AudioEngine singleton class, AudioWorklet processor, useAudioPlayer hook with EmbedPlaybackProvider integration, useWaveform hook for waveform generation.
</objective>

<execution_context>
@/Users/julianmunyard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianmunyard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-audio-system/12-CONTEXT.md
@.planning/phases/12-audio-system/12-RESEARCH.md
@src/components/providers/embed-provider.tsx

Port from Munyard Mixer codebase at: /Users/julianmunyard/Documents/ESSENTIAL WEBSITES/NEW MUNYARD MIXER
Key source files:
- audio/engine/thomasAudioEngine.js (core engine with Superpowered)
- audio/engine/realTimelineMixerEngine.js (engine wrapper)
- audio/engine/types.ts (engine types)
- app/components/hooks/useAudioEngine.ts (React hook with iOS unlock)
- public/worklet/timelineProcessor.js (AudioWorklet processor)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port AudioEngine and AudioWorklet processor from Munyard Mixer</name>
  <files>
    src/audio/engine/audioEngine.ts
    src/audio/engine/types.ts
    public/worklet/audioProcessor.js
    public/superpowered/README.md
  </files>
  <action>
Read the Munyard Mixer source files thoroughly before porting:
- `/Users/julianmunyard/Documents/ESSENTIAL WEBSITES/NEW MUNYARD MIXER/audio/engine/thomasAudioEngine.js`
- `/Users/julianmunyard/Documents/ESSENTIAL WEBSITES/NEW MUNYARD MIXER/audio/engine/realTimelineMixerEngine.js`
- `/Users/julianmunyard/Documents/ESSENTIAL WEBSITES/NEW MUNYARD MIXER/audio/engine/types.ts`
- `/Users/julianmunyard/Documents/ESSENTIAL WEBSITES/NEW MUNYARD MIXER/public/worklet/timelineProcessor.js`
- `/Users/julianmunyard/Documents/ESSENTIAL WEBSITES/NEW MUNYARD MIXER/app/components/hooks/useAudioEngine.ts`

**Create `src/audio/engine/types.ts`:**
```typescript
export type VarispeedMode = 'natural' | 'timestretch'

export interface AudioEngineState {
  isPlaying: boolean
  isLoaded: boolean
  currentTime: number      // seconds
  duration: number         // seconds
  progress: number         // 0-1
  speed: number            // 0.5-1.5
  varispeedMode: VarispeedMode
  reverbMix: number        // 0-1 (visitor-controlled wet/dry)
}

export interface AudioEngineCallbacks {
  onProgress?: (time: number, duration: number) => void
  onEnded?: () => void
  onLoaded?: (duration: number) => void
  onError?: (error: string) => void
}

export type AudioEngineMessage =
  | { type: 'command'; data: { command: 'play' } }
  | { type: 'command'; data: { command: 'pause' } }
  | { type: 'command'; data: { command: 'seek'; position: number } }
  | { type: 'command'; data: { command: 'setVarispeed'; speed: number; isNatural: boolean } }
  | { type: 'command'; data: { command: 'setReverbMix'; mix: number } }
  | { type: 'command'; data: { command: 'setReverbConfig'; config: Record<string, number | boolean> } }
  | { type: 'command'; data: { command: 'loadTrack'; url: string } }
  | { type: 'command'; data: { command: 'setLooping'; enabled: boolean } }
```

**Create `src/audio/engine/audioEngine.ts`:**
Port from `thomasAudioEngine.js` and `realTimelineMixerEngine.js`, adapting for LinkLobby's simpler use case (single track player, not a mixer timeline). Key adaptations:

1. **Singleton pattern:** `let instance: AudioEngine | null = null; export function getAudioEngine(): AudioEngine`
2. **init():** Initialize Superpowered WASM, create SuperpoweredWebAudio manager, load AudioWorklet from `${window.location.origin}/worklet/audioProcessor.js`
3. **loadTrack(url: string):** Load audio file for playback via message to worklet
4. **play() / pause() / seek(position: number):** Send commands to AudioWorklet
5. **setVarispeed(speed: number, mode: VarispeedMode):** Send varispeed command with isNatural flag. Range 0.5-1.5.
6. **setReverbConfig(config: ReverbConfig):** Send full reverb parameters to worklet (artist-configured)
7. **setReverbMix(mix: number):** Send just the mix value (visitor knob control)
8. **setLooping(enabled: boolean):** Toggle track looping
9. **iOS silent audio unlock:** Port the silent MP3 unlock pattern from Munyard Mixer's `useAudioEngine.ts` (lines 143-239). Create silent audio element on first user interaction, keep it looping while engine is active. Volume 0.001 (not zero -- iOS mutes zero).
10. **Progress tracking:** Set up requestAnimationFrame loop or worklet messages to report playback position back to main thread.
11. **Cleanup:** `destroy()` method that disconnects nodes, closes AudioContext, clears singleton.

Handle the case where Superpowered SDK is not available (development without license):
- Create a fallback mode using standard Web Audio API (AudioBufferSourceNode) for basic play/pause/seek
- Varispeed and reverb will be no-ops in fallback mode
- Log a warning: "Superpowered SDK not available, using basic Web Audio fallback"

Install `@superpoweredsdk/web` package. If the package fails to install or has issues, implement the fallback-only mode initially and add Superpowered integration later.

**Create `public/worklet/audioProcessor.js`:**
Port from Munyard Mixer's `timelineProcessor.js`, simplifying for single-track playback:
- Register as "AudioProcessor" (matching the name used in audioEngine.ts)
- Handle messages: loadTrack, play, pause, seek, setVarispeed, setReverbConfig, setReverbMix, setLooping
- Send back: progress updates, track ended events, loaded events
- Use Superpowered's AdvancedAudioPlayer for playback with built-in varispeed
- Use Superpowered's Reverb for reverb effect
- Chain: AdvancedAudioPlayer -> Reverb -> output

**Create `public/superpowered/README.md`:**
Note that Superpowered WASM files should be placed here if using local WASM loading. The npm package `@superpoweredsdk/web` includes the WASM binary, so local files may not be needed. Document the setup.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Verify `public/worklet/audioProcessor.js` exists and is valid JavaScript
3. Verify `src/audio/engine/audioEngine.ts` exports `AudioEngine` class and `getAudioEngine` function
4. Check that iOS silent unlock pattern is included
  </verify>
  <done>
AudioEngine class ported from Munyard Mixer with play/pause/seek, varispeed (Natural + TimeStretch at 0.5x-1.5x), reverb (full config + visitor mix knob), iOS silent unlock, and AudioWorklet processor. Singleton pattern prevents memory leaks. Fallback mode works without Superpowered SDK.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useAudioPlayer and useWaveform React hooks</name>
  <files>
    src/audio/hooks/useAudioPlayer.ts
    src/audio/hooks/useWaveform.ts
  </files>
  <action>
**Create `src/audio/hooks/useAudioPlayer.ts`:**
Port from Munyard Mixer's `useAudioEngine.ts`, adapting for LinkLobby's card-based architecture:

```typescript
interface UseAudioPlayerOptions {
  cardId: string
  trackUrl?: string
  looping?: boolean
  reverbConfig?: ReverbConfig  // from @/types/audio
  onPlay?: () => void
  onPause?: () => void
  onEnded?: () => void
}

interface UseAudioPlayerReturn {
  isPlaying: boolean
  isLoaded: boolean
  isLoading: boolean
  currentTime: number
  duration: number
  progress: number          // 0-1
  speed: number             // current varispeed
  varispeedMode: VarispeedMode
  reverbMix: number         // visitor-controlled mix

  play: () => void
  pause: () => void
  togglePlay: () => void
  seek: (position: number) => void       // 0-1
  setSpeed: (speed: number) => void      // 0.5-1.5
  setVarispeedMode: (mode: VarispeedMode) => void
  setReverbMix: (mix: number) => void    // 0-1
  loadTrack: (url: string) => void
}
```

Key behaviors:
1. **EmbedPlaybackProvider integration:** Use `useOptionalEmbedPlayback()` to coordinate. On play, call `setActiveEmbed(cardId)` to pause all other audio/music embeds. On pause, call `clearActiveEmbed(cardId)`. On mount, `registerEmbed(cardId, pause)`. On unmount, `unregisterEmbed(cardId)`.
2. **iOS unlock:** Call `audioEngine.ensureUnlocked()` on first play interaction
3. **Progress updates:** Use requestAnimationFrame or engine callbacks to update currentTime/progress state
4. **Track loading:** When trackUrl changes, load new track into engine
5. **Looping:** Pass looping setting to engine
6. **Cleanup:** Pause and unregister on unmount

**Create `src/audio/hooks/useWaveform.ts`:**

```typescript
interface UseWaveformOptions {
  audioUrl?: string
  peaks?: number            // Number of data points (default 128)
}

interface UseWaveformReturn {
  waveformData: number[] | null   // Array of 0-1 peak values
  isGenerating: boolean
  error: string | null
}
```

Implementation:
1. When audioUrl changes, fetch the audio file as ArrayBuffer
2. Decode using `AudioContext.decodeAudioData()`
3. Extract peaks from the decoded audio buffer:
   - Divide buffer into `peaks` segments
   - For each segment, find the maximum absolute value
   - Normalize all values to 0-1 range
4. Run in a useEffect with cleanup (abort fetch if unmounted)
5. Cache results in a ref to avoid re-generating for same URL
6. Handle errors gracefully (return null waveformData)

This generates waveform data client-side for display. The data can be stored back to the card content for future visits (avoiding re-generation).
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `useAudioPlayer` hook exports correct interface
3. `useWaveform` hook exports correct interface
4. EmbedPlaybackProvider integration uses `useOptionalEmbedPlayback` (not `useEmbedPlayback`)
  </verify>
  <done>
useAudioPlayer hook provides complete playback control (play/pause/seek/varispeed/reverb) with EmbedPlaybackProvider integration for one-at-a-time playback. useWaveform hook generates waveform peaks client-side from audio buffer. Both hooks handle cleanup and error states correctly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. AudioEngine can be imported and instantiated
3. AudioWorklet processor file exists at `public/worklet/audioProcessor.js`
4. useAudioPlayer integrates with EmbedPlaybackProvider via useOptionalEmbedPlayback
5. useWaveform can decode audio and extract peak data
6. iOS silent audio unlock pattern is implemented
7. Varispeed supports both Natural and TimeStretch modes
8. Reverb supports full config (artist) and mix-only (visitor) control
</verification>

<success_criteria>
- AudioEngine singleton with Superpowered SDK (or Web Audio fallback)
- Play, pause, seek, varispeed, reverb all functional
- iOS silent audio unlock pattern ported
- useAudioPlayer hook with full EmbedPlaybackProvider integration
- useWaveform hook generates peaks from audio buffer
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-audio-system/12-02-SUMMARY.md`
</output>
