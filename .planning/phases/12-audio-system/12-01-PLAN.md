---
phase: 12-audio-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/card.ts
  - src/types/audio.ts
  - src/lib/supabase/storage.ts
  - src/app/api/audio/upload/route.ts
  - src/app/api/audio/convert/route.ts
  - src/app/api/audio/waveform/route.ts
  - src/stores/page-store.ts
  - next.config.ts
  - public/worklet/.gitkeep
autonomous: true

must_haves:
  truths:
    - "AudioCardContent type exists with tracks, albumArt, reverbConfig, colors, looping, showWaveform fields"
    - "Audio files can be uploaded to Supabase Storage via API route with 100MB limit"
    - "Uploaded audio files are converted to MP3 format for playback"
    - "Pre-computed waveform data is generated on upload and stored in card content"
    - "Audio card type can be added from the editor with correct default content"
    - "next.config.ts has webpack config for AudioWorklet support"
  artifacts:
    - path: "src/types/audio.ts"
      provides: "AudioCardContent, AudioTrack, ReverbConfig, PlayerColors interfaces"
      exports: ["AudioCardContent", "AudioTrack", "ReverbConfig", "PlayerColors"]
    - path: "src/app/api/audio/upload/route.ts"
      provides: "Audio file upload endpoint with conversion and waveform generation"
      exports: ["POST"]
    - path: "public/worklet/.gitkeep"
      provides: "Directory for AudioWorklet processor files"
  key_links:
    - from: "src/types/card.ts"
      to: "src/types/audio.ts"
      via: "import AudioCardContent, add to CardContent union"
      pattern: "AudioCardContent"
    - from: "src/stores/page-store.ts"
      to: "src/types/audio.ts"
      via: "import for audio card defaults in addCard"
      pattern: "case 'audio'"
    - from: "src/app/api/audio/upload/route.ts"
      to: "src/lib/supabase/storage.ts"
      via: "Supabase Storage upload for audio files"
      pattern: "supabase.storage"
---

<objective>
Create the audio card type system, file upload infrastructure, and conversion pipeline for the audio system.

Purpose: Establish the data foundation that all audio components will build on -- types, storage, upload API, MP3 conversion, and waveform pre-computation. Without this, no audio card can be created or played.

Output: AudioCardContent types, audio upload API with conversion, waveform generation, webpack config for AudioWorklet, and audio card default content in page store.
</objective>

<execution_context>
@/Users/julianmunyard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianmunyard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-audio-system/12-CONTEXT.md
@.planning/phases/12-audio-system/12-RESEARCH.md
@src/types/card.ts
@src/stores/page-store.ts
@src/lib/supabase/storage.ts
@next.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audio types and update card type system</name>
  <files>
    src/types/audio.ts
    src/types/card.ts
    src/stores/page-store.ts
  </files>
  <action>
Create `src/types/audio.ts` with these interfaces:

```typescript
export interface AudioTrack {
  id: string              // crypto.randomUUID()
  title: string
  artist: string
  duration: number        // seconds
  audioUrl: string        // Supabase Storage public URL (MP3)
  storagePath: string     // For deletion
  waveformData?: number[] // Pre-computed waveform peaks (128 data points)
}

export interface ReverbConfig {
  mix: number          // Wet/dry mix (0-1), default 0.3
  width: number        // Stereo width (0-1), default 0.8
  damp: number         // High frequency damping (0-1), default 0.5
  roomSize: number     // Reverb decay time (0-1), default 0.5
  predelayMs: number   // Pre-delay in ms (0-200), default 20
  enabled: boolean     // Whether reverb is active, default false
}

export interface PlayerColors {
  borderColor?: string         // Card border/outline color
  elementBgColor?: string      // Button fills, slider track backgrounds
  foregroundColor?: string     // Play icon, knob ticks, text, active highlights
}

export interface AudioCardContent {
  tracks: AudioTrack[]
  albumArtUrl?: string           // Square album art (shared for all tracks)
  albumArtStoragePath?: string   // For deletion
  currentTrackIndex?: number     // Default 0
  showWaveform?: boolean         // true = waveform, false = progress bar (default true)
  looping?: boolean              // Artist-set loop toggle (default false)
  reverbConfig?: ReverbConfig    // Artist-configured reverb parameters
  playerColors?: PlayerColors    // 3 color customization fields
  transparentBackground?: boolean
  textColor?: string
}

export const DEFAULT_REVERB_CONFIG: ReverbConfig = {
  mix: 0.3, width: 0.8, damp: 0.5, roomSize: 0.5, predelayMs: 20, enabled: false
}

export const DEFAULT_AUDIO_CONTENT: AudioCardContent = {
  tracks: [],
  showWaveform: true,
  looping: false,
  reverbConfig: DEFAULT_REVERB_CONFIG,
}
```

Update `src/types/card.ts`:
1. Add `import type { AudioCardContent } from './audio'` and `import { DEFAULT_AUDIO_CONTENT } from './audio'`
2. Add `AudioCardContent` to the `CardContent` union type
3. Add `isAudioContent` type guard: `return typeof content === 'object' && content !== null && 'tracks' in content && Array.isArray((content as any).tracks)`
4. Re-export `AudioCardContent` from card.ts for convenience: `export type { AudioCardContent } from './audio'`

Update `src/stores/page-store.ts`:
1. Import `DEFAULT_AUDIO_CONTENT` from `@/types/audio`
2. Add `case 'audio':` to the `addCard` default content switch, returning `{ ...DEFAULT_AUDIO_CONTENT }`

Note: `CARD_TYPE_SIZING` already has `audio: null` (always full width) and `CARD_TYPES_NO_IMAGE` already includes `'audio'`. These are correct -- no changes needed.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Check that AudioCardContent is importable from both `@/types/audio` and `@/types/card`.
  </verify>
  <done>
AudioCardContent interface exists with all required fields (tracks, albumArt, reverbConfig, playerColors, showWaveform, looping). Card type system updated with audio content type. Page store creates correct default content when adding audio card.
  </done>
</task>

<task type="auto">
  <name>Task 2: Audio upload API with conversion and waveform generation</name>
  <files>
    src/app/api/audio/upload/route.ts
    src/lib/supabase/storage.ts
    next.config.ts
    public/worklet/.gitkeep
  </files>
  <action>
**Update `src/lib/supabase/storage.ts`:**
Add a new `AUDIO_BUCKET` constant: `const AUDIO_BUCKET = "card-audio"` with `MAX_AUDIO_SIZE = 100 * 1024 * 1024` (100MB).
Add `uploadAudioFile(file: File | Blob, cardId: string, trackId: string)` function following the same pattern as `uploadCardImage` but using `AUDIO_BUCKET`, accepting larger files, and generating path as `${cardId}/${trackId}.mp3`. Return `UploadResult` with url and path.
Add `deleteAudioFile(path: string)` function to remove audio from storage.

**Create `src/app/api/audio/upload/route.ts`:**
POST endpoint that:
1. Requires auth (use `createClient` from `@/lib/supabase/server`, verify user with `supabase.auth.getUser()`)
2. Accepts FormData with: `file` (audio file), `cardId` (string), `trackId` (string)
3. Validates file size (100MB max) -- reject with 413 if too large
4. **Conversion approach:** Use client-side conversion with `ffmpeg.wasm` (the executor will install `@ffmpeg/ffmpeg` and `@ffmpeg/util`). However, since conversion is complex and browser-dependent, implement a simpler initial approach:
   - If file is already MP3 (`audio/mpeg`), upload directly to Supabase Storage
   - If file is WAV or other format, convert to MP3 server-side using a Next.js API route with `ffmpeg` (the Node.js native ffmpeg wrapper, not WASM)
   - **Practical decision:** For initial implementation, accept MP3 files directly and WAV files. For WAV conversion, use the npm package `fluent-ffmpeg` if ffmpeg binary is available, OR fall back to accepting the WAV as-is with a warning that conversion is recommended.
   - The most practical approach for v1: Accept any audio file, upload it as-is to Supabase. If it's not MP3, the audio engine will still play it (Superpowered handles multiple formats). Add a TODO comment for server-side conversion optimization.
5. Generate waveform data:
   - Use the Web Audio API's `decodeAudioData` on the server? No -- this runs in Node.js, not browser.
   - **Practical approach:** Return the uploaded URL without waveform. Waveform generation will happen client-side in the browser using `AudioContext.decodeAudioData()` and a utility function. Add a `waveformData` field to the track that gets populated client-side after upload.
6. Upload to Supabase Storage via `uploadAudioFile()`
7. Return JSON with: `{ url, storagePath, duration }` (duration extracted if possible, otherwise null)

Set `export const config = { api: { bodyParser: false } }` to handle large file uploads, OR use Next.js App Router's built-in FormData handling with `export const maxDuration = 60` and increase body size.

For Next.js App Router, configure body size limit in route segment config:
```typescript
export const runtime = 'nodejs'
// No special config needed - FormData handles streaming
```

**Create `public/worklet/.gitkeep`:**
Empty file to ensure the worklet directory exists in the repo. The actual AudioWorklet processor file will be created in Plan 02.

**Update `next.config.ts`:**
Add webpack configuration for AudioWorklet support:
```typescript
webpack: (config, { isServer }) => {
  if (!isServer) {
    config.output.globalObject = "(typeof self !== 'undefined' ? self : this)"
  }
  return config
}
```
Keep existing `images` config. Merge with webpack config.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `ls public/worklet/.gitkeep` confirms directory exists
3. Verify next.config.ts has webpack config by reading the file
4. Test upload endpoint exists: `curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/audio/upload` returns 401 (auth required)
  </verify>
  <done>
Audio upload API accepts files up to 100MB, stores in Supabase "card-audio" bucket, returns URL and storage path. next.config.ts has AudioWorklet webpack config. public/worklet/ directory exists for AudioWorklet processor files.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. AudioCardContent type is comprehensive (tracks, albumArt, reverbConfig, playerColors, showWaveform, looping)
3. Audio card can be added from page store with correct defaults
4. Upload API route exists and requires auth
5. next.config.ts has AudioWorklet webpack configuration
6. public/worklet/ directory exists
</verification>

<success_criteria>
- AudioCardContent and supporting types defined and exported
- Card type system updated with audio content in union type
- Page store creates audio card with default content
- Audio upload API accepts files up to 100MB and stores in Supabase
- Webpack configured for AudioWorklet
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-audio-system/12-01-SUMMARY.md`
</output>
