---
phase: 04.1-flow-layout
plan: 02
type: execute
wave: 2
depends_on: ["04.1-01"]
files_modified:
  - src/components/editor/card-property-editor.tsx
  - src/components/canvas/flow-grid.tsx
  - src/components/canvas/position-drop-zone.tsx
  - src/components/canvas/sortable-flow-card.tsx
autonomous: true

must_haves:
  truths:
    - "Size selector hidden for Horizontal cards"
    - "Size selector shows Big/Small for Hero and Square cards"
    - "FlowGrid uses CSS flexbox with wrap"
    - "Position drop zones appear when dragging small cards"
    - "DragOverlay provides visual feedback during drag"
  artifacts:
    - path: "src/components/editor/card-property-editor.tsx"
      provides: "Conditional size selector based on card type"
      contains: "CARD_TYPE_SIZING"
    - path: "src/components/canvas/flow-grid.tsx"
      provides: "Flexbox flow container with dnd-kit integration"
      contains: "flex flex-wrap"
    - path: "src/components/canvas/position-drop-zone.tsx"
      provides: "Left/center/right droppable zones"
      contains: "useDroppable"
    - path: "src/components/canvas/sortable-flow-card.tsx"
      provides: "Size-aware sortable card wrapper"
      contains: "useSortable"
  key_links:
    - from: "src/components/canvas/flow-grid.tsx"
      to: "src/components/canvas/position-drop-zone.tsx"
      via: "renders PositionDropZone when dragging small card"
      pattern: "PositionDropZone"
    - from: "src/components/canvas/flow-grid.tsx"
      to: "src/components/canvas/sortable-flow-card.tsx"
      via: "renders SortableFlowCard for each card"
      pattern: "SortableFlowCard"
---

<objective>
Create flow layout components and update property editor for Big/Small sizing.

Purpose: Build the visual components that enable side-by-side card arrangement. The property editor gets a conditional size selector, and new canvas components handle the flexbox flow layout with drag positioning.

Output: Updated CardPropertyEditor, new FlowGrid, PositionDropZone, and SortableFlowCard components.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.1-flow-layout/04.1-CONTEXT.md
@.planning/phases/04.1-flow-layout/04.1-RESEARCH.md
@.planning/phases/04.1-flow-layout/04.1-01-SUMMARY.md

# Current files
@src/components/editor/card-property-editor.tsx
@src/components/canvas/sortable-card-list.tsx
@src/components/canvas/sortable-card.tsx
@src/types/card.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Property Editor with Conditional Size Selector</name>
  <files>src/components/editor/card-property-editor.tsx</files>
  <action>
Update src/components/editor/card-property-editor.tsx to conditionally show size selector:

1. Import CARD_TYPE_SIZING:
```typescript
import { CARD_SIZES, CARD_TYPE_SIZING } from "@/types/card"
```

2. Replace the current Card Size section with conditional rendering. Find the section:
```tsx
{/* Card Size */}
<div className="space-y-2">
  <Label htmlFor="cardSize">Card Size</Label>
  ...
</div>
```

Replace with:
```tsx
{/* Card Size - only show if card type supports sizing */}
{CARD_TYPE_SIZING[card.card_type] && (
  <div className="space-y-2">
    <Label htmlFor="cardSize">Card Size</Label>
    <Select
      value={card.size}
      onValueChange={(value) => updateCard(card.id, { size: value as CardSize })}
    >
      <SelectTrigger id="cardSize">
        <SelectValue />
      </SelectTrigger>
      <SelectContent>
        {CARD_TYPE_SIZING[card.card_type]!.map((size) => (
          <SelectItem key={size} value={size}>
            {CARD_SIZES[size].label} - {CARD_SIZES[size].description}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  </div>
)}
```

This ensures:
- Horizontal cards never show size selector (CARD_TYPE_SIZING.horizontal = null)
- Hero and Square cards show Big/Small options
- The label shows both name and description ("Big - Full width")

Also add HorizontalPosition to the imports if needed for future position display.
  </action>
  <verify>
`grep "CARD_TYPE_SIZING\[card.card_type\]" src/components/editor/card-property-editor.tsx` returns match.
TypeScript compiles: `npx tsc --noEmit` shows no errors.
Dev server runs without errors: `npm run dev` (check briefly, then stop).
  </verify>
  <done>Property editor conditionally shows size selector based on card type.</done>
</task>

<task type="auto">
  <name>Task 2: Create Flow Layout Canvas Components</name>
  <files>src/components/canvas/flow-grid.tsx, src/components/canvas/position-drop-zone.tsx, src/components/canvas/sortable-flow-card.tsx</files>
  <action>
Create three new components for the flow layout system:

**1. Create src/components/canvas/position-drop-zone.tsx:**
```typescript
"use client"

import { useDroppable } from "@dnd-kit/core"
import { cn } from "@/lib/utils"
import type { HorizontalPosition } from "@/types/card"

interface PositionDropZoneProps {
  position: HorizontalPosition
}

export function PositionDropZone({ position }: PositionDropZoneProps) {
  const { setNodeRef, isOver } = useDroppable({
    id: `position-${position}`,
    data: { type: "position", position },
  })

  return (
    <div
      ref={setNodeRef}
      className={cn(
        "flex-1 flex items-center justify-center border-2 border-dashed transition-colors rounded-lg",
        isOver
          ? "border-primary bg-primary/10"
          : "border-muted-foreground/30 bg-muted/5",
      )}
    >
      <span
        className={cn(
          "text-xs font-medium uppercase tracking-wide",
          isOver ? "text-primary" : "text-muted-foreground/50",
        )}
      >
        {position}
      </span>
    </div>
  )
}
```

**2. Create src/components/canvas/sortable-flow-card.tsx:**
```typescript
"use client"

import { useSortable } from "@dnd-kit/sortable"
import { CSS } from "@dnd-kit/utilities"
import { cn } from "@/lib/utils"
import { CardRenderer } from "@/components/cards/card-renderer"
import type { Card } from "@/types/card"

interface SortableFlowCardProps {
  card: Card
  isDragging?: boolean
}

export function SortableFlowCard({ card, isDragging }: SortableFlowCardProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
  } = useSortable({ id: card.id })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  }

  // Width classes based on size
  // Big = full width, Small = half width (minus gap)
  const widthClass = card.size === "big"
    ? "w-full"
    : "w-[calc(50%-0.5rem)]"

  // Position classes for small cards
  const positionClass = card.size === "small" && card.position === "center"
    ? "mx-auto"
    : card.size === "small" && card.position === "right"
    ? "ml-auto"
    : ""

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={cn(
        widthClass,
        positionClass,
        isDragging && "opacity-30",
        "cursor-grab active:cursor-grabbing"
      )}
      {...attributes}
      {...listeners}
    >
      <CardRenderer card={card} isPreview />
    </div>
  )
}
```

**3. Create src/components/canvas/flow-grid.tsx:**
```typescript
"use client"

import { useState, useEffect } from "react"
import {
  DndContext,
  DragOverlay,
  closestCenter,
  PointerSensor,
  KeyboardSensor,
  useSensor,
  useSensors,
  DragStartEvent,
  DragEndEvent,
} from "@dnd-kit/core"
import {
  SortableContext,
  sortableKeyboardCoordinates,
} from "@dnd-kit/sortable"
import { cn } from "@/lib/utils"
import { CardRenderer } from "@/components/cards/card-renderer"
import { SortableFlowCard } from "./sortable-flow-card"
import { PositionDropZone } from "./position-drop-zone"
import type { Card, HorizontalPosition } from "@/types/card"

interface FlowGridProps {
  cards: Card[]
  onReorder: (oldIndex: number, newIndex: number) => void
  onPositionChange: (cardId: string, position: HorizontalPosition) => void
}

export function FlowGrid({ cards, onReorder, onPositionChange }: FlowGridProps) {
  const [activeCard, setActiveCard] = useState<Card | null>(null)
  const [mounted, setMounted] = useState(false)

  // Hydration guard: dnd-kit generates different IDs on server vs client
  useEffect(() => {
    setMounted(true)
  }, [])

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // Prevent accidental drags
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  )

  function handleDragStart(event: DragStartEvent) {
    const card = cards.find((c) => c.id === event.active.id)
    setActiveCard(card || null)
  }

  function handleDragEnd(event: DragEndEvent) {
    const { active, over } = event
    setActiveCard(null)

    if (!over) return

    const overId = over.id.toString()

    // Position drop (small cards only)
    if (overId.startsWith("position-")) {
      const draggedCard = cards.find((c) => c.id === active.id)
      if (draggedCard?.size === "small") {
        const position = overId.replace("position-", "") as HorizontalPosition
        onPositionChange(active.id.toString(), position)
      }
      return
    }

    // Reorder drop
    if (active.id !== over.id) {
      const oldIndex = cards.findIndex((c) => c.id === active.id)
      const newIndex = cards.findIndex((c) => c.id === over.id)
      if (oldIndex !== -1 && newIndex !== -1) {
        onReorder(oldIndex, newIndex)
      }
    }
  }

  // Show loading placeholder during SSR
  if (!mounted) {
    return (
      <div className="flex flex-wrap gap-4">
        {cards.map((card) => (
          <div
            key={card.id}
            className={cn(
              "h-24 bg-muted rounded-lg animate-pulse",
              card.size === "big" ? "w-full" : "w-[calc(50%-0.5rem)]"
            )}
          />
        ))}
      </div>
    )
  }

  // Empty state
  if (cards.length === 0) {
    return (
      <div className="flex items-center justify-center h-48 border-2 border-dashed rounded-lg text-muted-foreground">
        <p>No cards yet. Add your first card above.</p>
      </div>
    )
  }

  const isDraggingSmall = activeCard?.size === "small"

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
    >
      <SortableContext
        items={cards.map((c) => c.id)}
        strategy={() => null} // Disable auto-sorting for mixed sizes
      >
        <div className="relative">
          {/* Position drop zones overlay - shown only when dragging small card */}
          {isDraggingSmall && (
            <div className="absolute inset-0 flex gap-4 z-10 p-1">
              <PositionDropZone position="left" />
              <PositionDropZone position="center" />
              <PositionDropZone position="right" />
            </div>
          )}

          {/* Cards in flow layout */}
          <div className={cn(
            "flex flex-wrap gap-4",
            isDraggingSmall && "opacity-50"
          )}>
            {cards.map((card) => (
              <SortableFlowCard
                key={card.id}
                card={card}
                isDragging={activeCard?.id === card.id}
              />
            ))}
          </div>
        </div>
      </SortableContext>

      {/* Drag overlay - visual feedback following cursor */}
      <DragOverlay dropAnimation={{ duration: 200, easing: "ease" }}>
        {activeCard && (
          <div className={cn(
            "shadow-xl pointer-events-none",
            activeCard.size === "big" ? "w-80" : "w-40",
          )}>
            <CardRenderer card={activeCard} isPreview />
          </div>
        )}
      </DragOverlay>
    </DndContext>
  )
}
```

Key implementation notes:
- `strategy={() => null}` disables dnd-kit's auto-positioning for mixed-size items
- Position zones only appear when dragging a small card
- DragOverlay renders at fixed width for visual consistency
- Cards use CSS flexbox classes for width and position
- Hydration guard pattern from existing implementation
  </action>
  <verify>
All three files exist:
`ls src/components/canvas/flow-grid.tsx src/components/canvas/position-drop-zone.tsx src/components/canvas/sortable-flow-card.tsx`
TypeScript compiles: `npx tsc --noEmit` shows no errors.
`grep "flex flex-wrap" src/components/canvas/flow-grid.tsx` returns match.
`grep "useDroppable" src/components/canvas/position-drop-zone.tsx` returns match.
  </verify>
  <done>Flow layout components created: FlowGrid, PositionDropZone, SortableFlowCard.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Property editor hides size selector for Horizontal cards
3. FlowGrid uses CSS flexbox with wrap for layout
4. Position drop zones appear only when dragging small cards
5. DragOverlay provides visual feedback during drag
6. SortableFlowCard applies correct width classes based on size
</verification>

<success_criteria>
- Horizontal card in property editor shows no size option
- Hero/Square cards show Big/Small options in property editor
- FlowGrid component renders cards in flex-wrap layout
- Position drop zones highlight on hover during drag
- Small cards can be 50% width, Big cards are 100%
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-flow-layout/04.1-02-SUMMARY.md`
</output>
