# Phase 4.1: Flow Layout - Research

**Researched:** 2026-01-25
**Domain:** CSS flow layout, dnd-kit with variable-sized items, drop zone positioning
**Confidence:** HIGH

## Summary

Phase 4.1 extends the existing vertical stack layout to a flow-based grid where cards can be either Big (full width) or Small (half width, 2 per row). Small cards can be positioned left, center, or right within their row via drag-to-place. This builds on the existing dnd-kit implementation from Phase 3.

The recommended approach uses **CSS flexbox with wrap** for the flow layout (cards flow left-to-right, wrap down), **separate droppable zones** for position placement (using dnd-kit's `useDroppable`), and **DragOverlay** for smooth visual feedback during drag operations. The existing `position_x` column in the database can be repurposed to store horizontal position (0=left, 1=center, 2=right).

Key insight from CONTEXT.md: This is NOT a free-form 2D canvas. Cards follow a constrained flow: Big cards always take full width, Small cards take half width and can be positioned left/center/right within their row. The layout is predictable (CSS handles the flow), and dnd-kit handles reordering + position assignment.

**Primary recommendation:** Use CSS flexbox `flex-wrap: wrap` for the flow layout, dnd-kit `useDroppable` for position drop zones, and repurpose the existing `position_x` column for horizontal position storage.

## Standard Stack

The established libraries/tools for this domain:

### Core (Already Installed)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @dnd-kit/core | ^6.3.1 | Drag-and-drop core | Already in project, provides DndContext, useDroppable |
| @dnd-kit/sortable | ^10.0.0 | Sortable list preset | Already in project, useSortable for reordering |
| @dnd-kit/utilities | ^3.2.2 | Transform utilities | Already in project, CSS.Transform for animations |
| fractional-indexing | ^3.2.0 | Order persistence | Already in project, single-UPDATE reordering |
| Tailwind CSS | ^4 | Styling | Already in project, flexbox utilities |

### No New Dependencies Required

This phase uses only existing libraries. The key additions are:
- `useDroppable` hook from @dnd-kit/core (already available)
- `DragOverlay` component from @dnd-kit/core (already available)
- Tailwind flexbox utilities (already available)

**Installation:**
```bash
# No new packages needed - all dependencies already installed
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── components/
│   ├── canvas/
│   │   ├── sortable-card-list.tsx    # Updated: flow layout + drop zones
│   │   ├── sortable-card.tsx         # Updated: size-aware wrapper
│   │   ├── flow-grid.tsx             # NEW: flexbox container with drop zones
│   │   ├── position-drop-zone.tsx    # NEW: left/center/right droppable
│   │   └── card-drag-overlay.tsx     # NEW: visual overlay during drag
│   ├── cards/
│   │   ├── card-renderer.tsx         # Updated: size prop affects width
│   │   └── [existing cards]
│   └── editor/
│       └── card-property-editor.tsx  # Updated: Big/Small size selector
├── types/
│   └── card.ts                       # Updated: size type, position type
└── lib/
    └── ordering.ts                   # Updated: position calculation helpers
```

### Pattern 1: CSS Flexbox Flow Layout
**What:** Cards arranged using flexbox with wrap, Big cards take 100% width, Small cards take ~50%
**When to use:** Preview canvas rendering
**Example:**
```typescript
// Source: CSS-Tricks flexbox guide + MDN
// Flow container with wrap
<div className="flex flex-wrap gap-4">
  {cards.map((card) => (
    <div
      key={card.id}
      className={cn(
        // Big cards take full width, Small cards take half
        card.size === 'big' ? 'w-full' : 'w-[calc(50%-0.5rem)]',
        // Small cards with position
        card.size === 'small' && card.position === 'center' && 'mx-auto',
        card.size === 'small' && card.position === 'right' && 'ml-auto',
      )}
    >
      <CardRenderer card={card} />
    </div>
  ))}
</div>
```

### Pattern 2: Position Drop Zones with useDroppable
**What:** Three invisible drop zones (left/center/right) appear when dragging small cards
**When to use:** During drag operations in editor preview
**Example:**
```typescript
// Source: dnd-kit docs - useDroppable
import { useDroppable } from '@dnd-kit/core'

interface PositionDropZoneProps {
  position: 'left' | 'center' | 'right'
  rowIndex: number
  isActive: boolean // Show only when dragging a small card
}

export function PositionDropZone({ position, rowIndex, isActive }: PositionDropZoneProps) {
  const { setNodeRef, isOver } = useDroppable({
    id: `drop-${rowIndex}-${position}`,
    data: {
      type: 'position',
      position,
      rowIndex,
    },
  })

  if (!isActive) return null

  return (
    <div
      ref={setNodeRef}
      className={cn(
        'absolute inset-y-0 w-1/3 transition-colors',
        position === 'left' && 'left-0',
        position === 'center' && 'left-1/3',
        position === 'right' && 'left-2/3',
        isOver && 'bg-primary/20 border-2 border-dashed border-primary',
      )}
    />
  )
}
```

### Pattern 3: DragOverlay for Visual Feedback
**What:** Render a visual copy of the dragged card that follows the cursor
**When to use:** During any drag operation
**Example:**
```typescript
// Source: dnd-kit docs - DragOverlay
import { DragOverlay } from '@dnd-kit/core'

// Inside DndContext
<DragOverlay dropAnimation={{ duration: 200, easing: 'ease' }}>
  {activeCard ? (
    <div className={cn(
      'shadow-xl opacity-90',
      activeCard.size === 'big' ? 'w-full' : 'w-1/2',
    )}>
      <CardRenderer card={activeCard} isPreview />
    </div>
  ) : null}
</DragOverlay>
```

### Pattern 4: Size-Based Sorting Strategy
**What:** Use null strategy for complex layouts, handle reordering manually
**When to use:** When mixing different-sized items
**Example:**
```typescript
// Source: dnd-kit GitHub issue #720
// For variable-sized grids, use strategy={() => null} and handle layout yourself
<SortableContext
  items={cards.map((c) => c.id)}
  strategy={() => null} // Disable automatic transforms
>
  {/* Render cards with CSS flexbox handling layout */}
</SortableContext>

// In onDragEnd, calculate new position based on drop target
function handleDragEnd(event: DragEndEvent) {
  const { active, over } = event
  if (!over) return

  const overId = over.id.toString()

  // Check if dropped on a position zone
  if (overId.startsWith('drop-')) {
    const [, rowIndex, position] = overId.split('-')
    // Update card's horizontal position
    updateCard(active.id, { position })
  } else {
    // Standard reorder
    const oldIndex = cards.findIndex((c) => c.id === active.id)
    const newIndex = cards.findIndex((c) => c.id === over.id)
    if (oldIndex !== newIndex) {
      onReorder(oldIndex, newIndex)
    }
  }
}
```

### Pattern 5: Big/Small Size Toggle
**What:** Replace Small/Medium/Large with Big/Small per CONTEXT.md decisions
**When to use:** Card property editor
**Example:**
```typescript
// Updated type definition
export type CardSize = 'big' | 'small'

// Updated size config
export const CARD_SIZES = {
  big: {
    label: 'Big',
    width: 'w-full',        // Full width
    aspectRatio: 'aspect-square', // or aspect-video for hero
  },
  small: {
    label: 'Small',
    width: 'w-[calc(50%-0.5rem)]', // Half width minus gap
    aspectRatio: 'aspect-square',
  },
} as const

// Horizontal card is always big (no size option)
const CARD_TYPE_SIZES: Record<CardType, CardSize[] | null> = {
  hero: ['big', 'small'],
  square: ['big', 'small'],
  horizontal: null, // No sizing - always full width
}
```

### Pattern 6: Horizontal Position Storage
**What:** Repurpose existing position_x column for left/center/right
**When to use:** Database storage of small card positions
**Example:**
```typescript
// Position mapping
export type HorizontalPosition = 'left' | 'center' | 'right'

const POSITION_MAP: Record<HorizontalPosition, number> = {
  left: 0,
  center: 1,
  right: 2,
}

const POSITION_REVERSE: Record<number, HorizontalPosition> = {
  0: 'left',
  1: 'center',
  2: 'right',
}

// In card type
export interface Card {
  // ... existing fields
  size: CardSize
  position: HorizontalPosition // Maps to position_x in DB
}

// In database mapping
function mapDbToCard(row: Record<string, unknown>): Card {
  return {
    // ... existing fields
    size: (row.size as CardSize) || 'big',
    position: POSITION_REVERSE[row.position_x as number] || 'left',
  }
}
```

### Anti-Patterns to Avoid
- **CSS Grid for this use case:** Flexbox with wrap is simpler for flow layout with variable widths
- **Free-form positioning:** Per CONTEXT.md, only left/center/right positions are allowed
- **Auto-sorting strategies with mixed sizes:** dnd-kit's built-in strategies assume uniform sizes; use `strategy={() => null}` instead
- **Storing position as string in DB:** Use integer (position_x) for consistency with existing schema
- **Showing drop zones always:** Only show when dragging a small card; big cards have no position choice

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Flow layout | Custom JS position calculations | CSS flexbox with wrap | Browser handles wrapping, responsive by default |
| Drop zone detection | Manual pointer collision | dnd-kit useDroppable + isOver | Built-in collision detection, accessibility |
| Drag visual feedback | Clone node manually | DragOverlay component | Handles viewport positioning, drop animations |
| Reorder persistence | Integer positions | fractional-indexing (already used) | Single-UPDATE efficiency |
| Size-responsive width | JS window resize listeners | Tailwind responsive classes | CSS handles, no JS needed |

**Key insight:** The flow layout is primarily a CSS problem, not a JavaScript problem. dnd-kit handles the drag interactions, but CSS flexbox handles the actual layout. Don't try to calculate positions in JS.

## Common Pitfalls

### Pitfall 1: Using dnd-kit Sorting Strategies with Mixed Sizes
**What goes wrong:** Cards overlap, jump to wrong positions, or animate incorrectly
**Why it happens:** Built-in strategies (verticalListSortingStrategy, rectSortingStrategy) assume uniform item sizes
**How to avoid:** Use `strategy={() => null}` and let CSS flexbox handle layout; dnd-kit only handles drag detection
**Warning signs:** Cards visually overlap during drag, wrong drop targets detected

### Pitfall 2: Position Zones Interfering with Sortable
**What goes wrong:** Dropping on position zone also triggers reorder, or vice versa
**Why it happens:** Collision detection finds both sortable item AND position zone
**How to avoid:** Check `over.data.current.type` in onDragEnd to distinguish between 'sortable' and 'position' drops; handle each case separately
**Warning signs:** Card changes both order AND position on single drop

### Pitfall 3: Big Cards Showing Position Zones
**What goes wrong:** User sees left/center/right zones for big cards (which always span full width)
**Why it happens:** Position zones rendered unconditionally
**How to avoid:** Only render position zones when dragging a small card; use `onDragStart` to track what's being dragged
**Warning signs:** Visual clutter, confusing UX

### Pitfall 4: Mobile Touch Conflicts with Scroll
**What goes wrong:** User can't scroll the preview on mobile; every touch initiates drag
**Why it happens:** Drag sensors activate on any touch
**How to avoid:** Keep existing drag handle pattern with `touch-none`; position drop zones only respond to active drags, not new touch events
**Warning signs:** Page doesn't scroll on mobile preview

### Pitfall 5: Flexbox Gap Causing Width Miscalculation
**What goes wrong:** Two small cards don't fit side-by-side; one wraps to next row
**Why it happens:** `w-1/2` (50%) + gap causes total > 100%
**How to avoid:** Use `w-[calc(50%-0.5rem)]` or similar to account for gap; or use `gap-4` with `w-[calc(50%-0.5rem)]`
**Warning signs:** Small cards always wrap, never side-by-side

### Pitfall 6: Horizontal Card Getting Size Option
**What goes wrong:** User can set Horizontal card to Small, breaking its design
**Why it happens:** Size selector shown for all card types
**How to avoid:** Conditionally render size selector based on card_type; Horizontal cards are always full-width
**Warning signs:** Broken Horizontal card layouts

## Code Examples

Verified patterns from official sources:

### Complete Flow Grid Component
```typescript
// Source: dnd-kit docs + CSS-Tricks flexbox guide
"use client"

import { useState } from 'react'
import {
  DndContext,
  DragOverlay,
  closestCenter,
  PointerSensor,
  KeyboardSensor,
  useSensor,
  useSensors,
  DragStartEvent,
  DragEndEvent,
} from '@dnd-kit/core'
import {
  SortableContext,
  sortableKeyboardCoordinates,
} from '@dnd-kit/sortable'
import { cn } from '@/lib/utils'
import { CardRenderer } from '@/components/cards/card-renderer'
import { SortableFlowCard } from './sortable-flow-card'
import { PositionDropZone } from './position-drop-zone'
import type { Card, HorizontalPosition } from '@/types/card'

interface FlowGridProps {
  cards: Card[]
  onReorder: (oldIndex: number, newIndex: number) => void
  onPositionChange: (cardId: string, position: HorizontalPosition) => void
}

export function FlowGrid({ cards, onReorder, onPositionChange }: FlowGridProps) {
  const [activeCard, setActiveCard] = useState<Card | null>(null)
  const [mounted, setMounted] = useState(false)

  // Hydration guard
  useEffect(() => {
    setMounted(true)
  }, [])

  const sensors = useSensors(
    useSensor(PointerSensor, { activationConstraint: { distance: 8 } }),
    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
  )

  function handleDragStart(event: DragStartEvent) {
    const card = cards.find((c) => c.id === event.active.id)
    setActiveCard(card || null)
  }

  function handleDragEnd(event: DragEndEvent) {
    const { active, over } = event
    setActiveCard(null)

    if (!over) return

    const overId = over.id.toString()

    // Position drop (small cards only)
    if (overId.startsWith('position-') && activeCard?.size === 'small') {
      const position = overId.split('-')[1] as HorizontalPosition
      onPositionChange(active.id.toString(), position)
      return
    }

    // Reorder drop
    if (active.id !== over.id) {
      const oldIndex = cards.findIndex((c) => c.id === active.id)
      const newIndex = cards.findIndex((c) => c.id === over.id)
      if (oldIndex !== -1 && newIndex !== -1) {
        onReorder(oldIndex, newIndex)
      }
    }
  }

  if (!mounted) {
    return <div className="space-y-4">{/* Loading placeholder */}</div>
  }

  const isDraggingSmall = activeCard?.size === 'small'

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
    >
      <SortableContext items={cards.map((c) => c.id)} strategy={() => null}>
        <div className="relative flex flex-wrap gap-4">
          {/* Position drop zones (shown only when dragging small card) */}
          {isDraggingSmall && (
            <div className="absolute inset-0 flex pointer-events-auto z-10">
              <PositionDropZone position="left" />
              <PositionDropZone position="center" />
              <PositionDropZone position="right" />
            </div>
          )}

          {/* Cards */}
          {cards.map((card) => (
            <SortableFlowCard
              key={card.id}
              card={card}
              isDragging={activeCard?.id === card.id}
            />
          ))}
        </div>
      </SortableContext>

      <DragOverlay dropAnimation={{ duration: 200, easing: 'ease' }}>
        {activeCard && (
          <div className={cn(
            'shadow-xl',
            activeCard.size === 'big' ? 'w-full' : 'w-48',
          )}>
            <CardRenderer card={activeCard} isPreview />
          </div>
        )}
      </DragOverlay>
    </DndContext>
  )
}
```

### Position Drop Zone Component
```typescript
// Source: dnd-kit useDroppable docs
import { useDroppable } from '@dnd-kit/core'
import { cn } from '@/lib/utils'
import type { HorizontalPosition } from '@/types/card'

interface PositionDropZoneProps {
  position: HorizontalPosition
}

export function PositionDropZone({ position }: PositionDropZoneProps) {
  const { setNodeRef, isOver } = useDroppable({
    id: `position-${position}`,
    data: { type: 'position', position },
  })

  return (
    <div
      ref={setNodeRef}
      className={cn(
        'flex-1 flex items-center justify-center border-2 border-dashed transition-colors',
        isOver
          ? 'border-primary bg-primary/10'
          : 'border-muted-foreground/30 bg-transparent',
      )}
    >
      <span className={cn(
        'text-xs font-medium uppercase tracking-wide',
        isOver ? 'text-primary' : 'text-muted-foreground/50',
      )}>
        {position}
      </span>
    </div>
  )
}
```

### Updated Card Type Definition
```typescript
// src/types/card.ts
export type CardType = 'hero' | 'horizontal' | 'square' | 'video' | 'gallery' | 'dropdown' | 'game' | 'audio'

// Changed from small/medium/large to big/small per CONTEXT.md
export type CardSize = 'big' | 'small'

export type HorizontalPosition = 'left' | 'center' | 'right'

export interface Card {
  id: string
  page_id: string
  card_type: CardType
  title: string | null
  description: string | null
  url: string | null
  content: Record<string, unknown>
  size: CardSize
  position: HorizontalPosition  // NEW: horizontal position for small cards
  sortKey: string
  is_visible: boolean
  created_at: string
  updated_at: string
}

// Card size configuration
export const CARD_SIZES = {
  big: {
    label: 'Big',
    description: 'Full width',
  },
  small: {
    label: 'Small',
    description: 'Half width',
  },
} as const

// Which card types support sizing
export const CARD_TYPE_SIZING: Record<CardType, CardSize[] | null> = {
  hero: ['big', 'small'],
  square: ['big', 'small'],
  horizontal: null, // Always full width
  video: ['big', 'small'],
  gallery: ['big', 'small'],
  dropdown: null, // Always full width
  game: ['big', 'small'],
  audio: null, // Always full width
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| CSS Grid for variable layouts | Flexbox with wrap | N/A (both valid) | Flexbox simpler for 1D flow |
| dnd-kit sorting strategies for mixed sizes | strategy={() => null} + CSS layout | Documented in dnd-kit issues | Prevents overlap bugs |
| Manual drop zone collision | useDroppable with isOver | Built-in dnd-kit feature | Cleaner code, accessible |
| Clone element for drag overlay | DragOverlay component | dnd-kit best practice | Smooth animations, viewport-relative |

**Current best practice notes:**
- dnd-kit maintainer recommends disabling sorting strategy for complex layouts
- CSS flexbox handles responsive flow naturally
- DragOverlay should always be rendered (conditionally render children, not the component)

## Open Questions

Things that couldn't be fully resolved:

1. **Row calculation for drop zones**
   - What we know: Need to show position zones per-row
   - What's unclear: How to calculate which "row" a card is in with flexbox (depends on viewport width)
   - Recommendation: Show position zones as full-width overlay when dragging small card, not per-row; let CSS handle which row the card lands in based on its position in the array

2. **Center position with odd number of small cards**
   - What we know: Left/Right work cleanly; Center means "in the middle"
   - What's unclear: If row has 1 small card at center, it should center. If 2 small cards, both left+center, does center mean right-align of pair?
   - Recommendation: Center = `mx-auto`, which centers single items. Two small cards should use left+right, not left+center.

3. **Migration from small/medium/large to big/small**
   - What we know: Current DB has 'small', 'medium', 'large' values
   - What's unclear: How to map existing values
   - Recommendation: Map 'large' -> 'big', map 'small' and 'medium' -> 'small' (both become half-width)

## Sources

### Primary (HIGH confidence)
- [dnd-kit Documentation - Sortable](https://docs.dndkit.com/presets/sortable) - SortableContext, strategy options
- [dnd-kit Documentation - useDroppable](https://docs.dndkit.com/api-documentation/droppable/usedroppable) - Drop zone API
- [dnd-kit Documentation - DragOverlay](https://docs.dndkit.com/api-documentation/draggable/drag-overlay) - Visual feedback
- [dnd-kit Documentation - Collision Detection](https://docs.dndkit.com/api-documentation/context-provider/collision-detection-algorithms) - Algorithm options
- [CSS-Tricks Flexbox Guide](https://css-tricks.com/snippets/css/a-guide-to-flexbox/) - flex-wrap, gap, justify-content
- [MDN Flexbox Wrapping](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout/Mastering_wrapping_of_flex_items) - Wrap behavior

### Secondary (MEDIUM confidence)
- [dnd-kit GitHub Issue #720](https://github.com/clauderic/dnd-kit/issues/720) - Variable-sized grid items workaround
- [Phase 3 RESEARCH.md](/Users/julianmunyard/LinkLobby/.planning/phases/03-canvas-system/03-RESEARCH.md) - Existing dnd-kit patterns

### Tertiary (LOW confidence)
- WebSearch results for "dnd-kit grid layout variable size items" - Confirms strategy={() => null} pattern

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - No new dependencies, using existing dnd-kit patterns
- Architecture: HIGH - CSS flexbox is well-documented, dnd-kit patterns verified from official docs
- Pitfalls: HIGH - Common issues documented in dnd-kit GitHub issues
- Position drop zones: MEDIUM - Pattern derived from useDroppable docs, not exact use case example

**Research date:** 2026-01-25
**Valid until:** 2026-02-25 (30 days - stable domain, no breaking changes expected)
