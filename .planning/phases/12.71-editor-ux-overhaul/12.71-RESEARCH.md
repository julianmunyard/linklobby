# Phase 12.71: Editor UX Overhaul - Research

**Researched:** 2026-02-26
**Domain:** React editor direct manipulation, contentEditable, floating toolbars, image upload UX, postMessage iframe communication
**Confidence:** HIGH (codebase is primary source; no external library additions needed for most features)

---

## Summary

This phase is a UX transformation of the existing split-screen editor. All features build on the already-working architecture: a parent editor page communicates with a `/preview` iframe via `postMessage`. The preview iframe posts `SELECT_CARD` / `OPEN_DESIGN_TAB` messages to the parent; the parent posts `STATE_UPDATE` messages to the preview. This bidirectional channel is the foundation for every direct-manipulation feature.

The biggest technical work is: (1) making profile header elements in the preview iframe clickable to navigate the editor panel, (2) implementing contentEditable inline editing for title, bio, and text cards with store sync, (3) building a floating quick-action toolbar that appears inside the iframe when a card is selected, and (4) cleaning up the card creation dropdown. Everything else (font picker in header, text line breaks, label renames, gallery fixes) is straightforward field or rendering work.

**No new dependencies are required.** The project already has `react-easy-crop`, `@use-gesture/react`, `browser-image-compression`, `motion`, `@dnd-kit/*`, and `@floating-ui/react` is NOT installed but `@radix-ui/react-popover` is available and can serve the floating toolbar. The postMessage channel already handles `SELECT_CARD`, `OPEN_DESIGN_TAB`, `REORDER_CARDS`, and scatter position updates — new message types follow the same pattern.

**Primary recommendation:** Implement all direct-manipulation features by extending the existing postMessage protocol, never by adding new state layers. Keep the iframe as the manipulation surface; keep the editor panel as the settings surface.

---

## Standard Stack

All features use the existing project stack. No new library additions needed.

### Core (already installed)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `zustand` | ^5.0.10 | Global state (page, profile, theme stores) | Already the project state layer |
| `react-hook-form` | ^7.71.1 | Form state in `CardPropertyEditor` | Already used for all card forms |
| `@radix-ui/react-popover` | ^1.1.15 | Floating toolbar anchor | Already installed, zero-bundle-overhead vs. floating-ui |
| `browser-image-compression` | ^2.0.2 | Client-side photo compression | Already installed and used in `image-compression.ts` |
| `react-easy-crop` | ^5.5.6 | Photo crop dialog | Already installed and used in `ImageCropDialog` |
| `@use-gesture/react` | ^10.3.1 | Pinch/drag gesture handling | Already used in `PreviewPanel` |
| `motion` | ^12.29.3 | Transition animations | Already used in `FeaturedThemesTab` |
| `lucide-react` | ^0.562.0 | Icons (Crop icon for photo crop) | Already installed |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Radix Popover for floating toolbar | `@floating-ui/react` | Floating UI gives more positioning control but requires new install; Radix Popover is already present and sufficient for a small button bar |
| Custom contentEditable | `react-contenteditable` npm package | The npm package wraps the same browser API; using raw contentEditable directly is simpler and avoids the innerHTML-vs-innerText pitfall that the library also has |

**Installation:** No new packages needed.

---

## Architecture Patterns

### Recommended Project Structure

No structural changes to folders are needed. New components slot into existing locations:

```
src/
├── components/
│   ├── editor/
│   │   ├── floating-card-toolbar.tsx      # NEW: floating quick-action bar (rendered inside iframe)
│   │   ├── cards-tab.tsx                  # MODIFY: rename "Add Card" → "Add Link", filter dropdown
│   │   ├── header-section.tsx             # MODIFY: add font picker subsection
│   │   ├── design-panel.tsx               # MODIFY: rename Header tab label
│   ├── preview/
│   │   ├── profile-header.tsx             # MODIFY: add click handlers for inline edit + OPEN_DESIGN_TAB
│   │   ├── inline-editable.tsx            # NEW: controlled contentEditable wrapper component
│   ├── cards/
│   │   ├── text-card.tsx                  # MODIFY: support \n → <br> rendering
│   │   ├── link-card.tsx                  # MODIFY: support \n in description
```

### Pattern 1: postMessage-Driven Panel Navigation (click-to-edit)

**What:** Preview iframe element is clicked → iframe posts a typed message → parent `PreviewPanel` handles it → parent dispatches a custom event → `EditorLayout` catches it and opens the correct tab.

**When to use:** Any time the preview should drive the editor panel (click header → jump to Header tab, click background → open Design tab).

**Existing implementation to follow:**
```typescript
// Source: src/app/preview/page.tsx:486 — ArtifactLayout header click
window.parent.postMessage(
  { type: 'OPEN_DESIGN_TAB', payload: { tab: 'style' } },
  window.location.origin
)

// Source: src/components/editor/preview-panel.tsx:193 — handler in parent
case "OPEN_DESIGN_TAB": {
  const openStyleEvent = new CustomEvent('open-design-tab', { detail: { tab: event.data.payload?.tab || 'style' } })
  window.dispatchEvent(openStyleEvent)
  break
}

// Source: src/components/editor/editor-layout.tsx:62 — listener in layout
window.addEventListener('open-design-tab', handler)
```

**New message type needed for header click:**
```typescript
// In preview/profile-header.tsx — click on display name or bio area
window.parent.postMessage(
  { type: 'OPEN_DESIGN_TAB', payload: { tab: 'header' } },
  window.location.origin
)
```

The `OPEN_DESIGN_TAB` message type already works. For "click header → jump to header editing", reuse it with `{ tab: 'header' }`. The Design panel already has a 'header' tab entry in its `TABS` array.

### Pattern 2: contentEditable Inline Title/Bio/Text Editing

**What:** A user clicks on display name, bio, or text card text in the preview. The element becomes `contentEditable`. On blur or Enter, the value is committed to the profile store or page store.

**Critical implementation rules:**
- Use `suppressContentEditableWarning` to silence React warning
- Read value via `element.innerText` (not `innerHTML`) to avoid XSS and formatting leakage
- On `keydown`, intercept Enter key: `preventDefault()` then either blur (for single-line) or insert `\n` for multiline
- Do NOT use `onInput` → `setState` in tight loop — commit only on blur
- Store ref for the element; compare to avoid no-op commits

```typescript
// Source: verified pattern from MDN + React 19 docs — contentEditable with ref
// In preview/inline-editable.tsx (NEW component)
"use client"

interface InlineEditableProps {
  value: string
  onCommit: (value: string) => void
  multiline?: boolean
  className?: string
  placeholder?: string
}

export function InlineEditable({ value, onCommit, multiline = false, className, placeholder }: InlineEditableProps) {
  const ref = useRef<HTMLSpanElement>(null)

  // Sync external value to DOM only when not focused
  useEffect(() => {
    if (ref.current && document.activeElement !== ref.current) {
      ref.current.innerText = value || ''
    }
  }, [value])

  const handleBlur = () => {
    const text = ref.current?.innerText ?? ''
    onCommit(text)
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      if (!multiline) {
        e.preventDefault()
        ref.current?.blur()
      }
      // multiline: allow default \n insertion
    }
    if (e.key === 'Escape') {
      if (ref.current) ref.current.innerText = value || ''
      ref.current?.blur()
    }
  }

  return (
    <span
      ref={ref}
      contentEditable
      suppressContentEditableWarning
      onBlur={handleBlur}
      onKeyDown={handleKeyDown}
      className={className}
      data-placeholder={placeholder}
    />
  )
}
```

**Wire-up:** `InlineEditable` goes inside `profile-header.tsx` (preview iframe). On commit, post to parent:
```typescript
window.parent.postMessage(
  { type: 'UPDATE_PROFILE', payload: { field: 'displayName', value: text } },
  window.location.origin
)
```
Parent handler updates `useProfileStore`. This is a new message type following the existing `REORDER_CARDS` / `MOVE_CARDS` pattern.

For **text card inline editing**, the same approach applies but posts `UPDATE_CARD` with `{ cardId, title: text }`.

### Pattern 3: Floating Quick-Action Toolbar Inside Iframe

**What:** When a card is selected (`selectedCardId` set in preview state), a toolbar floats near the card with Delete, Duplicate, and Crop (for photo cards) buttons.

**Where to implement:** Inside the preview iframe (`/preview/page.tsx` or individual card wrappers in `SelectableFlowGrid`). The toolbar posts actions back to the parent via postMessage.

**Implementation approach:** Use the existing `selectedCardId` in preview state. The `SelectableFlowGrid` already wraps cards and knows which is selected. Add a `FloatingCardToolbar` component that renders absolutely positioned near the selected card's bounding box.

```typescript
// Source: existing pattern from src/app/preview/page.tsx:78
// New message types for floating toolbar actions
window.parent.postMessage({ type: 'DELETE_CARD', payload: { cardId } }, window.location.origin)
window.parent.postMessage({ type: 'DUPLICATE_CARD', payload: { cardId } }, window.location.origin)
```

Parent `PreviewPanel` already handles `SELECT_CARD`, `REORDER_CARDS` — add `DELETE_CARD` and `DUPLICATE_CARD` cases to its switch statement.

**Positioning:** Position the toolbar absolutely relative to the card container. Use `top: -40px` offset above the card. No external library needed — the toolbar can be a `position: absolute` element inside the card wrapper, shown when `isSelected`.

For scatter mode cards, the toolbar position must follow the card's scatter x/y position.

### Pattern 4: Text Line Breaks

**What:** Pressing Enter in the title or description textarea should produce visible `<br>` on the public page.

**Current gap:** `TextCard` and `link-card` render `card.title` and `card.description` with `{card.title}` — React renders this as plain text, stripping newlines.

**Fix:** Replace raw text rendering with a `renderWithLineBreaks` function:
```typescript
// Simple, no library needed
function renderWithLineBreaks(text: string) {
  return text.split('\n').map((line, i, arr) => (
    <span key={i}>
      {line}
      {i < arr.length - 1 && <br />}
    </span>
  ))
}
```

Apply in `text-card.tsx` and `link-card.tsx` for both `card.title` and `card.description`.

**The textarea side** (in `CardPropertyEditor`): React `<Textarea>` already handles Enter → `\n` in the value. Ensure the `description` form field uses `\n` (it does — `Textarea` preserves newlines). No change needed on the editor side.

### Pattern 5: Image Upload — Compression Already Exists

**What:** Large photo uploads (iPhone cameras send 12MB+ images) should be auto-compressed.

**Current state:** `compressImageForUpload` from `src/lib/image-compression.ts` (using `browser-image-compression@^2.0.2`) is ALREADY called in:
- `src/components/cards/image-upload.tsx` (card image uploads)
- `src/components/editor/gallery-card-fields.tsx` (gallery)
- `src/components/editor/audio-card-fields.tsx` (audio artwork)

**The gap:** The profile image uploads in `header-section.tsx` and `design-panel.tsx` do NOT call `compressImageForUpload` before uploading. They call `uploadProfileImage` directly after crop. Adding compression there is the fix.

**For the duplicate photo bug in gallery:** The gallery `handleFileSelect` creates IDs with `generateId()` — if the same file is selected twice in rapid succession, the `e.target.value = ''` reset at the bottom of `handleFileSelect` is already present but the reset happens AFTER the async upload. Check that `fileInputRef.current.value = ''` is reset synchronously at the start of the handler, not at the end.

**For gallery silent failure on click-away:** The `setIsUploading(true)` / `setIsUploading(false)` block does not have an AbortController or any cancellation guard. If the dialog/component unmounts during upload, the state update fires on an unmounted component. Fix: add an `isMounted` ref guard pattern or `AbortController` on the upload fetch.

### Pattern 6: Card Creation Dropdown Simplification

**What:** Remove visual variants (Hero Card, Square Card, Horizontal Link, Mini Link, Text) from the "Add Card" dropdown. These are display formats, not content types.

**Where:** `src/components/editor/cards-tab.tsx` — the `CARD_TYPES` array at line 26. Remove the types that are visual variants:
```typescript
// REMOVE from CARD_TYPES:
{ type: "mini", label: "Mini Link" },
{ type: "horizontal", label: "Horizontal Link" },
{ type: "hero", label: "Hero Card" },
{ type: "square", label: "Square Card" },
{ type: "text", label: "Text" },
```

**Important:** These card types must remain creatable through CardTypePicker in the property editor (the type switcher inside card editing). The dropdown only changes what's in the "Add Link/Card" dropdown.

**Rename "Add Card" → "Add Link":** Change the `DropdownMenuTrigger` button label text in `cards-tab.tsx` from `"Add Card"` to `"Add Link"`.

**"Text" standalone blocks in Design tab:** Adding a "Text" section to Design tab means a special-purpose shortcut for creating `text` type cards without showing them in the main dropdown. This can be a button in the Design panel that calls `handleAddCard("text")`.

### Pattern 7: Featured Tab — Theme Templates First

**What:** Clicking a featured theme should show its templates rather than immediately applying it. The `handleNavigateToTheme` function already exists in `editor-panel.tsx` (line 226). Currently it's called from within the panel navigation. The Featured tab needs to call this instead of directly applying the theme.

**Where:** `src/components/editor/featured-themes-tab.tsx` — currently calls `applyTemplate()` on click. Change it to call `onNavigateToTheme(themeId)` to show templates for that theme first.

**The `onNavigateToTheme` prop** already flows into `FeaturedThemesTab` from `EditorPanel`. Verify the `FeaturedThemesTab` component receives and uses it.

### Anti-Patterns to Avoid

- **Inline editing via controlled React state on contentEditable:** React's virtual DOM and contentEditable fight. Use uncontrolled (ref-based) approach, commit on blur only. Never set state on `onInput` for contentEditable.
- **New global state for "inline editing mode":** Don't add a Zustand slice for tracking "is the title being edited." Keep it local to the component with a `[isEditing, setIsEditing]` useState.
- **Floating toolbar inside parent editor panel for in-preview actions:** The toolbar must live in the iframe, not the parent. The parent panel only receives the action after the postMessage arrives. Doing it in the parent creates a coordinate mismatch.
- **Posting every keystroke from inline editing to parent:** Too many postMessages cause performance issues. Commit only on blur or explicit save.
- **Forgetting to handle the preview iframe's lack of Radix context:** The preview iframe (`/preview`) is a separate React root. Any floating UI that uses shadcn/ui Radix components must be imported in the preview route — or the toolbar must be pure CSS/React without Radix.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Image compression on upload | Custom canvas resize logic | `browser-image-compression` (already installed) | Already handles EXIF rotation, WebWorker, progressive JPEG, format preservation |
| Photo crop dialog | Custom crop UI | `react-easy-crop` via existing `ImageCropDialog` component | Already used for avatar/logo, same API works for card photo crop |
| Drag-reorder in gallery | Custom DnD | `@dnd-kit/sortable` (already used in gallery-card-fields) | Already implemented, just needs the crop-first UX refinement |
| Text splitting for line breaks | Regex replace + dangerouslySetInnerHTML | `text.split('\n').map(...)` JSX pattern | Avoids XSS, works with React rendering |
| Floating toolbar positioning | Manual coordinate math | `position: absolute` on card wrapper with offset | Cards are already positioned elements; absolute positioning relative to parent works cleanly |

**Key insight:** This phase is almost entirely UX wiring of existing infrastructure, not new infrastructure. The postMessage channel, stores, compression library, and crop dialog are all in place.

---

## Common Pitfalls

### Pitfall 1: contentEditable + React State Loop

**What goes wrong:** Developer adds `value={displayName}` and `onInput` handler to a contentEditable span. Every keystroke calls `setDisplayName()` which triggers a re-render which resets cursor position.

**Why it happens:** React's reconciler updates the DOM text content, which the browser treats as a cursor reset.

**How to avoid:** Use `useRef` to control the element directly. Only sync the prop value into `ref.current.innerText` when the element is NOT focused. Commit (post to store) only on `onBlur`.

**Warning signs:** Typing in the element resets cursor to position 0 after each character.

### Pitfall 2: postMessage Race Condition on Commit

**What goes wrong:** User types in inline edit, then immediately clicks a card. Blur fires → `UPDATE_PROFILE` postMessage → parent updates profile store → store update triggers `STATE_UPDATE` to iframe → iframe re-renders with new profile data, which causes a second `innerText` sync that wipes what was typed.

**Why it happens:** The `sendToPreview` subscription in `PreviewPanel` fires synchronously on any store change. The profile store update from the inline edit commitment triggers it immediately.

**How to avoid:** The `InlineEditable` component's `useEffect` that syncs `value` to `innerText` must only fire when the element is NOT focused (`document.activeElement !== ref.current`). That guard is already shown in the code example in Pattern 2.

**Warning signs:** Typed text disappears after clicking away.

### Pitfall 3: Floating Toolbar Inside Iframe Uses Radix Without Context

**What goes wrong:** Developer imports `<Button>` or `<DropdownMenu>` from shadcn into the floating toolbar, and the preview iframe (`/preview/page.tsx`) doesn't have the necessary Radix providers.

**Why it happens:** Preview page is a separate React root. Some Radix primitives need `TooltipProvider` etc. from the app shell.

**How to avoid:** The floating toolbar inside the iframe should use plain HTML/Tailwind buttons, not shadcn/Radix components. Or verify that the required providers are present in `/preview/layout.tsx`.

**Warning signs:** Tooltip/popover errors in browser console from preview iframe.

### Pitfall 4: Gallery Upload Fires State on Unmounted Component

**What goes wrong:** User starts photo upload in gallery, navigates away from the card editor mid-upload. `setIsUploading(false)` and `onChange(...)` fire on the unmounted component.

**Why it happens:** The `handleFileSelect` async function has no cancellation guard.

**How to avoid:** Add a mounted ref at the top of `GalleryCardFields`:
```typescript
const isMountedRef = useRef(true)
useEffect(() => () => { isMountedRef.current = false }, [])
// Then guard: if (!isMountedRef.current) return
```

**Warning signs:** React console warning "Can't perform a React state update on an unmounted component."

### Pitfall 5: Inline Editing in Preview Causes Deselect

**What goes wrong:** User double-clicks a title in the preview to edit. While typing, they click outside the iframe (on the editor panel background). The parent's `handleDeselect()` fires, which saves and deselects — aborting the inline edit mid-type.

**Why it happens:** The desktop `PreviewPanel` has `onClick={handleDeselect}` on the container. The iframe border click target is on the container div.

**How to avoid:** When inline editing is active, suppress the `handleDeselect` behavior. Send a `INLINE_EDIT_ACTIVE` message from the iframe to the parent when editing starts, and `INLINE_EDIT_DONE` when it ends. Parent suspends deselect logic during that window.

**Warning signs:** Text edit aborts when user moves mouse to editor panel.

### Pitfall 6: "Add Link" Rename Breaks Mac/Phone-Home Themes

**What goes wrong:** Renaming the button from "Add Card" to "Add Link" looks wrong on Macintosh theme (adds Mac windows) or Phone Home theme (adds app icons, not links).

**Why it happens:** The button label is shared across themes, but the content of the dropdown changes per-theme.

**How to avoid:** The label should be conditionally "Add Card" for Mac/Phone Home themes and "Add Link" for all others. Or keep "Add" as a minimal neutral label.

**Warning signs:** Button label doesn't match the thing it creates.

---

## Code Examples

### Existing postMessage Pattern (HIGH confidence — verified in codebase)

```typescript
// Source: src/app/preview/page.tsx:78-85 — SELECT_CARD from preview to parent
const handleCardClick = useCallback((cardId: string) => {
  if (window.parent !== window) {
    window.parent.postMessage(
      { type: "SELECT_CARD", payload: { cardId } },
      window.location.origin
    )
  }
}, [])

// Source: src/app/preview/page.tsx:486 — OPEN_DESIGN_TAB from preview to parent
window.parent.postMessage(
  { type: 'OPEN_DESIGN_TAB', payload: { tab: 'style' } },
  window.location.origin
)
```

### Opening Header Tab via Existing Message Type

```typescript
// Add to profile-header.tsx — no new message type needed
const handleHeaderClick = () => {
  if (window.parent !== window) {
    window.parent.postMessage(
      { type: 'OPEN_DESIGN_TAB', payload: { tab: 'header' } },
      window.location.origin
    )
  }
}
```

### Text Line Breaks Rendering

```typescript
// Source: standard React pattern — no library
function renderWithLineBreaks(text: string) {
  const lines = text.split('\n')
  return lines.map((line, i) => (
    <span key={i}>
      {line}
      {i < lines.length - 1 && <br />}
    </span>
  ))
}

// In text-card.tsx, replace:
// {card.title || "Text"}
// with:
// {renderWithLineBreaks(card.title || "Text")}
```

### Compression Guard for Profile Image Upload

```typescript
// Source: pattern from src/lib/image-compression.ts — already used in gallery/audio
// Add to handleCropComplete in header-section.tsx and design-panel.tsx
import { compressImageForUpload } from "@/lib/image-compression"

const handleCropComplete = async (croppedBlob: Blob) => {
  setIsUploading(true)
  try {
    // Compress before upload (same as other image uploads in the project)
    const compressedBlob = await compressImageForUpload(croppedBlob as File)
    const result = await uploadProfileImage(compressedBlob, user.id, imageType)
    // ...
  }
}
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Panel-only editing | Canvas-driven with postMessage select | Phase 12.7 | Foundation for this phase |
| Manual iframe tap forwarding | `forwardTap` + `elementFromPoint` | Phase 12.7 | Enables click-to-select in iframe |
| ArtifactLayout only uses OPEN_DESIGN_TAB | Now other themes need it too | Phase 12.71 | Extend existing message type |

**Deprecated/outdated:**
- Opening `OPEN_DESIGN_TAB` only from ArtifactLayout: Other theme headers and background clicks need the same capability.

---

## Open Questions

1. **Floating toolbar on mobile vs. desktop**
   - What we know: Desktop has pointer events on iframe directly; mobile uses `forwardTap` postMessage
   - What's unclear: Whether the floating toolbar should be desktop-only or also shown on mobile (where screen space is tighter)
   - Recommendation: Desktop-only for the floating toolbar in this phase; mobile already has `MobileCardTypeDrawer` for quick actions

2. **"Freeform structured mode" (item 21)**
   - What we know: Scatter mode exists with `scatterMode` flag; `ScatterCanvas` handles free positioning
   - What's unclear: What "grid-snap without chaos" means in the scatter renderer — requires a separate snap-to-grid algorithm in the scatter canvas
   - Recommendation: Defer to a sub-phase or treat as a separate investigation; this is the most open-ended item technically

3. **Inline editing cross-iframe sync latency**
   - What we know: Every store change triggers `sendToPreview()` which sends full `STATE_UPDATE`
   - What's unclear: Whether rapid inline editing (very fast typing) creates noticeable latency due to iframe postMessage overhead
   - Recommendation: Commit on blur only (not on every keystroke) — this eliminates the latency issue entirely for inline editing

4. **"Create Your Own" blank canvas in Featured tab**
   - What we know: `FeaturedThemesTab` shows template cards from `FEATURED_IDS`
   - What's unclear: UX for a "blank canvas" — does it reset all cards? Just deselect template? Show an empty canvas with a plus button?
   - Recommendation: Implement as a special list item at the end of Featured that clears all template content but keeps current theme, opens the Links tab

---

## Sources

### Primary (HIGH confidence — directly verified in codebase)
- `src/components/editor/editor-layout.tsx` — postMessage handler chain, OPEN_DESIGN_TAB
- `src/components/editor/preview-panel.tsx` — message switch statement, all existing message types
- `src/app/preview/page.tsx` — SELECT_CARD, OPEN_DESIGN_TAB send patterns
- `src/components/editor/cards-tab.tsx` — CARD_TYPES array, Add Card button
- `src/components/editor/card-property-editor.tsx` — CardTypePicker, form structure
- `src/components/editor/design-panel.tsx` — TABS array including 'header', tab navigation
- `src/components/editor/header-section.tsx` — HeaderSection component structure
- `src/components/preview/profile-header.tsx` — render functions for title/bio/avatar
- `src/components/cards/text-card.tsx` — title/description rendering without line break support
- `src/lib/image-compression.ts` — existing `compressImageForUpload`
- `src/components/editor/gallery-card-fields.tsx` — upload pattern, file input, compression usage
- `package.json` — confirmed installed: react-easy-crop, browser-image-compression, @use-gesture/react, motion, @radix-ui/react-popover
- `src/components/cards/word-art-layout.tsx` — existing pattern for clickable header element in preview

### Secondary (MEDIUM confidence — verified with official MDN patterns)
- contentEditable + React uncontrolled pattern: MDN Web Docs (standard browser API, React 19 compatible)
- `browser-image-compression` API: consistent with installed version ^2.0.2 (used in 4 files in codebase)

### Tertiary (LOW confidence — WebSearch, not verified with official docs)
- React Transitions for editor update debouncing: December 2025 article from handlewithcare.dev — not needed for this phase (commit-on-blur sidesteps this entirely)

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — all libraries verified as installed in package.json
- Architecture: HIGH — all patterns verified by reading existing implementations in the codebase
- Pitfalls: HIGH for iframe/postMessage pitfalls (verified from codebase patterns); MEDIUM for contentEditable cursor reset (standard browser behavior, confirmed in MDN and react-contenteditable GitHub issues)

**Research date:** 2026-02-26
**Valid until:** 2026-03-28 (stable architecture, no fast-moving dependencies involved)
