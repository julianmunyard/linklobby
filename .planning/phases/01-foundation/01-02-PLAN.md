---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/schema.sql
autonomous: false
user_setup:
  - service: supabase
    why: "Database and authentication"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: NEXT_PUBLIC_SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> anon public key"
    dashboard_config:
      - task: "Create new Supabase project (if not exists)"
        location: "https://supabase.com/dashboard -> New Project"
      - task: "Disable email confirmation for faster dev"
        location: "Authentication -> Providers -> Email -> Toggle off 'Confirm email'"

must_haves:
  truths:
    - "Profiles table exists with username unique constraint"
    - "Pages table exists with user_id foreign key"
    - "Cards table exists with page_id foreign key"
    - "RLS is enabled on all tables"
    - "Trigger auto-creates profile when user signs up"
    - "Trigger auto-creates page when profile is created"
  artifacts:
    - path: "supabase/schema.sql"
      provides: "Complete database schema"
      contains: "CREATE TABLE public.profiles"
    - path: "supabase/schema.sql"
      provides: "RLS policies"
      contains: "ENABLE ROW LEVEL SECURITY"
    - path: "supabase/schema.sql"
      provides: "User signup trigger"
      contains: "handle_new_user"
  key_links:
    - from: "profiles.id"
      to: "auth.users.id"
      via: "foreign key"
      pattern: "REFERENCES auth.users"
    - from: "pages.user_id"
      to: "auth.users.id"
      via: "foreign key"
      pattern: "REFERENCES auth.users"
    - from: "cards.page_id"
      to: "pages.id"
      via: "foreign key"
      pattern: "REFERENCES public.pages"
---

<objective>
Create the complete database schema with profiles, pages, and cards tables, including RLS policies and auto-creation triggers.

Purpose: Establish the data model that supports username claiming, page ownership, and card storage.
Output: SQL schema file and executed schema in Supabase project.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database schema SQL file</name>
  <files>
    - supabase/schema.sql
  </files>
  <action>
Create directory and schema file:

```bash
mkdir -p /Users/julianmunyard/LinkLobby/supabase
```

Create `supabase/schema.sql` with the complete schema:

```sql
-- LinkLobby Database Schema
-- Run in Supabase SQL Editor (Dashboard -> SQL Editor -> New Query)
--
-- Tables: profiles, pages, cards
-- Features: RLS policies, auto-creation triggers, username uniqueness
--
-- WARNING: This schema assumes a fresh Supabase project.
-- If tables already exist, you may need to drop them first.

-- ============================================
-- PROFILES TABLE
-- Extends auth.users with username and display info
-- ============================================

CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT UNIQUE NOT NULL,
  display_name TEXT,
  avatar_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies: Anyone can read profiles (for public pages), users can update own
CREATE POLICY "Public profiles are viewable by everyone"
  ON public.profiles FOR SELECT
  USING (true);

CREATE POLICY "Users can update own profile"
  ON public.profiles FOR UPDATE
  USING (auth.uid() = id);

CREATE POLICY "Users can insert own profile"
  ON public.profiles FOR INSERT
  WITH CHECK (auth.uid() = id);

-- Index for username lookups (public page routing)
CREATE INDEX IF NOT EXISTS idx_profiles_username ON public.profiles(username);

-- ============================================
-- PAGES TABLE
-- One page per user, stores theme and layout settings
-- ============================================

CREATE TABLE IF NOT EXISTS public.pages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT NOT NULL REFERENCES public.profiles(username) ON UPDATE CASCADE,
  theme_id TEXT NOT NULL DEFAULT 'sleek',
  background_type TEXT DEFAULT 'color',
  background_value TEXT DEFAULT '#0a0a0a',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT one_page_per_user UNIQUE (user_id)
);

-- Enable RLS
ALTER TABLE public.pages ENABLE ROW LEVEL SECURITY;

-- Policies: Anyone can read pages (for public viewing), users manage own
CREATE POLICY "Public pages are viewable by everyone"
  ON public.pages FOR SELECT
  USING (true);

CREATE POLICY "Users can manage own page"
  ON public.pages FOR ALL
  USING (auth.uid() = user_id);

-- Index for username lookups (public page routing)
CREATE INDEX IF NOT EXISTS idx_pages_username ON public.pages(username);

-- ============================================
-- CARDS TABLE
-- Belongs to pages, stores card type, content, position
-- ============================================

CREATE TABLE IF NOT EXISTS public.cards (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  page_id UUID NOT NULL REFERENCES public.pages(id) ON DELETE CASCADE,
  card_type TEXT NOT NULL, -- 'hero', 'horizontal', 'square', 'video', 'gallery', 'dropdown', 'game', 'audio'
  title TEXT,
  description TEXT,
  url TEXT,
  content JSONB DEFAULT '{}', -- Flexible content storage per card type
  position_x INTEGER DEFAULT 0,
  position_y INTEGER DEFAULT 0,
  width INTEGER DEFAULT 1,
  height INTEGER DEFAULT 1,
  z_index INTEGER DEFAULT 0,
  is_visible BOOLEAN DEFAULT TRUE,
  sort_order INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE public.cards ENABLE ROW LEVEL SECURITY;

-- Policies: Anyone can read cards (for public pages), users manage own via page ownership
CREATE POLICY "Cards are viewable by everyone"
  ON public.cards FOR SELECT
  USING (true);

CREATE POLICY "Users can manage own cards"
  ON public.cards FOR ALL
  USING (
    page_id IN (SELECT id FROM public.pages WHERE user_id = auth.uid())
  );

-- Indexes for common queries
CREATE INDEX IF NOT EXISTS idx_cards_page_id ON public.cards(page_id);
CREATE INDEX IF NOT EXISTS idx_cards_sort_order ON public.cards(page_id, sort_order);

-- ============================================
-- TRIGGERS: Auto-create profile and page on signup
-- ============================================

-- Trigger: Auto-create profile when user signs up
-- Reads username from user metadata passed during signUp()
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.profiles (id, username)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'username'
  );
  RETURN NEW;
END;
$$;

-- Drop existing trigger if exists (for idempotency)
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Trigger: Auto-create page when profile is created
CREATE OR REPLACE FUNCTION public.handle_new_profile()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.pages (user_id, username)
  VALUES (NEW.id, NEW.username);
  RETURN NEW;
END;
$$;

-- Drop existing trigger if exists (for idempotency)
DROP TRIGGER IF EXISTS on_profile_created ON public.profiles;

CREATE TRIGGER on_profile_created
  AFTER INSERT ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_profile();

-- ============================================
-- HELPER FUNCTIONS
-- ============================================

-- Function: Check username availability (for client-side UX)
CREATE OR REPLACE FUNCTION public.check_username_available(desired_username TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN NOT EXISTS (
    SELECT 1 FROM public.profiles
    WHERE username = LOWER(desired_username)
  );
END;
$$;

-- Function: Update username (handles cascading to pages)
CREATE OR REPLACE FUNCTION public.update_username(new_username TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  current_user_id UUID;
BEGIN
  current_user_id := auth.uid();

  IF current_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Check availability
  IF EXISTS (SELECT 1 FROM public.profiles WHERE username = LOWER(new_username) AND id != current_user_id) THEN
    RAISE EXCEPTION 'Username already taken';
  END IF;

  -- Update username (ON UPDATE CASCADE handles pages table)
  UPDATE public.profiles
  SET username = LOWER(new_username), updated_at = NOW()
  WHERE id = current_user_id;

  RETURN TRUE;
END;
$$;

-- ============================================
-- VERIFICATION QUERIES (run after schema creation)
-- ============================================
-- SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';
-- SELECT * FROM pg_policies WHERE schemaname = 'public';
-- SELECT tgname, tgrelid::regclass FROM pg_trigger WHERE tgname LIKE 'on_%';
```

This schema:
1. Creates profiles table linked to auth.users via UUID primary key
2. Creates pages table with one_page_per_user constraint
3. Creates cards table with flexible JSONB content
4. Enables RLS on all tables with appropriate policies
5. Sets up triggers to auto-create profile -> page on signup
6. Includes helper functions for username availability and updates
  </action>
  <verify>
```bash
# Check file exists and has expected content
cat /Users/julianmunyard/LinkLobby/supabase/schema.sql | head -50
# Should show the schema header and profiles table
```
  </verify>
  <done>
Schema SQL file created at supabase/schema.sql with all tables, RLS policies, triggers, and helper functions.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Execute schema in Supabase</name>
  <what-built>
Database schema SQL file ready for execution. The user needs to:
1. Create a Supabase project (if not exists)
2. Get the API credentials
3. Execute the schema SQL
4. Configure email settings
  </what-built>
  <how-to-verify>
**Step 1: Create Supabase Project (if needed)**
1. Go to https://supabase.com/dashboard
2. Click "New Project"
3. Name it "linklobby" (or similar)
4. Choose a database password (save it somewhere!)
5. Select region closest to you
6. Wait for project to provision (~2 minutes)

**Step 2: Get API Credentials**
1. Go to Project Settings (gear icon) -> API
2. Copy "Project URL" -> This is NEXT_PUBLIC_SUPABASE_URL
3. Copy "anon public" key -> This is NEXT_PUBLIC_SUPABASE_ANON_KEY
4. Update `/Users/julianmunyard/LinkLobby/.env.local` with these values

**Step 3: Execute Schema**
1. Go to SQL Editor (left sidebar)
2. Click "New Query"
3. Copy entire contents of `supabase/schema.sql`
4. Paste into the editor
5. Click "Run" (or Cmd+Enter)
6. Should see "Success. No rows returned" for each statement

**Step 4: Verify Tables Created**
Run this query in SQL Editor:
```sql
SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';
```
Should return: profiles, pages, cards

**Step 5: Disable Email Confirmation (for dev)**
1. Go to Authentication -> Providers -> Email
2. Toggle OFF "Confirm email"
3. This allows immediate login after signup (re-enable for production)

**Step 6: Verify Triggers**
Run this query in SQL Editor:
```sql
SELECT tgname, tgrelid::regclass FROM pg_trigger WHERE tgname LIKE 'on_%';
```
Should return:
- on_auth_user_created on auth.users
- on_profile_created on profiles
  </how-to-verify>
  <resume-signal>
Type "done" after completing all steps and verifying the tables exist, or describe any issues encountered.
  </resume-signal>
</task>

</tasks>

<verification>
After the checkpoint:

1. Supabase project exists and is accessible
2. `.env.local` has real NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY
3. Running `SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';` returns profiles, pages, cards
4. RLS is enabled (check Authentication -> Policies)
5. Triggers exist for auto-creation
</verification>

<success_criteria>
- profiles table exists with username UNIQUE constraint
- pages table exists with user_id foreign key and one_page_per_user constraint
- cards table exists with page_id foreign key and JSONB content column
- RLS enabled on all three tables
- on_auth_user_created trigger fires on signup
- on_profile_created trigger fires when profile inserted
- check_username_available function callable
- update_username function callable
- .env.local updated with real Supabase credentials
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
