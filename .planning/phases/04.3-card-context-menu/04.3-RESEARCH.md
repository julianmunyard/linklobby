# Phase 4.3: Card Context Menu & Undo/Redo - Research

**Researched:** 2026-01-26
**Domain:** Undo/Redo state management, keyboard shortcuts, toast actions
**Confidence:** HIGH

## Summary

This phase adds card actions (type switching, duplicate, delete) to the property editor and implements a full undo/redo system for all editor operations. The existing Zustand store pattern is ideal for integration with zundo, a lightweight (<700B) temporal middleware that adds time-travel capabilities to Zustand stores.

The approach uses:
1. **zundo** for undo/redo stack management with the existing Zustand store
2. **react-hotkeys-hook** for keyboard shortcuts (Ctrl/Cmd+Z, Ctrl/Cmd+Shift+Z)
3. **sonner** (already installed) for toast notifications with undo action buttons
4. **Icon tile picker** in the property editor for card type switching

**Primary recommendation:** Wrap the existing `usePageStore` with zundo's `temporal` middleware, add a `handleSet` throttle to batch rapid field changes, and use `partialize` to track only card-related state (excluding UI state like `selectedCardId`).

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| zundo | 2.3.0 | Undo/redo middleware for Zustand | Official Zustand third-party library, <700B, supports Zustand v5 |
| react-hotkeys-hook | 5.2.1 | Keyboard shortcut handling | Most popular React hotkey library, TypeScript support, declarative API |
| sonner | 2.0.7 | Toast notifications | Already installed, supports action buttons for undo |
| zustand | 5.0.10 | State management | Already installed, zundo 2.3.0 has official support |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| lodash.throttle | 4.1.1 | Throttle history snapshots | Wrap `handleSet` to batch rapid field changes |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| zundo | zustand-travel | More features (JSON Patch), but heavier; zundo is simpler for this use case |
| react-hotkeys-hook | Native useEffect | Native works but lacks form field detection, scoping, cross-platform mod key handling |
| lodash.throttle | just-throttle | just-throttle is smaller (no dependencies), either works |

**Installation:**
```bash
npm install zundo react-hotkeys-hook lodash.throttle
npm install -D @types/lodash.throttle
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── stores/
│   └── page-store.ts        # Wrap with temporal() middleware
├── hooks/
│   ├── use-history.ts       # Hook exposing undo/redo/canUndo/canRedo
│   └── use-hotkeys-setup.ts # Global keyboard shortcut registration
├── components/
│   └── editor/
│       ├── card-property-editor.tsx  # Add type picker, duplicate, delete buttons
│       ├── card-type-picker.tsx      # Visual tile picker for card types
│       └── history-controls.tsx      # Undo/redo toolbar buttons
```

### Pattern 1: Temporal Store Wrapper
**What:** Wrap existing Zustand store with zundo's temporal middleware
**When to use:** When you need undo/redo on state changes
**Example:**
```typescript
// Source: https://github.com/charkour/zundo
import { create } from 'zustand'
import { temporal } from 'zundo'
import throttle from 'lodash.throttle'

interface PageState {
  cards: Card[]
  selectedCardId: string | null
  // ... other fields
}

export const usePageStore = create<PageState>()(
  temporal(
    (set) => ({
      cards: [],
      selectedCardId: null,
      // ... actions
    }),
    {
      // Only track cards array, not UI state
      partialize: (state) => ({ cards: state.cards }),

      // Throttle to batch rapid changes (500ms)
      handleSet: (handleSet) =>
        throttle<typeof handleSet>((state) => {
          handleSet(state)
        }, 500, { leading: false, trailing: true }),

      // Limit history depth (memory management)
      limit: 50,
    }
  )
)

// Access temporal store
const { undo, redo, clear, pastStates, futureStates } = usePageStore.temporal.getState()
```

### Pattern 2: History Hook
**What:** Custom hook that exposes undo/redo state and actions
**When to use:** Components need to render undo/redo UI state
**Example:**
```typescript
// src/hooks/use-history.ts
import { usePageStore } from '@/stores/page-store'
import { useStore } from 'zustand'

export function useHistory() {
  const { undo, redo, clear } = usePageStore.temporal.getState()

  // Subscribe to temporal store for reactive updates
  const canUndo = useStore(usePageStore.temporal, (state) => state.pastStates.length > 0)
  const canRedo = useStore(usePageStore.temporal, (state) => state.futureStates.length > 0)

  return { undo, redo, clear, canUndo, canRedo }
}
```

### Pattern 3: Keyboard Shortcuts Setup
**What:** Global hotkey registration in root component
**When to use:** Editor keyboard shortcuts
**Example:**
```typescript
// Source: https://react-hotkeys-hook.vercel.app/docs/api/use-hotkeys
import { useHotkeys } from 'react-hotkeys-hook'
import { useHistory } from '@/hooks/use-history'

export function useHistoryHotkeys() {
  const { undo, redo, canUndo, canRedo } = useHistory()

  // Cross-platform: ctrl for Windows/Linux, meta for Mac
  useHotkeys('ctrl+z, meta+z', () => {
    if (canUndo) undo()
  }, { preventDefault: true })

  useHotkeys('ctrl+shift+z, meta+shift+z', () => {
    if (canRedo) redo()
  }, { preventDefault: true })
}
```

### Pattern 4: Delete with Undo Toast
**What:** Immediate delete with toast showing undo action
**When to use:** Destructive actions that benefit from quick recovery
**Example:**
```typescript
// Source: https://sonner.emilkowal.ski/toast
import { toast } from 'sonner'

function handleDelete(cardId: string) {
  // Store card data before deletion for potential restore
  const cardToDelete = cards.find(c => c.id === cardId)

  // Remove immediately (optimistic)
  removeCard(cardId)

  // Show toast with undo
  toast('Card deleted', {
    action: {
      label: 'Undo',
      onClick: () => {
        // Undo via temporal store
        undo()
      }
    },
    duration: 5000,
  })
}
```

### Pattern 5: Card Type Picker (Icon Tiles)
**What:** Visual tile picker showing card type thumbnails
**When to use:** Card type switching in property editor
**Example:**
```typescript
const CARD_TYPE_OPTIONS = [
  { type: 'hero', icon: RectangleHorizontal, label: 'Hero' },
  { type: 'horizontal', icon: Minus, label: 'Horizontal' },
  { type: 'square', icon: Square, label: 'Square' },
] as const

function CardTypePicker({ currentType, onChange }: Props) {
  return (
    <div className="grid grid-cols-3 gap-2">
      {CARD_TYPE_OPTIONS.map(({ type, icon: Icon, label }) => (
        <button
          key={type}
          onClick={() => onChange(type)}
          className={cn(
            "flex flex-col items-center p-3 rounded-md border",
            currentType === type && "border-primary bg-primary/10"
          )}
        >
          <Icon className="h-6 w-6 mb-1" />
          <span className="text-xs">{label}</span>
        </button>
      ))}
    </div>
  )
}
```

### Anti-Patterns to Avoid
- **Tracking UI state in history:** Don't include `selectedCardId`, `hasChanges`, or other UI state in undo history. Use `partialize` to exclude.
- **Unthrottled history:** Every keystroke creating a history entry makes undo unusable. Always throttle field edits.
- **Manual undo stack:** Don't build custom undo arrays when zundo exists and handles edge cases.
- **Confirmation dialogs for delete:** Modern UX prefers immediate action + undo toast over blocking confirmation dialogs.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Undo/redo state management | Custom past/present/future arrays | zundo temporal middleware | Handles edge cases, memory limits, pause/resume |
| Keyboard shortcuts | Manual keydown listeners | react-hotkeys-hook | Cross-platform mod keys, form field detection, scoping |
| Toast with action | Custom snackbar component | sonner with action prop | Already installed, handles timing, animations, stacking |
| Throttling field changes | Custom debounce logic | lodash.throttle with handleSet | Reliable, well-tested, zundo-compatible |

**Key insight:** Undo/redo has many subtle edge cases (memory limits, pause during drag operations, proper state restoration). Zundo handles these while staying tiny (<700B).

## Common Pitfalls

### Pitfall 1: Tracking Selection State in History
**What goes wrong:** Undo restores cards AND deselects the current card, confusing users
**Why it happens:** Including `selectedCardId` in partialized state
**How to avoid:** Use partialize to ONLY track `cards` array
**Warning signs:** Undoing changes the selected card unexpectedly

### Pitfall 2: Every Keystroke Creates History Entry
**What goes wrong:** Undo requires 50 presses to undo a single field edit
**Why it happens:** No throttle on form field changes to store
**How to avoid:** Use `handleSet` with 500ms throttle (trailing: true)
**Warning signs:** History stack grows rapidly during typing

### Pitfall 3: Undo During Drag Creates Corruption
**What goes wrong:** Undoing while dragging a card creates inconsistent state
**Why it happens:** Drag state and card positions are both tracked
**How to avoid:** Use `pause()` when drag starts, `resume()` when drag ends
**Warning signs:** Cards duplicate or disappear during drag + undo

### Pitfall 4: Browser Shortcuts Conflict
**What goes wrong:** Ctrl+Z triggers browser's native undo in text fields
**Why it happens:** Not preventing default behavior on hotkey
**How to avoid:** Set `preventDefault: true` in useHotkeys options
**Warning signs:** Text fields have native undo AND app undo happening

### Pitfall 5: History Lost on Page Refresh
**What goes wrong:** Users expect undo to work after refresh but it's empty
**Why it happens:** Temporal state not persisted to storage
**How to avoid:** Document that history is session-only (standard behavior), OR optionally persist with localStorage
**Warning signs:** User complaints about lost undo after refresh

### Pitfall 6: Type Conversion Loses Content
**What goes wrong:** Converting Hero to Square loses the button style setting
**Why it happens:** Card types have different content schemas
**How to avoid:** Unified content schema - all fields exist on all cards, display varies
**Warning signs:** Content disappears after type switch

## Code Examples

Verified patterns from official sources:

### Wrapping Store with Temporal
```typescript
// Source: https://github.com/charkour/zundo
import { create } from 'zustand'
import { temporal, TemporalState } from 'zundo'
import throttle from 'lodash.throttle'
import type { Card } from '@/types/card'

interface PageState {
  cards: Card[]
  selectedCardId: string | null
  hasChanges: boolean
  // ... other fields

  // Actions
  setCards: (cards: Card[]) => void
  addCard: (type: CardType) => void
  updateCard: (id: string, updates: Partial<Card>) => void
  removeCard: (id: string) => void
  // ...
}

// Type for partialized state (what gets tracked)
type PartialPageState = Pick<PageState, 'cards'>

export const usePageStore = create<PageState>()(
  temporal(
    (set, get) => ({
      cards: [],
      selectedCardId: null,
      hasChanges: false,

      setCards: (cards) => set({ cards, hasChanges: true }),
      // ... other actions
    }),
    {
      partialize: (state): PartialPageState => ({ cards: state.cards }),
      handleSet: (handleSet) =>
        throttle<typeof handleSet>(
          (state) => handleSet(state),
          500,
          { leading: false, trailing: true }
        ),
      limit: 50,
    }
  )
)
```

### Accessing Temporal Store
```typescript
// Source: https://github.com/charkour/zundo
import { useStore } from 'zustand'
import { usePageStore } from '@/stores/page-store'

export function useHistory() {
  // Get actions (non-reactive)
  const { undo, redo, clear, pause, resume } = usePageStore.temporal.getState()

  // Subscribe to state (reactive)
  const pastStates = useStore(usePageStore.temporal, (s) => s.pastStates)
  const futureStates = useStore(usePageStore.temporal, (s) => s.futureStates)

  return {
    undo,
    redo,
    clear,
    pause,
    resume,
    canUndo: pastStates.length > 0,
    canRedo: futureStates.length > 0,
  }
}
```

### Keyboard Shortcuts
```typescript
// Source: https://react-hotkeys-hook.vercel.app/docs/api/use-hotkeys
import { useHotkeys } from 'react-hotkeys-hook'

export function HistoryHotkeys() {
  const { undo, redo, canUndo, canRedo } = useHistory()

  useHotkeys(
    'ctrl+z, meta+z',
    (e) => {
      e.preventDefault()
      if (canUndo) {
        undo()
        toast('Undone', { duration: 2000 })
      }
    },
    { enableOnFormTags: false }
  )

  useHotkeys(
    'ctrl+shift+z, meta+shift+z',
    (e) => {
      e.preventDefault()
      if (canRedo) {
        redo()
        toast('Redone', { duration: 2000 })
      }
    },
    { enableOnFormTags: false }
  )

  return null // Invisible component for hotkey registration
}
```

### Toast with Undo Action
```typescript
// Source: https://sonner.emilkowal.ski/toast
import { toast } from 'sonner'

function handleDeleteCard(cardId: string) {
  const { removeCard } = usePageStore.getState()
  const { undo } = usePageStore.temporal.getState()

  // Remove immediately
  removeCard(cardId)

  // Show undo toast
  toast('Card deleted', {
    description: 'The card has been removed',
    action: {
      label: 'Undo',
      onClick: () => {
        undo()
        toast('Card restored')
      }
    },
    duration: 5000,
  })
}
```

### Pause History During Drag
```typescript
// In SortableCardList or similar
import { useHistory } from '@/hooks/use-history'

function SortableCardList() {
  const { pause, resume } = useHistory()

  const handleDragStart = () => {
    pause()
  }

  const handleDragEnd = () => {
    resume()
  }

  return (
    <DndContext
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
    >
      {/* ... */}
    </DndContext>
  )
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Confirmation dialogs for delete | Immediate delete + undo toast | ~2020 | Better UX, faster workflow |
| Redux-undo | zundo with Zustand | 2022 | Simpler API, smaller bundle |
| Manual keyboard event listeners | react-hotkeys-hook | 2020+ | Cross-platform, form-aware |
| Custom undo arrays | Temporal middleware | 2022 | Handles edge cases automatically |

**Deprecated/outdated:**
- `undoMiddleware` name: Renamed to `temporal` in zundo v2.0.0
- `include`/`exclude` options: Replaced by `partialize` in zundo v2.0.0
- `coolOffDurationMs`: Replaced by `handleSet` wrapper in zundo v2.0.0

## Open Questions

Things that couldn't be fully resolved:

1. **History depth trade-off**
   - What we know: 50 entries is reasonable for this use case
   - What's unclear: Whether users expect unlimited undo in a session
   - Recommendation: Start with limit: 50, can increase if feedback warrants

2. **Undo/redo button placement**
   - What we know: Dashboard header has space between username and Save button
   - What's unclear: Best position for undo/redo buttons (header vs inline with property editor)
   - Recommendation: Add to header near Save button for visibility on mobile

3. **Toast strategy for keyboard shortcuts**
   - What we know: Delete should show toast with undo option
   - What's unclear: Should Ctrl+Z show a brief "Undone" toast or be silent?
   - Recommendation: Show brief toast (2s) to confirm action, especially for keyboard shortcuts

## Sources

### Primary (HIGH confidence)
- [zundo GitHub](https://github.com/charkour/zundo) - API docs, partialize, handleSet, temporal store access
- [react-hotkeys-hook docs](https://react-hotkeys-hook.vercel.app/docs/api/use-hotkeys) - useHotkeys API, cross-platform mod keys
- [sonner docs](https://sonner.emilkowal.ski/toast) - Toast with action button, duration, dismiss

### Secondary (MEDIUM confidence)
- [Zustand third-party libraries](https://zustand.docs.pmnd.rs/integrations/third-party-libraries) - zundo officially listed
- [zundo releases](https://github.com/charkour/zundo/releases) - v2.3.0 confirms Zustand v5 support

### Tertiary (LOW confidence)
- WebSearch for best practices - Verified against official docs

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - zundo, react-hotkeys-hook, sonner all have authoritative docs
- Architecture: HIGH - Patterns directly from library documentation
- Pitfalls: MEDIUM - Derived from docs + common patterns, not production experience

**Research date:** 2026-01-26
**Valid until:** 2026-02-26 (stable libraries, low churn)
