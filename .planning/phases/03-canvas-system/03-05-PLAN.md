---
phase: 03-canvas-system
plan: 05
type: execute
wave: 3
depends_on: ["03-02", "03-04"]
files_modified:
  - src/app/api/cards/route.ts
  - src/app/api/cards/[id]/route.ts
  - src/lib/supabase/cards.ts
  - src/hooks/use-cards.ts
autonomous: true

must_haves:
  truths:
    - "Cards can be fetched from database"
    - "New cards can be created with sortKey"
    - "Card order updates persist to database"
    - "Cards can be deleted"
  artifacts:
    - path: "src/app/api/cards/route.ts"
      provides: "GET and POST endpoints for cards"
      exports: ["GET", "POST"]
    - path: "src/app/api/cards/[id]/route.ts"
      provides: "PATCH and DELETE endpoints for individual cards"
      exports: ["PATCH", "DELETE"]
    - path: "src/lib/supabase/cards.ts"
      provides: "Database operations for cards"
      exports: ["fetchCards", "createCard", "updateCard", "deleteCard"]
    - path: "src/hooks/use-cards.ts"
      provides: "React hook for card operations"
      exports: ["useCards"]
  key_links:
    - from: "src/app/api/cards/route.ts"
      to: "src/lib/supabase/cards.ts"
      via: "import database functions"
      pattern: "from '@/lib/supabase/cards'"
    - from: "src/hooks/use-cards.ts"
      to: "/api/cards"
      via: "fetch calls"
      pattern: "fetch.*api/cards"
---

<objective>
Create API routes and database operations for card persistence.

Purpose: Enable cards to be saved to and loaded from the database. This completes the data layer, allowing card order changes to persist across sessions.

Output: Card API routes, database functions, useCards hook
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-canvas-system/03-RESEARCH.md
@.planning/phases/03-canvas-system/03-01-SUMMARY.md
@.planning/phases/03-canvas-system/03-02-SUMMARY.md
@.planning/phases/03-canvas-system/03-04-SUMMARY.md

# Database and types
@supabase/schema.sql
@src/types/card.ts
@src/lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create card database operations</name>
  <files>src/lib/supabase/cards.ts</files>
  <action>
Create database helper functions for card CRUD operations:

```typescript
// src/lib/supabase/cards.ts
import { createClient } from "@/lib/supabase/server"
import type { Card, CardType, CardSize } from "@/types/card"

// Map database row to Card type
function mapDbToCard(row: Record<string, unknown>): Card {
  return {
    id: row.id as string,
    page_id: row.page_id as string,
    card_type: row.card_type as CardType,
    title: row.title as string | null,
    description: row.description as string | null,
    url: row.url as string | null,
    content: (row.content as Record<string, unknown>) || {},
    size: (row.size as CardSize) || "medium",
    sortKey: row.sort_key as string,
    is_visible: row.is_visible as boolean,
    created_at: row.created_at as string,
    updated_at: row.updated_at as string,
  }
}

// Map Card to database columns
function mapCardToDb(card: Partial<Card>) {
  const dbCard: Record<string, unknown> = {}
  if (card.page_id !== undefined) dbCard.page_id = card.page_id
  if (card.card_type !== undefined) dbCard.card_type = card.card_type
  if (card.title !== undefined) dbCard.title = card.title
  if (card.description !== undefined) dbCard.description = card.description
  if (card.url !== undefined) dbCard.url = card.url
  if (card.content !== undefined) dbCard.content = card.content
  if (card.size !== undefined) dbCard.size = card.size
  if (card.sortKey !== undefined) dbCard.sort_key = card.sortKey
  if (card.is_visible !== undefined) dbCard.is_visible = card.is_visible
  return dbCard
}

export async function fetchCards(pageId: string): Promise<Card[]> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from("cards")
    .select("*")
    .eq("page_id", pageId)
    .order("sort_key", { ascending: true })

  if (error) throw error
  return (data || []).map(mapDbToCard)
}

export async function createCard(
  card: Omit<Card, "id" | "created_at" | "updated_at">
): Promise<Card> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from("cards")
    .insert(mapCardToDb(card))
    .select()
    .single()

  if (error) throw error
  return mapDbToCard(data)
}

export async function updateCard(
  id: string,
  updates: Partial<Card>
): Promise<Card> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from("cards")
    .update({ ...mapCardToDb(updates), updated_at: new Date().toISOString() })
    .eq("id", id)
    .select()
    .single()

  if (error) throw error
  return mapDbToCard(data)
}

export async function deleteCard(id: string): Promise<void> {
  const supabase = await createClient()

  const { error } = await supabase.from("cards").delete().eq("id", id)

  if (error) throw error
}

export async function fetchUserPage(): Promise<{ id: string } | null> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return null

  const { data, error } = await supabase
    .from("pages")
    .select("id")
    .eq("user_id", user.id)
    .single()

  if (error) return null
  return data
}
```

Note: sortKey in TypeScript maps to sort_key in database. The mapping functions handle this.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/supabase/cards.ts`
  </verify>
  <done>Database operations for cards with proper sort_key mapping.</done>
</task>

<task type="auto">
  <name>Task 2: Create card API routes</name>
  <files>src/app/api/cards/route.ts, src/app/api/cards/[id]/route.ts</files>
  <action>
Create API routes for card CRUD operations.

**src/app/api/cards/route.ts:**
```typescript
// GET /api/cards - fetch all cards for current user's page
// POST /api/cards - create a new card

import { NextResponse } from "next/server"
import { createClient } from "@/lib/supabase/server"
import { fetchCards, createCard, fetchUserPage } from "@/lib/supabase/cards"

export async function GET() {
  try {
    const page = await fetchUserPage()
    if (!page) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 })
    }

    const cards = await fetchCards(page.id)
    return NextResponse.json({ cards })
  } catch (error) {
    console.error("Error fetching cards:", error)
    return NextResponse.json(
      { error: "Failed to fetch cards" },
      { status: 500 }
    )
  }
}

export async function POST(request: Request) {
  try {
    const page = await fetchUserPage()
    if (!page) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 })
    }

    const body = await request.json()
    const { card_type, title, description, url, content, size, sortKey, is_visible } = body

    const card = await createCard({
      page_id: page.id,
      card_type,
      title: title || null,
      description: description || null,
      url: url || null,
      content: content || {},
      size: size || "medium",
      sortKey,
      is_visible: is_visible ?? true,
    })

    return NextResponse.json({ card }, { status: 201 })
  } catch (error) {
    console.error("Error creating card:", error)
    return NextResponse.json(
      { error: "Failed to create card" },
      { status: 500 }
    )
  }
}
```

**src/app/api/cards/[id]/route.ts:**
```typescript
// PATCH /api/cards/[id] - update a card
// DELETE /api/cards/[id] - delete a card

import { NextResponse } from "next/server"
import { updateCard, deleteCard, fetchUserPage } from "@/lib/supabase/cards"

export async function PATCH(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const page = await fetchUserPage()
    if (!page) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 })
    }

    const { id } = await params
    const updates = await request.json()

    const card = await updateCard(id, updates)
    return NextResponse.json({ card })
  } catch (error) {
    console.error("Error updating card:", error)
    return NextResponse.json(
      { error: "Failed to update card" },
      { status: 500 }
    )
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const page = await fetchUserPage()
    if (!page) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 })
    }

    const { id } = await params
    await deleteCard(id)
    return NextResponse.json({ success: true })
  } catch (error) {
    console.error("Error deleting card:", error)
    return NextResponse.json(
      { error: "Failed to delete card" },
      { status: 500 }
    )
  }
}
```

Note: Next.js 15 params is a Promise, hence `await params`.
  </action>
  <verify>
Files exist and export correct HTTP methods.
`npx tsc --noEmit src/app/api/cards/route.ts src/app/api/cards/\\[id\\]/route.ts`
  </verify>
  <done>API routes for GET, POST, PATCH, DELETE card operations.</done>
</task>

<task type="auto">
  <name>Task 3: Create useCards hook for data fetching</name>
  <files>src/hooks/use-cards.ts</files>
  <action>
Create a hook that loads cards from API and syncs with the store:

```typescript
// src/hooks/use-cards.ts
"use client"

import { useEffect, useState, useCallback } from "react"
import { usePageStore } from "@/stores/page-store"
import type { Card } from "@/types/card"

export function useCards() {
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const setCards = usePageStore((state) => state.setCards)
  const cards = usePageStore((state) => state.getSortedCards())
  const hasChanges = usePageStore((state) => state.hasChanges)
  const markSaved = usePageStore((state) => state.markSaved)

  // Load cards on mount
  useEffect(() => {
    async function loadCards() {
      try {
        setIsLoading(true)
        setError(null)

        const response = await fetch("/api/cards")
        if (!response.ok) {
          throw new Error("Failed to fetch cards")
        }

        const { cards: fetchedCards } = await response.json()
        setCards(fetchedCards)
        // Mark as saved since we just loaded from DB
        markSaved()
      } catch (err) {
        setError(err instanceof Error ? err.message : "Unknown error")
      } finally {
        setIsLoading(false)
      }
    }

    loadCards()
  }, [setCards, markSaved])

  // Save all cards to database
  const saveCards = useCallback(async () => {
    try {
      setError(null)

      // Get cards from store (they may have been modified)
      const currentCards = usePageStore.getState().cards

      // For each card, update in database
      const promises = currentCards.map((card) =>
        fetch(`/api/cards/${card.id}`, {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            title: card.title,
            description: card.description,
            url: card.url,
            content: card.content,
            size: card.size,
            sortKey: card.sortKey,
            is_visible: card.is_visible,
          }),
        })
      )

      await Promise.all(promises)
      markSaved()
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to save")
      throw err
    }
  }, [markSaved])

  // Create a new card
  const createCard = useCallback(
    async (card: Omit<Card, "id" | "page_id" | "created_at" | "updated_at">) => {
      try {
        const response = await fetch("/api/cards", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(card),
        })

        if (!response.ok) {
          throw new Error("Failed to create card")
        }

        const { card: newCard } = await response.json()
        return newCard as Card
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to create")
        throw err
      }
    },
    []
  )

  // Delete a card
  const removeCard = useCallback(async (id: string) => {
    try {
      const response = await fetch(`/api/cards/${id}`, {
        method: "DELETE",
      })

      if (!response.ok) {
        throw new Error("Failed to delete card")
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to delete")
      throw err
    }
  }, [])

  return {
    cards,
    isLoading,
    error,
    hasChanges,
    saveCards,
    createCard,
    removeCard,
  }
}
```

This hook:
- Loads cards on mount and syncs to store
- Provides saveCards to persist all changes
- Provides createCard/removeCard for CRUD
- Tracks loading and error state
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/hooks/use-cards.ts`
  </verify>
  <done>useCards hook for loading, saving, and managing cards.</done>
</task>

</tasks>

<verification>
1. Database operations work with correct sort_key column
2. API routes return proper JSON responses
3. useCards hook loads and saves cards
4. TypeScript compiles without errors
</verification>

<success_criteria>
- GET /api/cards returns user's cards sorted by sort_key
- POST /api/cards creates card with sortKey
- PATCH /api/cards/[id] updates card including sortKey
- DELETE /api/cards/[id] removes card
- useCards loads cards into store on mount
</success_criteria>

<output>
After completion, create `.planning/phases/03-canvas-system/03-05-SUMMARY.md`
</output>
