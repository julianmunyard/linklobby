---
phase: 08-public-page
plan: 04
type: execute
wave: 3
depends_on: ["08-03"]
files_modified:
  - src/app/[username]/opengraph-image.tsx
  - src/app/[username]/twitter-image.tsx
  - src/app/sitemap.ts
  - src/app/robots.ts
autonomous: true

must_haves:
  truths:
    - "Sharing page on social media shows correct preview image"
    - "OG image includes profile avatar and display name"
    - "Sitemap lists all published pages"
    - "Robots.txt allows crawling of public pages"
    - "Editor and API routes are disallowed in robots.txt"
  artifacts:
    - path: "src/app/[username]/opengraph-image.tsx"
      provides: "Dynamic OG image generation"
      exports: ["default", "runtime", "alt", "size", "contentType"]
    - path: "src/app/sitemap.ts"
      provides: "Dynamic sitemap generation"
      exports: ["default", "revalidate"]
    - path: "src/app/robots.ts"
      provides: "Robots.txt configuration"
      exports: ["default"]
  key_links:
    - from: "src/app/[username]/opengraph-image.tsx"
      to: "src/lib/supabase/public.ts"
      via: "fetchPublicPageData call"
      pattern: "fetchPublicPageData"
    - from: "src/app/sitemap.ts"
      to: "supabase profiles table"
      via: "query published profiles"
      pattern: "is_published.*true"
---

<objective>
Implement SEO features: OG images, sitemap, and robots.txt.

Purpose: Social sharing needs attractive preview images. Search engines need sitemap and robots.txt to discover and index pages correctly.

Output: Dynamic OG image, Twitter card image, sitemap.ts, robots.ts
</objective>

<execution_context>
@/Users/julianmunyard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianmunyard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-public-page/08-CONTEXT.md
@.planning/phases/08-public-page/08-RESEARCH.md
@src/app/[username]/page.tsx
@src/lib/supabase/public.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dynamic OG image using ImageResponse</name>
  <files>src/app/[username]/opengraph-image.tsx, src/app/[username]/twitter-image.tsx</files>
  <action>
Create `src/app/[username]/opengraph-image.tsx` using Next.js ImageResponse (Satori-based):

```typescript
// src/app/[username]/opengraph-image.tsx
import { ImageResponse } from 'next/og'
import { fetchPublicPageData } from '@/lib/supabase/public'

// Image metadata
export const runtime = 'edge'
export const alt = 'Profile preview'
export const size = { width: 1200, height: 630 }
export const contentType = 'image/png'

interface ImageProps {
  params: Promise<{ username: string }>
}

/**
 * Dynamic OG image for social sharing
 * Uses @vercel/og ImageResponse (Satori) for fast generation
 * Per CONTEXT.md: "OG image is a dynamic screenshot of the page (above-the-fold only)"
 * Interpretation: Profile header representation, not browser screenshot
 */
export default async function Image({ params }: ImageProps) {
  const { username } = await params
  const data = await fetchPublicPageData(username)

  // Fallback for non-existent/unpublished pages
  if (!data) {
    return new ImageResponse(
      (
        <div
          style={{
            width: '100%',
            height: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: '#000000',
            color: '#ffffff',
            fontFamily: 'sans-serif',
          }}
        >
          <div style={{ fontSize: 48 }}>LinkLobby</div>
        </div>
      ),
      { ...size }
    )
  }

  const { profile, page } = data
  const displayName = profile.display_name || username

  // Get theme colors (fallback to Instagram Reels defaults)
  const bgColor = page.theme_settings?.colors?.background ?? '#000000'
  const textColor = page.theme_settings?.colors?.text ?? '#ffffff'
  const accentColor = page.theme_settings?.colors?.accent ?? '#ff4444'

  return new ImageResponse(
    (
      <div
        style={{
          width: '100%',
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: bgColor,
          color: textColor,
          fontFamily: 'sans-serif',
        }}
      >
        {/* Avatar */}
        {profile.show_avatar && profile.avatar_url && (
          <img
            src={profile.avatar_url}
            width={120}
            height={120}
            style={{
              borderRadius: '50%',
              objectFit: 'cover',
              marginBottom: 24,
            }}
          />
        )}

        {/* Display Name */}
        <div
          style={{
            fontSize: 56,
            fontWeight: 'bold',
            marginBottom: 12,
            textAlign: 'center',
          }}
        >
          {displayName}
        </div>

        {/* Bio (truncated) */}
        {profile.bio && (
          <div
            style={{
              fontSize: 24,
              opacity: 0.8,
              maxWidth: 800,
              textAlign: 'center',
            }}
          >
            {profile.bio.length > 100
              ? `${profile.bio.slice(0, 100)}...`
              : profile.bio}
          </div>
        )}

        {/* LinkLobby branding */}
        <div
          style={{
            position: 'absolute',
            bottom: 32,
            fontSize: 20,
            opacity: 0.5,
          }}
        >
          LinkLobby
        </div>
      </div>
    ),
    { ...size }
  )
}
```

Then create `src/app/[username]/twitter-image.tsx` that re-exports the same image:

```typescript
// src/app/[username]/twitter-image.tsx
// Twitter card uses the same image as OpenGraph
export { default, runtime, alt, contentType } from './opengraph-image'

// Twitter uses different dimensions but we'll use the same for simplicity
export const size = { width: 1200, height: 630 }
```

Key points:
- Uses `runtime = 'edge'` for fast generation
- Renders profile header representation (not browser screenshot per RESEARCH.md recommendation)
- Shows avatar, display name, truncated bio
- Uses theme colors from database
- Includes LinkLobby branding
  </action>
  <verify>
Run `npx tsc --noEmit src/app/[username]/opengraph-image.tsx`
Confirm exports: `grep "export" src/app/[username]/opengraph-image.tsx`
  </verify>
  <done>OG image generates with profile info and theme colors</done>
</task>

<task type="auto">
  <name>Task 2: Create dynamic sitemap</name>
  <files>src/app/sitemap.ts</files>
  <action>
Create `src/app/sitemap.ts` to list all published pages:

```typescript
// src/app/sitemap.ts
import type { MetadataRoute } from 'next'
import { createClient } from '@/lib/supabase/server'

// Revalidate sitemap every hour
export const revalidate = 3600

/**
 * Dynamic sitemap generation
 * Lists all published profiles for search engine indexing
 */
export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  const supabase = await createClient()

  // Fetch all profiles with published pages
  const { data: profiles } = await supabase
    .from('profiles')
    .select(`
      username,
      updated_at,
      pages!inner (
        is_published,
        updated_at
      )
    `)
    .eq('pages.is_published', true)

  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://linklobby.com'

  // Base routes
  const staticRoutes: MetadataRoute.Sitemap = [
    {
      url: baseUrl,
      lastModified: new Date(),
      changeFrequency: 'monthly',
      priority: 1,
    },
    {
      url: `${baseUrl}/login`,
      lastModified: new Date(),
      changeFrequency: 'yearly',
      priority: 0.3,
    },
    {
      url: `${baseUrl}/signup`,
      lastModified: new Date(),
      changeFrequency: 'yearly',
      priority: 0.3,
    },
  ]

  // Profile pages
  const profileRoutes: MetadataRoute.Sitemap = (profiles || []).map((profile) => {
    // Get the most recent update from profile or page
    const pageUpdated = Array.isArray(profile.pages)
      ? profile.pages[0]?.updated_at
      : (profile.pages as { updated_at?: string })?.updated_at
    const lastMod = pageUpdated || profile.updated_at

    return {
      url: `${baseUrl}/${profile.username}`,
      lastModified: new Date(lastMod),
      changeFrequency: 'weekly' as const,
      priority: 0.8,
    }
  })

  return [...staticRoutes, ...profileRoutes]
}
```

Key points:
- Uses ISR with 1-hour revalidation
- Joins profiles with pages to filter by is_published
- Includes static routes (home, login, signup)
- Uses NEXT_PUBLIC_SITE_URL env var for base URL
  </action>
  <verify>
Run `npx tsc --noEmit src/app/sitemap.ts`
Confirm revalidate export: `grep "revalidate" src/app/sitemap.ts`
  </verify>
  <done>Sitemap lists home page and all published profile pages</done>
</task>

<task type="auto">
  <name>Task 3: Create robots.ts</name>
  <files>src/app/robots.ts</files>
  <action>
Create `src/app/robots.ts` to configure crawler access:

```typescript
// src/app/robots.ts
import type { MetadataRoute } from 'next'

/**
 * Robots.txt configuration
 * Allows crawling of public pages, disallows private/internal routes
 */
export default function robots(): MetadataRoute.Robots {
  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://linklobby.com'

  return {
    rules: {
      userAgent: '*',
      allow: '/',
      disallow: [
        '/api/',        // API routes
        '/editor/',     // Editor (requires auth)
        '/settings/',   // Settings (requires auth)
        '/insights/',   // Insights (requires auth)
        '/login',       // Auth pages (low value for SEO)
        '/signup',      // Auth pages
        '/preview',     // Preview iframe
      ],
    },
    sitemap: `${baseUrl}/sitemap.xml`,
  }
}
```

Key points:
- Allows root and profile pages
- Disallows API, editor, settings, insights (private)
- Disallows auth pages (low SEO value)
- References sitemap.xml
  </action>
  <verify>
Run `npx tsc --noEmit src/app/robots.ts`
Confirm disallow list: `grep "disallow" src/app/robots.ts`
  </verify>
  <done>Robots.txt allows public pages, disallows private routes</done>
</task>

</tasks>

<verification>
1. OG image created: `ls src/app/[username]/opengraph-image.tsx`
2. Twitter image created: `ls src/app/[username]/twitter-image.tsx`
3. Sitemap created: `ls src/app/sitemap.ts`
4. Robots created: `ls src/app/robots.ts`
5. TypeScript compiles: `npx tsc --noEmit`
6. Start dev server and check:
   - Visit `/sitemap.xml` - should list profiles
   - Visit `/robots.txt` - should show rules
   - Visit `/testuser` (if exists) and inspect OG tags
</verification>

<success_criteria>
- OG image generates dynamically with profile avatar and name
- Twitter card shares the same image
- Sitemap includes all published profile pages
- Sitemap revalidates hourly
- Robots.txt allows public pages, disallows API/editor/settings
- All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-public-page/08-04-SUMMARY.md`
</output>
