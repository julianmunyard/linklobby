---
phase: 04.2-linktree-import
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/linktree.ts
  - src/lib/import/linktree-scraper.ts
  - src/lib/import/layout-generator.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Linktree page data can be fetched and parsed"
    - "Layout pattern generates visual variety (not all same card type)"
    - "Invalid/private profiles return clear error"
  artifacts:
    - path: "src/types/linktree.ts"
      provides: "Zod schemas for Linktree __NEXT_DATA__ structure"
      exports: ["LinktreeDataSchema", "LinktreeLinkSchema", "LinktreeLink"]
    - path: "src/lib/import/linktree-scraper.ts"
      provides: "Scraper service for fetching Linktree profiles"
      exports: ["scrapeLinktreeProfile", "normalizeLinktreeInput"]
    - path: "src/lib/import/layout-generator.ts"
      provides: "Layout pattern algorithm for randomized card types"
      exports: ["generateLayoutPattern", "LayoutItem"]
  key_links:
    - from: "src/lib/import/linktree-scraper.ts"
      to: "src/types/linktree.ts"
      via: "imports LinktreeDataSchema for validation"
      pattern: "import.*LinktreeDataSchema.*from.*linktree"
---

<objective>
Create the core infrastructure for Linktree import: Zod schemas for data validation, scraper service to fetch profile data, and layout generator for randomized card types.

Purpose: Establish the foundational services that the API route will use to scrape Linktree pages and map them to LinkLobby cards with visual variety.
Output: Three new files providing types, scraping, and layout generation capabilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.2-linktree-import/04.2-CONTEXT.md
@.planning/phases/04.2-linktree-import/04.2-RESEARCH.md
@src/types/card.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create Linktree type schemas</name>
  <files>
    - package.json
    - src/types/linktree.ts
  </files>
  <action>
1. Install axios and cheerio:
   ```bash
   npm install axios cheerio
   npm install -D @types/cheerio
   ```

2. Create `src/types/linktree.ts` with Zod schemas matching the __NEXT_DATA__ structure from RESEARCH.md:

```typescript
// src/types/linktree.ts
import { z } from 'zod'

// Individual link schema - matches Linktree's link structure
export const LinktreeLinkSchema = z.object({
  id: z.number(),
  title: z.string(),
  url: z.string().url(),
  type: z.string().optional(), // 'HEADER', 'CLASSIC', etc. - we'll ignore this per CONTEXT.md
  position: z.number(),
  thumbnail: z.string().url().optional().nullable(),
  locked: z.boolean().optional(),
})

// Account schema
const LinktreeAccountSchema = z.object({
  username: z.string(),
  pageTitle: z.string().optional().nullable(),
  description: z.string().optional().nullable(),
  tier: z.string().optional(),
  isActive: z.boolean().optional(),
  profilePictureUrl: z.string().url().optional().nullable(),
})

// Main data schema - validates __NEXT_DATA__.props.pageProps
export const LinktreePagePropsSchema = z.object({
  account: LinktreeAccountSchema.optional(),
  links: z.array(LinktreeLinkSchema),
  socialLinks: z.array(z.any()).optional(),
})

// Full __NEXT_DATA__ schema
export const LinktreeDataSchema = z.object({
  props: z.object({
    pageProps: LinktreePagePropsSchema,
  }),
})

// Export types
export type LinktreeData = z.infer<typeof LinktreeDataSchema>
export type LinktreeLink = z.infer<typeof LinktreeLinkSchema>
export type LinktreePageProps = z.infer<typeof LinktreePagePropsSchema>
```

Note: The schema is flexible to handle potential structure variations - uses `.optional()` liberally to avoid breaking on missing fields.
  </action>
  <verify>
    - `npm ls axios cheerio` shows both installed
    - `npx tsc --noEmit` passes (no type errors)
    - File exists at src/types/linktree.ts
  </verify>
  <done>
    - axios and cheerio installed
    - Zod schemas created for Linktree data validation
    - Types exported for use by scraper and mapper
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Linktree scraper service</name>
  <files>src/lib/import/linktree-scraper.ts</files>
  <action>
Create `src/lib/import/linktree-scraper.ts` following the patterns from RESEARCH.md:

```typescript
// src/lib/import/linktree-scraper.ts
import axios from 'axios'
import * as cheerio from 'cheerio'
import { LinktreeDataSchema, type LinktreePageProps } from '@/types/linktree'

// Normalize user input to username
export function normalizeLinktreeInput(input: string): string {
  const cleaned = input.trim()

  // If it's a URL, extract username
  if (cleaned.includes('linktr.ee/') || cleaned.includes('linktree.com/')) {
    const match = cleaned.match(/linktr\.ee\/([^/?#]+)|linktree\.com\/([^/?#]+)/)
    if (match) return match[1] || match[2]
  }

  // Remove @ prefix if present, return as username
  return cleaned.replace(/^@/, '')
}

// Custom error types for clear user feedback
export class LinktreeNotFoundError extends Error {
  constructor(username: string) {
    super(`This Linktree page is private or doesn't exist. Check the username: "${username}"`)
    this.name = 'LinktreeNotFoundError'
  }
}

export class LinktreeEmptyError extends Error {
  constructor() {
    super('No links found on this Linktree. Add some links manually instead.')
    this.name = 'LinktreeEmptyError'
  }
}

export class LinktreeFetchError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'LinktreeFetchError'
  }
}

// Scrape Linktree profile and return parsed data
export async function scrapeLinktreeProfile(input: string): Promise<LinktreePageProps> {
  const username = normalizeLinktreeInput(input)
  const url = `https://linktr.ee/${username}`

  try {
    const response = await axios.get(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.9',
      },
      timeout: 10000, // 10 second timeout
      validateStatus: (status) => status < 500, // Don't throw on 4xx
    })

    // Check for 404/redirect to home (profile not found)
    if (response.status === 404 || response.request?.responseURL === 'https://linktr.ee/') {
      throw new LinktreeNotFoundError(username)
    }

    // Parse HTML and extract __NEXT_DATA__
    const $ = cheerio.load(response.data)
    const nextDataScript = $('#__NEXT_DATA__').html()

    if (!nextDataScript) {
      throw new LinktreeNotFoundError(username)
    }

    // Parse and validate JSON
    const rawData = JSON.parse(nextDataScript)
    const validated = LinktreeDataSchema.safeParse(rawData)

    if (!validated.success) {
      console.error('Linktree data validation failed:', validated.error.issues)
      throw new LinktreeFetchError('Unable to parse Linktree page. The page structure may have changed.')
    }

    const pageProps = validated.data.props.pageProps

    // Filter to only clickable links (exclude headers, etc.)
    const clickableLinks = pageProps.links.filter(link =>
      link.url &&
      !link.locked &&
      link.type !== 'HEADER'
    )

    if (clickableLinks.length === 0) {
      throw new LinktreeEmptyError()
    }

    return {
      ...pageProps,
      links: clickableLinks,
    }
  } catch (error) {
    // Re-throw our custom errors
    if (error instanceof LinktreeNotFoundError ||
        error instanceof LinktreeEmptyError ||
        error instanceof LinktreeFetchError) {
      throw error
    }

    // Handle axios errors
    if (axios.isAxiosError(error)) {
      if (error.code === 'ECONNABORTED') {
        throw new LinktreeFetchError('Request timed out. Please try again.')
      }
      if (error.response?.status === 429) {
        throw new LinktreeFetchError('Too many requests. Please wait a moment and try again.')
      }
      throw new LinktreeFetchError('Failed to fetch Linktree page. Please check your connection.')
    }

    // Unknown error
    console.error('Unexpected error scraping Linktree:', error)
    throw new LinktreeFetchError('An unexpected error occurred. Please try again.')
  }
}
```

Key design decisions:
- Custom error classes for clear user feedback (per CONTEXT.md edge cases)
- Filter out HEADER type links (per CONTEXT.md - only import clickable links)
- 10 second timeout (per RESEARCH.md)
- Graceful error handling for rate limiting, timeouts, network issues
  </action>
  <verify>
    - File exists at src/lib/import/linktree-scraper.ts
    - `npx tsc --noEmit` passes
    - Manual test (optional): Create a quick test script to verify scraping works
  </verify>
  <done>
    - Scraper service created with normalizeLinktreeInput and scrapeLinktreeProfile exports
    - Custom error types for user-friendly error messages
    - Validation using Zod schemas from Task 1
  </done>
</task>

<task type="auto">
  <name>Task 3: Create layout generator for randomized card types</name>
  <files>src/lib/import/layout-generator.ts</files>
  <action>
Create `src/lib/import/layout-generator.ts` implementing the randomized layout pattern per CONTEXT.md ("immediate 'this is different' feeling"):

```typescript
// src/lib/import/layout-generator.ts
import type { CardType, CardSize } from '@/types/card'

export interface LayoutItem {
  type: CardType
  size: CardSize
}

// Define rhythm patterns - creates visual variety
// Each pattern is designed for visual balance and "this is different" feeling
const LAYOUT_PATTERNS: LayoutItem[][] = [
  // Pattern A: Hero + 2 small squares (dramatic opener)
  [
    { type: 'hero', size: 'big' },
    { type: 'square', size: 'small' },
    { type: 'square', size: 'small' },
  ],
  // Pattern B: Horizontal + big square (balanced)
  [
    { type: 'horizontal', size: 'big' },
    { type: 'square', size: 'big' },
  ],
  // Pattern C: 2 small squares + horizontal (rhythm change)
  [
    { type: 'square', size: 'small' },
    { type: 'square', size: 'small' },
    { type: 'horizontal', size: 'big' },
  ],
  // Pattern D: Hero small + square small + horizontal (variety)
  [
    { type: 'hero', size: 'small' },
    { type: 'square', size: 'small' },
    { type: 'horizontal', size: 'big' },
  ],
  // Pattern E: Big square + 2 small squares (grid feel)
  [
    { type: 'square', size: 'big' },
    { type: 'square', size: 'small' },
    { type: 'square', size: 'small' },
  ],
]

/**
 * Generate a layout pattern for N links.
 * Cycles through patterns to create visual rhythm.
 * Returns array of LayoutItems matching the link count.
 */
export function generateLayoutPattern(linkCount: number): LayoutItem[] {
  if (linkCount === 0) return []

  const result: LayoutItem[] = []
  let patternIndex = 0

  while (result.length < linkCount) {
    const pattern = LAYOUT_PATTERNS[patternIndex % LAYOUT_PATTERNS.length]

    // Add items from current pattern until we have enough
    for (const item of pattern) {
      if (result.length >= linkCount) break
      result.push({ ...item }) // Clone to avoid mutation
    }

    patternIndex++
  }

  return result.slice(0, linkCount)
}

/**
 * Generate layout with slight randomization to avoid predictability.
 * Shuffles the starting pattern index based on link count.
 */
export function generateLayoutPatternRandomized(linkCount: number): LayoutItem[] {
  if (linkCount === 0) return []

  // Use a deterministic "random" start based on link count
  // This ensures same count = same layout (predictable for testing)
  // but different counts get different feels
  const startIndex = linkCount % LAYOUT_PATTERNS.length

  const result: LayoutItem[] = []
  let patternIndex = startIndex

  while (result.length < linkCount) {
    const pattern = LAYOUT_PATTERNS[patternIndex % LAYOUT_PATTERNS.length]

    for (const item of pattern) {
      if (result.length >= linkCount) break
      result.push({ ...item })
    }

    patternIndex++
  }

  return result.slice(0, linkCount)
}
```

Design rationale:
- Patterns alternate between hero, horizontal, and square cards
- Mix of big and small sizes creates visual rhythm
- Patterns are deterministic for consistent results (same input = same output)
- startIndex varies by link count so different profiles look different
- No forced platform-specific types (per CONTEXT.md - layout decides, not platform)
  </action>
  <verify>
    - File exists at src/lib/import/layout-generator.ts
    - `npx tsc --noEmit` passes
    - Quick sanity check: generateLayoutPattern(5) returns 5 items with variety of types/sizes
  </verify>
  <done>
    - Layout generator created with pattern-based algorithm
    - Exports generateLayoutPattern and generateLayoutPatternRandomized
    - Creates visual variety immediately distinguishing from Linktree's uniform look
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm ls axios cheerio` confirms dependencies installed
2. `npx tsc --noEmit` passes with no type errors
3. Files exist:
   - src/types/linktree.ts
   - src/lib/import/linktree-scraper.ts
   - src/lib/import/layout-generator.ts
4. Imports resolve correctly (no circular dependencies)
</verification>

<success_criteria>
- axios and cheerio installed as dependencies
- Zod schemas validate Linktree __NEXT_DATA__ structure
- Scraper can normalize username/URL input
- Scraper throws typed errors for not-found, empty, and fetch failures
- Layout generator produces varied card types and sizes
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04.2-linktree-import/04.2-01-SUMMARY.md`
</output>
