---
phase: 04.2-linktree-import
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - src/app/api/import/linktree/route.ts
  - src/lib/import/linktree-mapper.ts
  - src/components/editor/linktree-import-dialog.tsx
  - src/components/editor/cards-tab.tsx
autonomous: false

must_haves:
  truths:
    - "User can enter Linktree username and import links"
    - "Imported links appear as cards on canvas with varied types/sizes"
    - "Thumbnails are downloaded and re-uploaded to our storage"
    - "User is asked to add or replace if they have existing cards"
    - "Clear error messages shown for invalid/private/empty profiles"
    - "Toast shows import result (X links imported, Y failed)"
  artifacts:
    - path: "src/app/api/import/linktree/route.ts"
      provides: "API endpoint for importing Linktree profiles"
      exports: ["POST"]
    - path: "src/lib/import/linktree-mapper.ts"
      provides: "Maps Linktree data to LinkLobby cards"
      exports: ["mapLinktreeToCards"]
    - path: "src/components/editor/linktree-import-dialog.tsx"
      provides: "Import dialog with input and confirmation"
      exports: ["LinktreeImportDialog"]
  key_links:
    - from: "src/app/api/import/linktree/route.ts"
      to: "src/lib/import/linktree-scraper.ts"
      via: "calls scrapeLinktreeProfile"
      pattern: "scrapeLinktreeProfile"
    - from: "src/app/api/import/linktree/route.ts"
      to: "src/lib/supabase/cards.ts"
      via: "creates cards in database"
      pattern: "createCard"
    - from: "src/components/editor/linktree-import-dialog.tsx"
      to: "/api/import/linktree"
      via: "fetch POST request"
      pattern: "fetch.*api/import/linktree"
    - from: "src/lib/import/linktree-mapper.ts"
      to: "src/lib/import/layout-generator.ts"
      via: "imports generateLayoutPatternRandomized"
      pattern: "import.*generateLayoutPatternRandomized.*from.*layout-generator"
---

<objective>
Wire up the complete Linktree import flow: API route that orchestrates scraping and card creation, mapper that transforms Linktree links to cards with image handling, and UI dialog for user interaction.

Purpose: Enable artists to import their Linktree links with one click, seeing their cards appear with visual variety.
Output: Working end-to-end import feature accessible from the editor.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.2-linktree-import/04.2-CONTEXT.md
@.planning/phases/04.2-linktree-import/04.2-RESEARCH.md
@.planning/phases/04.2-linktree-import/04.2-01-SUMMARY.md
@src/types/card.ts
@src/lib/supabase/cards.ts
@src/lib/supabase/storage.ts
@src/app/api/cards/route.ts
@src/components/editor/cards-tab.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mapper and API route for import</name>
  <files>
    - src/lib/import/linktree-mapper.ts
    - src/app/api/import/linktree/route.ts
  </files>
  <action>
1. Create `src/lib/import/linktree-mapper.ts` - transforms Linktree data to cards with STRUCTURED return for image blobs:

```typescript
// src/lib/import/linktree-mapper.ts
import axios from 'axios'
import { generateLayoutPatternRandomized, type LayoutItem } from './layout-generator'
import type { LinktreeLink } from '@/types/linktree'
import type { CardType, CardSize, HorizontalPosition } from '@/types/card'

// Card data without the image blob
export interface MappedCardData {
  card_type: CardType
  title: string | null
  description: string | null
  url: string
  content: Record<string, unknown>
  size: CardSize
  position: HorizontalPosition
}

// Structured return: card data paired with its image blob
export interface MappedCardWithImage {
  card: MappedCardData
  imageBlob: Blob | null
}

// Result of full import
export interface ImportResult {
  mappedCards: MappedCardWithImage[]
  failures: Array<{ index: number; title: string; reason: string }>
}

// Download image from URL and return as Blob
async function downloadImage(imageUrl: string): Promise<Blob | null> {
  try {
    const response = await axios.get(imageUrl, {
      responseType: 'arraybuffer',
      timeout: 5000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)',
      },
    })

    const contentType = response.headers['content-type'] || 'image/jpeg'
    return new Blob([response.data], { type: contentType })
  } catch (error) {
    console.warn('Failed to download image:', imageUrl, error)
    return null
  }
}

/**
 * Map Linktree links to LinkLobby cards.
 * Downloads thumbnails and returns them separately from card data.
 * Returns array of {card, imageBlob} objects for clean API handling.
 */
export async function mapLinktreeToCards(
  links: LinktreeLink[]
): Promise<ImportResult> {
  const layout = generateLayoutPatternRandomized(links.length)

  // Process links in parallel with Promise.allSettled
  const settledResults = await Promise.allSettled(
    links.map(async (link, index) => {
      const layoutItem = layout[index]

      // Download thumbnail if available
      let imageBlob: Blob | null = null
      if (link.thumbnail) {
        imageBlob = await downloadImage(link.thumbnail)
      }

      // Map to our card format - image blob is separate, not embedded in content
      const card: MappedCardData = {
        card_type: layoutItem.type,
        title: link.title || null,
        description: null, // Linktree doesn't have descriptions on links
        url: link.url,
        content: {}, // Clean content object - no embedded blobs
        size: layoutItem.size,
        position: 'left' as HorizontalPosition, // Will flow naturally in our layout
      }

      return { card, imageBlob, index }
    })
  )

  // Separate successes and failures
  const mappedCards: MappedCardWithImage[] = []
  const failures: Array<{ index: number; title: string; reason: string }> = []

  for (const result of settledResults) {
    if (result.status === 'fulfilled') {
      const { card, imageBlob } = result.value
      // Return structured object with card data and imageBlob separate
      mappedCards.push({ card, imageBlob })
    } else {
      const linkIndex = settledResults.indexOf(result)
      failures.push({
        index: linkIndex,
        title: links[linkIndex]?.title || 'Unknown',
        reason: result.reason?.message || 'Unknown error',
      })
    }
  }

  return { mappedCards, failures }
}
```

2. Create `src/app/api/import/linktree/route.ts` using the structured mapper return:

```typescript
// src/app/api/import/linktree/route.ts
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { scrapeLinktreeProfile, LinktreeNotFoundError, LinktreeEmptyError, LinktreeFetchError } from '@/lib/import/linktree-scraper'
import { mapLinktreeToCards } from '@/lib/import/linktree-mapper'
import { fetchUserPage, createCard } from '@/lib/supabase/cards'
import { generateAppendKey } from '@/lib/ordering'
import type { Card } from '@/types/card'

const BUCKET_NAME = 'card-images'

export async function POST(request: Request) {
  try {
    // Authenticate user
    const page = await fetchUserPage()
    if (!page) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })
    }

    // Get username from request
    const { username, existingCards = [] } = await request.json()
    if (!username || typeof username !== 'string') {
      return NextResponse.json({ error: 'Username is required' }, { status: 400 })
    }

    // Scrape Linktree profile
    const profileData = await scrapeLinktreeProfile(username)

    // Map to our card format - returns structured {card, imageBlob} pairs
    const { mappedCards, failures } = await mapLinktreeToCards(profileData.links)

    // Create cards in database with images uploaded
    const supabase = await createClient()
    const createdCards: Card[] = []
    let sortKeyBase = existingCards.length > 0
      ? generateAppendKey(existingCards)
      : 'a0'

    for (const { card: cardData, imageBlob } of mappedCards) {
      try {
        // Upload image if we have one - imageBlob is already extracted, not embedded
        let imageUrl: string | undefined

        if (imageBlob) {
          const fileExt = imageBlob.type.split('/')[1] || 'jpg'
          const tempId = crypto.randomUUID()
          const fileName = `${tempId}/${crypto.randomUUID()}.${fileExt}`

          const { data: uploadData, error: uploadError } = await supabase.storage
            .from(BUCKET_NAME)
            .upload(fileName, imageBlob, {
              contentType: imageBlob.type,
              upsert: false,
            })

          if (!uploadError && uploadData) {
            const { data: urlData } = supabase.storage
              .from(BUCKET_NAME)
              .getPublicUrl(uploadData.path)
            imageUrl = urlData.publicUrl
          }
        }

        // Create the card - content is clean, just add imageUrl if we have one
        const card = await createCard({
          page_id: page.id,
          card_type: cardData.card_type,
          title: cardData.title,
          description: cardData.description,
          url: cardData.url,
          content: imageUrl ? { imageUrl } : {},
          size: cardData.size,
          position: cardData.position,
          sortKey: sortKeyBase,
          is_visible: true,
        })

        createdCards.push(card)

        // Update sortKey for next card
        sortKeyBase = generateAppendKey([...existingCards, ...createdCards])
      } catch (cardError) {
        console.error('Failed to create card:', cardError)
        failures.push({
          index: mappedCards.findIndex(m => m.card === cardData),
          title: cardData.title || 'Untitled',
          reason: 'Failed to save card',
        })
      }
    }

    return NextResponse.json({
      success: true,
      imported: createdCards.length,
      failed: failures.length,
      cards: createdCards,
      failures,
    })
  } catch (error) {
    // Handle known error types with user-friendly messages
    if (error instanceof LinktreeNotFoundError) {
      return NextResponse.json({ error: error.message }, { status: 404 })
    }
    if (error instanceof LinktreeEmptyError) {
      return NextResponse.json({ error: error.message }, { status: 404 })
    }
    if (error instanceof LinktreeFetchError) {
      return NextResponse.json({ error: error.message }, { status: 502 })
    }

    console.error('Import error:', error)
    return NextResponse.json(
      { error: 'Failed to import Linktree. Please try again.' },
      { status: 500 }
    )
  }
}
```

Key design improvement: The mapper now returns `{card, imageBlob}` pairs instead of embedding blobs in the content object. This makes the data flow explicit and avoids fragile type casting in the API route.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Files exist at correct paths
    - `grep -q "export async function POST" src/app/api/import/linktree/route.ts && echo "POST exported"`
    - `grep -q "export interface MappedCardWithImage" src/lib/import/linktree-mapper.ts && echo "MappedCardWithImage interface exists"`
    - `grep -q "mappedCards: MappedCardWithImage" src/lib/import/linktree-mapper.ts && echo "Structured return type used"`
  </verify>
  <done>
    - Mapper transforms Linktree links to card format with structured {card, imageBlob} return
    - API route orchestrates full import flow using clean data extraction
    - Proper error handling with user-friendly messages
    - Images uploaded to Supabase storage
  </done>
</task>

<task type="auto">
  <name>Task 2: Create import dialog and integrate into editor</name>
  <files>
    - src/components/editor/linktree-import-dialog.tsx
    - src/components/editor/cards-tab.tsx
  </files>
  <action>
1. Create `src/components/editor/linktree-import-dialog.tsx`:

```typescript
// src/components/editor/linktree-import-dialog.tsx
'use client'

import { useState } from 'react'
import { Loader2, Download } from 'lucide-react'
import { toast } from 'sonner'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { usePageStore } from '@/stores/page-store'
import type { Card } from '@/types/card'

interface LinktreeImportDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
}

type ImportMode = 'add' | 'replace'

export function LinktreeImportDialog({ open, onOpenChange }: LinktreeImportDialogProps) {
  const [username, setUsername] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [showConfirmDialog, setShowConfirmDialog] = useState(false)
  const [pendingMode, setPendingMode] = useState<ImportMode | null>(null)

  const cards = usePageStore((state) => state.cards)
  const setCards = usePageStore((state) => state.setCards)
  const hasExistingCards = cards.length > 0

  const handleImport = async (mode: ImportMode) => {
    if (!username.trim()) {
      toast.error('Please enter a Linktree username or URL')
      return
    }

    setIsLoading(true)
    setShowConfirmDialog(false)

    try {
      const existingCards = mode === 'add' ? cards : []

      const response = await fetch('/api/import/linktree', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          username: username.trim(),
          existingCards,
        }),
      })

      const data = await response.json()

      if (!response.ok) {
        toast.error(data.error || 'Failed to import')
        return
      }

      // Update store with imported cards
      if (mode === 'replace') {
        setCards(data.cards)
      } else {
        setCards([...cards, ...data.cards])
      }

      // Show success toast
      if (data.failed > 0) {
        toast.success(`Imported ${data.imported} links (${data.failed} failed)`)
      } else {
        toast.success(`Imported ${data.imported} links`)
      }

      // Reset and close
      setUsername('')
      onOpenChange(false)
    } catch (error) {
      console.error('Import error:', error)
      toast.error('Failed to import. Please try again.')
    } finally {
      setIsLoading(false)
    }
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()

    if (!username.trim()) {
      toast.error('Please enter a Linktree username or URL')
      return
    }

    // If user has existing cards, ask what to do
    if (hasExistingCards) {
      setShowConfirmDialog(true)
    } else {
      handleImport('add')
    }
  }

  const handleModeSelect = (mode: ImportMode) => {
    setPendingMode(mode)
    handleImport(mode)
  }

  return (
    <>
      <Dialog open={open && !showConfirmDialog} onOpenChange={onOpenChange}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Import from Linktree</DialogTitle>
            <DialogDescription>
              Enter your Linktree username or URL to import your existing links.
            </DialogDescription>
          </DialogHeader>

          <form onSubmit={handleSubmit}>
            <div className="grid gap-4 py-4">
              <div className="grid gap-2">
                <Label htmlFor="username">Linktree Username or URL</Label>
                <Input
                  id="username"
                  placeholder="artistname or linktr.ee/artistname"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  disabled={isLoading}
                  autoFocus
                />
              </div>
            </div>

            <DialogFooter>
              <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isLoading}>
                Cancel
              </Button>
              <Button type="submit" disabled={isLoading || !username.trim()}>
                {isLoading ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Importing...
                  </>
                ) : (
                  <>
                    <Download className="mr-2 h-4 w-4" />
                    Import
                  </>
                )}
              </Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>

      {/* Confirmation dialog for existing cards */}
      <AlertDialog open={showConfirmDialog} onOpenChange={setShowConfirmDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>You have existing cards</AlertDialogTitle>
            <AlertDialogDescription>
              Would you like to add the imported links to your existing cards, or start fresh?
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter className="flex-col sm:flex-row gap-2">
            <AlertDialogCancel onClick={() => setShowConfirmDialog(false)} disabled={isLoading}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={() => handleModeSelect('add')}
              disabled={isLoading}
              className="bg-secondary text-secondary-foreground hover:bg-secondary/80"
            >
              {isLoading && pendingMode === 'add' ? (
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              ) : null}
              Add to existing
            </AlertDialogAction>
            <AlertDialogAction
              onClick={() => handleModeSelect('replace')}
              disabled={isLoading}
            >
              {isLoading && pendingMode === 'replace' ? (
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              ) : null}
              Start fresh
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  )
}
```

2. Update `src/components/editor/cards-tab.tsx` - COMPLETE implementation with all changes:

Read the existing file first, then make these specific modifications:

a) Add imports at the top of the file:
```typescript
import { useState } from 'react'
import { Download } from 'lucide-react'
import { LinktreeImportDialog } from './linktree-import-dialog'
```

b) Add state inside the component function (near the top with other state):
```typescript
const [importDialogOpen, setImportDialogOpen] = useState(false)
```

c) Add "Import" button in the header section, next to the "Add Card" dropdown/button:
```typescript
<Button size="sm" variant="ghost" onClick={() => setImportDialogOpen(true)}>
  <Download className="h-4 w-4 mr-1" />
  Import
</Button>
```

d) Add empty state when cards.length === 0 - replace the existing empty state or add if none exists:
```typescript
{cards.length === 0 ? (
  <div className="flex flex-col items-center justify-center py-12 text-center">
    <p className="text-muted-foreground mb-4">No cards yet</p>
    <Button onClick={() => setImportDialogOpen(true)} className="mb-2">
      <Download className="h-4 w-4 mr-2" />
      Import from Linktree
    </Button>
    <p className="text-sm text-muted-foreground">
      Or <button className="underline" onClick={handleAddCard}>add a card manually</button>
    </p>
  </div>
) : (
  // ... existing cards list rendering
)}
```
Note: Replace `handleAddCard` with whatever the existing add card handler is named.

e) Add the dialog component at the end of the component return, before the closing wrapper tag:
```typescript
<LinktreeImportDialog open={importDialogOpen} onOpenChange={setImportDialogOpen} />
```

The key changes are:
1. Import button in header (always visible)
2. Empty state with prominent import CTA when no cards
3. LinktreeImportDialog rendered with open state
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `grep -q "LinktreeImportDialog" src/components/editor/cards-tab.tsx && echo "Dialog imported"`
    - `grep -q "importDialogOpen" src/components/editor/cards-tab.tsx && echo "State added"`
    - `grep -q "Import from Linktree" src/components/editor/cards-tab.tsx && echo "Empty state has import CTA"`
    - File exists at src/components/editor/linktree-import-dialog.tsx
  </verify>
  <done>
    - Import dialog with username input
    - Confirmation dialog for existing cards (add vs replace)
    - Loading states and error handling
    - Toast notifications for results
    - Import button in editor header
    - Empty state with prominent import CTA
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify import flow end-to-end</name>
  <what-built>
    Complete Linktree import feature:
    - API route at /api/import/linktree
    - Import dialog with username/URL input
    - Confirmation dialog for existing cards
    - Cards created with randomized types/sizes
    - Thumbnails downloaded and re-uploaded
    - Toast notifications for results
  </what-built>
  <how-to-verify>
    1. Start dev server: `npm run dev`
    2. Navigate to editor (http://localhost:3000/editor)
    3. Click "Import" button in the Cards tab header
    4. Enter a public Linktree username (e.g., "linktree" or another public profile)
    5. Click Import and wait for completion
    6. Verify:
       - Toast shows "Imported X links"
       - Cards appear with VARIED types (hero, horizontal, square) - NOT all the same
       - Cards have different sizes (big/small mix)
       - Thumbnails display where available
       - Card order matches Linktree order
    7. Test error handling:
       - Try an invalid username (e.g., "thisuserdoesnotexist12345")
       - Verify error toast with clear message
    8. Test existing cards flow:
       - If you have cards, try importing again
       - Verify confirmation dialog appears
       - Test "Add to existing" option
       - Test "Start fresh" option
  </how-to-verify>
  <resume-signal>Type "approved" if import works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes
2. API route responds to POST /api/import/linktree
3. Dialog opens and accepts username input
4. Cards are created with varied types and sizes
5. Thumbnails are uploaded to storage
6. Error messages are user-friendly
7. Existing cards flow works (add vs replace)
</verification>

<success_criteria>
- User can enter Linktree username or full URL
- System fetches links from Linktree page
- Cards are created with randomized visual variety (not all horizontal)
- Thumbnails are preserved (downloaded and re-uploaded)
- User sees confirmation dialog if they have existing cards
- Clear error messages for invalid/private/empty profiles
- Toast shows import result count
- Cards appear immediately on canvas after import
</success_criteria>

<output>
After completion, create `.planning/phases/04.2-linktree-import/04.2-02-SUMMARY.md`
</output>
