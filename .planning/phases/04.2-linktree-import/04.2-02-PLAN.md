---
phase: 04.2-linktree-import
plan: 02
type: execute
wave: 2
depends_on: ["04.2-01"]
files_modified:
  - src/app/api/import/linktree/route.ts
  - src/lib/import/linktree-mapper.ts
  - src/components/editor/linktree-import-dialog.tsx
  - src/components/editor/cards-tab.tsx
autonomous: false

must_haves:
  truths:
    - "User can enter Linktree username and import links"
    - "Imported links appear as cards on canvas with varied types/sizes"
    - "Thumbnails are downloaded and re-uploaded to our storage"
    - "User is asked to add or replace if they have existing cards"
    - "Clear error messages shown for invalid/private/empty profiles"
    - "Toast shows import result (X links imported, Y failed)"
  artifacts:
    - path: "src/app/api/import/linktree/route.ts"
      provides: "API endpoint for importing Linktree profiles"
      exports: ["POST"]
    - path: "src/lib/import/linktree-mapper.ts"
      provides: "Maps Linktree data to LinkLobby cards"
      exports: ["mapLinktreeToCards"]
    - path: "src/components/editor/linktree-import-dialog.tsx"
      provides: "Import dialog with input and confirmation"
      exports: ["LinktreeImportDialog"]
  key_links:
    - from: "src/app/api/import/linktree/route.ts"
      to: "src/lib/import/linktree-scraper.ts"
      via: "calls scrapeLinktreeProfile"
      pattern: "scrapeLinktreeProfile"
    - from: "src/app/api/import/linktree/route.ts"
      to: "src/lib/supabase/cards.ts"
      via: "creates cards in database"
      pattern: "createCard"
    - from: "src/components/editor/linktree-import-dialog.tsx"
      to: "/api/import/linktree"
      via: "fetch POST request"
      pattern: "fetch.*api/import/linktree"
---

<objective>
Wire up the complete Linktree import flow: API route that orchestrates scraping and card creation, mapper that transforms Linktree links to cards with image handling, and UI dialog for user interaction.

Purpose: Enable artists to import their Linktree links with one click, seeing their cards appear with visual variety.
Output: Working end-to-end import feature accessible from the editor.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.2-linktree-import/04.2-CONTEXT.md
@.planning/phases/04.2-linktree-import/04.2-RESEARCH.md
@.planning/phases/04.2-linktree-import/04.2-01-SUMMARY.md
@src/types/card.ts
@src/lib/supabase/cards.ts
@src/lib/supabase/storage.ts
@src/app/api/cards/route.ts
@src/components/editor/cards-tab.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mapper and API route for import</name>
  <files>
    - src/lib/import/linktree-mapper.ts
    - src/app/api/import/linktree/route.ts
  </files>
  <action>
1. Create `src/lib/import/linktree-mapper.ts` - transforms Linktree data to cards:

```typescript
// src/lib/import/linktree-mapper.ts
import axios from 'axios'
import { generateLayoutPatternRandomized, type LayoutItem } from './layout-generator'
import type { LinktreeLink } from '@/types/linktree'
import type { CardType, CardSize, HorizontalPosition } from '@/types/card'

// Result of mapping a single link
export interface MappedCard {
  card_type: CardType
  title: string | null
  description: string | null
  url: string
  content: Record<string, unknown>
  size: CardSize
  position: HorizontalPosition
}

// Result of full import
export interface ImportResult {
  cards: MappedCard[]
  failures: Array<{ index: number; title: string; reason: string }>
}

// Download image from URL and return as Blob
async function downloadImage(imageUrl: string): Promise<Blob | null> {
  try {
    const response = await axios.get(imageUrl, {
      responseType: 'arraybuffer',
      timeout: 5000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)',
      },
    })

    const contentType = response.headers['content-type'] || 'image/jpeg'
    return new Blob([response.data], { type: contentType })
  } catch (error) {
    console.warn('Failed to download image:', imageUrl, error)
    return null
  }
}

/**
 * Map Linktree links to LinkLobby cards.
 * Downloads thumbnails and prepares them for upload.
 * Returns cards ready for creation (images need to be uploaded separately).
 */
export async function mapLinktreeToCards(
  links: LinktreeLink[]
): Promise<ImportResult> {
  const layout = generateLayoutPatternRandomized(links.length)
  const results: (MappedCard | { error: string; index: number })[] = []

  // Process links in parallel with Promise.allSettled
  const settledResults = await Promise.allSettled(
    links.map(async (link, index) => {
      const layoutItem = layout[index]

      // Download thumbnail if available
      let imageBlob: Blob | null = null
      if (link.thumbnail) {
        imageBlob = await downloadImage(link.thumbnail)
      }

      // Map to our card format
      const card: MappedCard & { imageBlob?: Blob | null } = {
        card_type: layoutItem.type,
        title: link.title || null,
        description: null, // Linktree doesn't have descriptions on links
        url: link.url,
        content: {},
        size: layoutItem.size,
        position: 'left' as HorizontalPosition, // Will flow naturally in our layout
        imageBlob, // Temporary - will be uploaded and replaced with URL
      }

      return { card, index }
    })
  )

  // Separate successes and failures
  const cards: MappedCard[] = []
  const failures: Array<{ index: number; title: string; reason: string }> = []

  for (const result of settledResults) {
    if (result.status === 'fulfilled') {
      const { card, index } = result.value
      // Store imageBlob separately for upload, remove from card object
      const { imageBlob, ...cardData } = card as MappedCard & { imageBlob?: Blob }
      cards.push({ ...cardData, content: { pendingImageBlob: imageBlob } })
    } else {
      const linkIndex = settledResults.indexOf(result)
      failures.push({
        index: linkIndex,
        title: links[linkIndex]?.title || 'Unknown',
        reason: result.reason?.message || 'Unknown error',
      })
    }
  }

  return { cards, failures }
}
```

2. Create `src/app/api/import/linktree/route.ts`:

```typescript
// src/app/api/import/linktree/route.ts
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { scrapeLinktreeProfile, LinktreeNotFoundError, LinktreeEmptyError, LinktreeFetchError } from '@/lib/import/linktree-scraper'
import { mapLinktreeToCards } from '@/lib/import/linktree-mapper'
import { fetchUserPage, createCard } from '@/lib/supabase/cards'
import { generateAppendKey } from '@/lib/ordering'
import type { Card } from '@/types/card'

const BUCKET_NAME = 'card-images'

export async function POST(request: Request) {
  try {
    // Authenticate user
    const page = await fetchUserPage()
    if (!page) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })
    }

    // Get username from request
    const { username, existingCards = [] } = await request.json()
    if (!username || typeof username !== 'string') {
      return NextResponse.json({ error: 'Username is required' }, { status: 400 })
    }

    // Scrape Linktree profile
    const profileData = await scrapeLinktreeProfile(username)

    // Map to our card format
    const { cards: mappedCards, failures } = await mapLinktreeToCards(profileData.links)

    // Create cards in database with images uploaded
    const supabase = await createClient()
    const createdCards: Card[] = []
    let sortKeyBase = existingCards.length > 0
      ? generateAppendKey(existingCards)
      : 'a0'

    for (const mappedCard of mappedCards) {
      try {
        // Upload image if we have one
        let imageUrl: string | undefined
        const pendingBlob = (mappedCard.content as any)?.pendingImageBlob as Blob | undefined

        if (pendingBlob) {
          const fileExt = pendingBlob.type.split('/')[1] || 'jpg'
          const tempId = crypto.randomUUID()
          const fileName = `${tempId}/${crypto.randomUUID()}.${fileExt}`

          const { data: uploadData, error: uploadError } = await supabase.storage
            .from(BUCKET_NAME)
            .upload(fileName, pendingBlob, {
              contentType: pendingBlob.type,
              upsert: false,
            })

          if (!uploadError && uploadData) {
            const { data: urlData } = supabase.storage
              .from(BUCKET_NAME)
              .getPublicUrl(uploadData.path)
            imageUrl = urlData.publicUrl
          }
        }

        // Create the card
        const card = await createCard({
          page_id: page.id,
          card_type: mappedCard.card_type,
          title: mappedCard.title,
          description: mappedCard.description,
          url: mappedCard.url,
          content: imageUrl ? { imageUrl } : {},
          size: mappedCard.size,
          position: mappedCard.position,
          sortKey: sortKeyBase,
          is_visible: true,
        })

        createdCards.push(card)

        // Update sortKey for next card
        sortKeyBase = generateAppendKey([...existingCards, ...createdCards])
      } catch (cardError) {
        console.error('Failed to create card:', cardError)
        failures.push({
          index: mappedCards.indexOf(mappedCard),
          title: mappedCard.title || 'Untitled',
          reason: 'Failed to save card',
        })
      }
    }

    return NextResponse.json({
      success: true,
      imported: createdCards.length,
      failed: failures.length,
      cards: createdCards,
      failures,
    })
  } catch (error) {
    // Handle known error types with user-friendly messages
    if (error instanceof LinktreeNotFoundError) {
      return NextResponse.json({ error: error.message }, { status: 404 })
    }
    if (error instanceof LinktreeEmptyError) {
      return NextResponse.json({ error: error.message }, { status: 404 })
    }
    if (error instanceof LinktreeFetchError) {
      return NextResponse.json({ error: error.message }, { status: 502 })
    }

    console.error('Import error:', error)
    return NextResponse.json(
      { error: 'Failed to import Linktree. Please try again.' },
      { status: 500 }
    )
  }
}
```

Note: The API route handles authentication, scraping, image upload, and card creation in one request. Images are uploaded using the existing storage bucket pattern.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Files exist at correct paths
    - API route file has POST export
  </verify>
  <done>
    - Mapper transforms Linktree links to card format with image download
    - API route orchestrates full import flow
    - Proper error handling with user-friendly messages
    - Images uploaded to Supabase storage
  </done>
</task>

<task type="auto">
  <name>Task 2: Create import dialog and integrate into editor</name>
  <files>
    - src/components/editor/linktree-import-dialog.tsx
    - src/components/editor/cards-tab.tsx
  </files>
  <action>
1. Create `src/components/editor/linktree-import-dialog.tsx`:

```typescript
// src/components/editor/linktree-import-dialog.tsx
'use client'

import { useState } from 'react'
import { Loader2, Download } from 'lucide-react'
import { toast } from 'sonner'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { usePageStore } from '@/stores/page-store'
import type { Card } from '@/types/card'

interface LinktreeImportDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
}

type ImportMode = 'add' | 'replace'

export function LinktreeImportDialog({ open, onOpenChange }: LinktreeImportDialogProps) {
  const [username, setUsername] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [showConfirmDialog, setShowConfirmDialog] = useState(false)
  const [pendingMode, setPendingMode] = useState<ImportMode | null>(null)

  const cards = usePageStore((state) => state.cards)
  const setCards = usePageStore((state) => state.setCards)
  const hasExistingCards = cards.length > 0

  const handleImport = async (mode: ImportMode) => {
    if (!username.trim()) {
      toast.error('Please enter a Linktree username or URL')
      return
    }

    setIsLoading(true)
    setShowConfirmDialog(false)

    try {
      const existingCards = mode === 'add' ? cards : []

      const response = await fetch('/api/import/linktree', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          username: username.trim(),
          existingCards,
        }),
      })

      const data = await response.json()

      if (!response.ok) {
        toast.error(data.error || 'Failed to import')
        return
      }

      // Update store with imported cards
      if (mode === 'replace') {
        setCards(data.cards)
      } else {
        setCards([...cards, ...data.cards])
      }

      // Show success toast
      if (data.failed > 0) {
        toast.success(`Imported ${data.imported} links (${data.failed} failed)`)
      } else {
        toast.success(`Imported ${data.imported} links`)
      }

      // Reset and close
      setUsername('')
      onOpenChange(false)
    } catch (error) {
      console.error('Import error:', error)
      toast.error('Failed to import. Please try again.')
    } finally {
      setIsLoading(false)
    }
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()

    if (!username.trim()) {
      toast.error('Please enter a Linktree username or URL')
      return
    }

    // If user has existing cards, ask what to do
    if (hasExistingCards) {
      setShowConfirmDialog(true)
    } else {
      handleImport('add')
    }
  }

  const handleModeSelect = (mode: ImportMode) => {
    setPendingMode(mode)
    handleImport(mode)
  }

  return (
    <>
      <Dialog open={open && !showConfirmDialog} onOpenChange={onOpenChange}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Import from Linktree</DialogTitle>
            <DialogDescription>
              Enter your Linktree username or URL to import your existing links.
            </DialogDescription>
          </DialogHeader>

          <form onSubmit={handleSubmit}>
            <div className="grid gap-4 py-4">
              <div className="grid gap-2">
                <Label htmlFor="username">Linktree Username or URL</Label>
                <Input
                  id="username"
                  placeholder="artistname or linktr.ee/artistname"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  disabled={isLoading}
                  autoFocus
                />
              </div>
            </div>

            <DialogFooter>
              <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isLoading}>
                Cancel
              </Button>
              <Button type="submit" disabled={isLoading || !username.trim()}>
                {isLoading ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Importing...
                  </>
                ) : (
                  <>
                    <Download className="mr-2 h-4 w-4" />
                    Import
                  </>
                )}
              </Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>

      {/* Confirmation dialog for existing cards */}
      <AlertDialog open={showConfirmDialog} onOpenChange={setShowConfirmDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>You have existing cards</AlertDialogTitle>
            <AlertDialogDescription>
              Would you like to add the imported links to your existing cards, or start fresh?
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter className="flex-col sm:flex-row gap-2">
            <AlertDialogCancel onClick={() => setShowConfirmDialog(false)} disabled={isLoading}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={() => handleModeSelect('add')}
              disabled={isLoading}
              className="bg-secondary text-secondary-foreground hover:bg-secondary/80"
            >
              {isLoading && pendingMode === 'add' ? (
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              ) : null}
              Add to existing
            </AlertDialogAction>
            <AlertDialogAction
              onClick={() => handleModeSelect('replace')}
              disabled={isLoading}
              variant="destructive"
            >
              {isLoading && pendingMode === 'replace' ? (
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              ) : null}
              Start fresh
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  )
}
```

2. Update `src/components/editor/cards-tab.tsx` to add import button:

Add import to the component:
- Import the dialog component
- Add state for dialog open
- Add "Import from Linktree" button next to "Add Card" dropdown
- When canvas is empty, show prominent import prompt

Key changes:
```typescript
// Add imports at top
import { Download } from 'lucide-react'
import { LinktreeImportDialog } from './linktree-import-dialog'

// Add state in component
const [importDialogOpen, setImportDialogOpen] = useState(false)

// Add button in header (next to Add Card dropdown)
<Button size="sm" variant="ghost" onClick={() => setImportDialogOpen(true)}>
  <Download className="h-4 w-4 mr-1" />
  Import
</Button>

// Add dialog at end of component (before closing div)
<LinktreeImportDialog open={importDialogOpen} onOpenChange={setImportDialogOpen} />

// If cards.length === 0, show empty state with prominent import CTA
```

The empty state should show:
- "No cards yet" message
- "Import from Linktree" button (primary)
- "Or add a card manually" link (secondary)
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Dialog component renders without errors
    - Import button visible in cards-tab header
    - Empty state shows import prompt when no cards
  </verify>
  <done>
    - Import dialog with username input
    - Confirmation dialog for existing cards (add vs replace)
    - Loading states and error handling
    - Toast notifications for results
    - Import button in editor header
    - Empty state with prominent import CTA
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify import flow end-to-end</name>
  <what-built>
    Complete Linktree import feature:
    - API route at /api/import/linktree
    - Import dialog with username/URL input
    - Confirmation dialog for existing cards
    - Cards created with randomized types/sizes
    - Thumbnails downloaded and re-uploaded
    - Toast notifications for results
  </what-built>
  <how-to-verify>
    1. Start dev server: `npm run dev`
    2. Navigate to editor (http://localhost:3000/editor)
    3. Click "Import" button in the Cards tab header
    4. Enter a public Linktree username (e.g., "linktree" or another public profile)
    5. Click Import and wait for completion
    6. Verify:
       - Toast shows "Imported X links"
       - Cards appear with VARIED types (hero, horizontal, square) - NOT all the same
       - Cards have different sizes (big/small mix)
       - Thumbnails display where available
       - Card order matches Linktree order
    7. Test error handling:
       - Try an invalid username (e.g., "thisuserdoesnotexist12345")
       - Verify error toast with clear message
    8. Test existing cards flow:
       - If you have cards, try importing again
       - Verify confirmation dialog appears
       - Test "Add to existing" option
       - Test "Start fresh" option
  </how-to-verify>
  <resume-signal>Type "approved" if import works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes
2. API route responds to POST /api/import/linktree
3. Dialog opens and accepts username input
4. Cards are created with varied types and sizes
5. Thumbnails are uploaded to storage
6. Error messages are user-friendly
7. Existing cards flow works (add vs replace)
</verification>

<success_criteria>
- User can enter Linktree username or full URL
- System fetches links from Linktree page
- Cards are created with randomized visual variety (not all horizontal)
- Thumbnails are preserved (downloaded and re-uploaded)
- User sees confirmation dialog if they have existing cards
- Clear error messages for invalid/private/empty profiles
- Toast shows import result count
- Cards appear immediately on canvas after import
</success_criteria>

<output>
After completion, create `.planning/phases/04.2-linktree-import/04.2-02-SUMMARY.md`
</output>
