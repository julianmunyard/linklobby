# Phase 12.1: Scatter Mode - Research

**Researched:** 2026-02-11
**Domain:** Freeform canvas positioning with drag and resize
**Confidence:** HIGH

## Summary

Scatter mode requires implementing freeform absolute positioning alongside the existing dnd-kit flow layout system. The project already uses @dnd-kit/core v6.3.1 for reordering, and the database schema already includes position_x, position_y, width, height, and z_index columns on the cards table.

The standard approach combines **react-rnd** (for free positioning + resize handles) with the existing dnd-kit infrastructure. React-rnd is the de facto library for this use case - it provides both draggable and resizable functionality in a single component with percentage-based sizing support, boundary constraints, and proper touch handling.

The architecture requires conditional rendering: when scatter mode is ON for a theme, render cards with react-rnd in absolute positioning; when OFF, use the existing flow-grid with dnd-kit sortable. Positions are stored as percentages in card.content (theme-specific), while the database's position_x/y columns remain for future use or non-scatter positioning needs.

**Primary recommendation:** Use react-rnd for scatter cards, store scatter layout per-theme in card.content as percentages, keep existing flow-grid untouched for non-scatter themes.

## Standard Stack

The established libraries/tools for freeform canvas positioning in React:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| react-rnd | ^10.4.13 (latest) | Draggable + resizable components | De facto standard combining both drag and resize in one component. Built on react-draggable. 8.7k stars, actively maintained. |
| @dnd-kit/core | ^6.3.1 (existing) | Drag overlay and sensors | Already in project for flow layout. Can reuse sensors for scatter mode activation constraints. |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @use-gesture/react | ^10.3.1 (existing) | Advanced touch gestures | Already in project. Can handle visitor drag on public pages with custom gesture logic. |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| react-rnd | react-draggable + react-resizable | More control but must wire together two libraries. react-rnd already does this integration. |
| react-rnd | dnd-kit only | dnd-kit excels at sortable/list UX but not designed for free canvas positioning or resize handles. Would require custom modifiers. |
| react-rnd | react-grid-layout | Grid-layout is for constrained grid systems (dashboards), not freeform scatter. Overkill for this use case. |

**Installation:**
```bash
npm install react-rnd
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── components/
│   ├── canvas/
│   │   ├── scatter-canvas.tsx          # Scatter mode container
│   │   ├── scatter-card.tsx            # Draggable+resizable wrapper using react-rnd
│   │   ├── flow-grid.tsx               # Existing flow layout (unchanged)
│   │   └── preview-flow-grid.tsx       # Existing preview (unchanged)
│   └── public/
│       ├── static-scatter-canvas.tsx   # Public page scatter layout
│       └── static-flow-grid.tsx        # Existing public flow (unchanged)
├── stores/
│   └── page-store.ts                   # Add scatter layout actions
└── types/
    └── scatter.ts                      # Scatter position/size types
```

### Pattern 1: Conditional Layout Rendering
**What:** Theme determines whether cards render in flow layout or scatter canvas.
**When to use:** Every card grid rendering point (editor preview, public page).
**Example:**
```typescript
// In preview panel
const isScatterTheme = SCATTER_THEMES.includes(themeId)
const scatterEnabled = themeStore.scatterMode && isScatterTheme

return (
  <>
    {scatterEnabled ? (
      <ScatterCanvas cards={cards} />
    ) : (
      <FlowGrid cards={cards} />
    )}
  </>
)
```

### Pattern 2: Per-Theme Scatter Layout Storage
**What:** Each scatter theme stores its own independent layout in card.content.
**When to use:** Saving/loading scatter positions, switching themes.
**Example:**
```typescript
// Card content structure
interface CardContent {
  // Existing content fields...
  scatterLayouts?: {
    'mac-os'?: ScatterPosition
    'instagram-reels'?: ScatterPosition
    'system-settings'?: ScatterPosition
    'macintosh'?: ScatterPosition
    'word-art'?: ScatterPosition
  }
}

interface ScatterPosition {
  x: number        // Percentage (0-100) of canvas width
  y: number        // Percentage (0-100) of canvas height
  width: number    // Percentage (0-100) of canvas width
  height: number   // Percentage (0-100) of canvas height
  zIndex: number   // Last moved = highest
}
```

### Pattern 3: Percentage-Based Positioning
**What:** Store positions as percentages, convert to pixels on render.
**When to use:** All scatter position storage and calculations.
**Example:**
```typescript
// Converting percentage to pixels
const canvasWidth = canvasRef.current.offsetWidth
const canvasHeight = canvasRef.current.offsetHeight

const pixelX = (scatterPos.x / 100) * canvasWidth
const pixelY = (scatterPos.y / 100) * canvasHeight
const pixelWidth = (scatterPos.width / 100) * canvasWidth
const pixelHeight = (scatterPos.height / 100) * canvasHeight

// Converting pixels back to percentage (on drag/resize)
const percentX = (pixelX / canvasWidth) * 100
const percentY = (pixelY / canvasHeight) * 100
const percentWidth = (pixelWidth / canvasWidth) * 100
const percentHeight = (pixelHeight / canvasHeight) * 100
```

### Pattern 4: Z-Index on Move
**What:** Track drag events, update zIndex to bring moved card to front.
**When to use:** OnDragStop and OnResizeStop callbacks.
**Example:**
```typescript
// Track highest z-index
const [maxZIndex, setMaxZIndex] = useState(cards.length)

const handleDragStop = (cardId: string) => {
  const newZIndex = maxZIndex + 1
  updateCardScatterPosition(cardId, { zIndex: newZIndex })
  setMaxZIndex(newZIndex)
}
```

### Pattern 5: Visual Grid Overlay
**What:** CSS grid lines overlaid on canvas when scatter mode active.
**When to use:** Artist dashboard preview only, not public pages.
**Example:**
```typescript
// Grid overlay with CSS
<div className="absolute inset-0 pointer-events-none">
  <div
    className="w-full h-full"
    style={{
      backgroundImage: `
        linear-gradient(to right, rgba(255,255,255,0.1) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,0.1) 1px, transparent 1px)
      `,
      backgroundSize: '8.333% 8.333%' // 12x12 grid
    }}
  />
</div>
```

### Anti-Patterns to Avoid
- **Don't modify existing flow-grid components** - Keep scatter completely separate. Flow layout must remain unchanged for non-scatter themes.
- **Don't use pixel positions in database** - Always store percentages so layouts scale properly across devices.
- **Don't manually manage z-index** - Automatic "last moved on top" is simpler than manual layer controls.
- **Don't use dnd-kit for scatter** - dnd-kit is designed for sortable lists, not free canvas positioning. Use react-rnd instead.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Resize handles on corners/edges | Custom corner divs with pointer events | react-rnd `enableResizing` | Handles all 8 directions (n, s, e, w, ne, nw, se, sw), touch events, aspect ratio locking, min/max size constraints. |
| Boundary constraints | Manual Math.max/Math.min clamping | react-rnd `bounds="parent"` | Handles both drag and resize bounds, prevents overflow during resize, accounts for transform origins. |
| Touch vs mouse drag | Separate pointer event handlers | react-rnd built-in (uses react-draggable) | Already handles touch-action CSS, touchstart/touchmove/touchend, prevents scroll conflicts. |
| Percentage-based sizing | Custom percentage calculations | react-rnd with `size={{ width: '20%', height: '30%' }}` | Native support for percentage units, handles resize with percentages. |
| Click vs drag distinction | Custom pointer move distance tracking | dnd-kit `activationConstraint: { distance: 8 }` | Already using dnd-kit sensors in project. Reuse for public page visitor drag. |

**Key insight:** Combining drag + resize correctly is harder than it looks. React-rnd handles edge cases like: resizing while at boundary edge, touch-action CSS for mobile, handle positioning with transforms, aspect ratio during resize, and coordinate translation between percentage and pixels.

## Common Pitfalls

### Pitfall 1: Touch Scroll Conflicts on Mobile
**What goes wrong:** On mobile, dragging a scatter card triggers page scroll instead of drag. User cannot move cards on touch devices.
**Why it happens:** Default browser behavior interprets touch-drag as scroll. React-rnd needs explicit CSS to override this.
**How to avoid:** Add `touch-action: none` CSS to all draggable/resizable elements AND their parent container.
**Warning signs:** Works on desktop but cards won't drag on iPhone/iPad. Console shows no errors.
**Code:**
```css
.scatter-canvas {
  touch-action: none;
}

.scatter-card {
  touch-action: none;
}
```

### Pitfall 2: Parent Bounds Break on Window Resize
**What goes wrong:** Cards are constrained to bounds on initial render, but after window resize, cards can be dragged outside the canvas.
**Why it happens:** react-rnd calculates bounds dimensions once. Window resize changes canvas size but bounds are not recalculated.
**How to avoid:** Add window resize listener to remount scatter canvas or force react-rnd bounds recalculation.
**Warning signs:** Drag bounds work initially, then after rotating device or resizing browser, cards escape canvas.
**Code:**
```typescript
const [boundsKey, setBoundsKey] = useState(0)

useEffect(() => {
  const handleResize = () => setBoundsKey(k => k + 1)
  window.addEventListener('resize', handleResize)
  return () => window.removeEventListener('resize', handleResize)
}, [])

// Force remount on resize
<div key={boundsKey}>
  {cards.map(card => <Rnd bounds="parent" ... />)}
</div>
```

### Pitfall 3: Percentage Positions Break on Theme Switch
**What goes wrong:** Switching from scatter theme to flow theme and back loses card positions or shows cards in wrong locations.
**Why it happens:** Not storing positions per-theme. Single position stored for all themes causes collision.
**How to avoid:** Store scatter positions as object keyed by themeId in card.content.scatterLayouts.
**Warning signs:** Arranging cards in Mac OS theme, switching to iPod (flow), switching back to Mac OS shows cards in different positions.
**Code:**
```typescript
// WRONG: Single position for all themes
content: { scatterX: 20, scatterY: 30 }

// CORRECT: Per-theme positions
content: {
  scatterLayouts: {
    'mac-os': { x: 20, y: 30, width: 25, height: 15, zIndex: 1 },
    'instagram-reels': { x: 50, y: 40, width: 30, height: 20, zIndex: 2 }
  }
}
```

### Pitfall 4: Click vs Drag on Public Pages Breaks Links
**What goes wrong:** With visitor drag enabled, clicking cards follows the link immediately even when user intended to drag. OR dragging requires long-press which feels unresponsive.
**Why it happens:** Activation threshold too low (clicks become drags) or too high (drags feel delayed).
**How to avoid:** Use dnd-kit's MouseSensor with `distance: 8px` constraint. This allows instant click-to-follow-link while requiring 8px movement to activate drag. No delay needed.
**Warning signs:** Users complain "clicking doesn't work" or "dragging feels laggy".
**Code:**
```typescript
// Public page visitor drag (if enabled)
const sensors = useSensors(
  useSensor(MouseSensor, {
    activationConstraint: { distance: 8 } // 8px threshold
  }),
  useSensor(TouchSensor, {
    activationConstraint: {
      delay: 250,      // Touch needs delay for precision
      tolerance: 5     // Allow 5px drift during delay
    }
  })
)
```

### Pitfall 5: Percentage Width/Height Become Pixel Locks
**What goes wrong:** Cards resize freely, save, but on reload cards are locked to pixel dimensions and don't scale with canvas.
**Why it happens:** React-rnd returns pixel dimensions in onResize. If you save pixels instead of converting back to percentages, layout becomes fixed.
**How to avoid:** Always convert pixel values back to percentages before saving to database.
**Warning signs:** Layout looks correct on desktop, but on mobile cards are tiny or huge. Window resize doesn't scale cards proportionally.
**Code:**
```typescript
const handleResizeStop = (cardId: string, ref: HTMLElement) => {
  const canvas = canvasRef.current
  const pixelWidth = ref.offsetWidth
  const pixelHeight = ref.offsetHeight

  // WRONG: Save pixels
  // updateCard(cardId, { width: pixelWidth, height: pixelHeight })

  // CORRECT: Convert to percentages
  const percentWidth = (pixelWidth / canvas.offsetWidth) * 100
  const percentHeight = (pixelHeight / canvas.offsetHeight) * 100
  updateCard(cardId, { width: percentWidth, height: percentHeight })
}
```

## Code Examples

Verified patterns from official sources:

### react-rnd Basic Setup
```typescript
// Source: https://github.com/bokuweb/react-rnd
import { Rnd } from 'react-rnd'

<Rnd
  size={{ width: '25%', height: '20%' }}      // Percentage sizing
  position={{ x: 100, y: 50 }}                // Pixel position (convert from %)
  onDragStop={(e, d) => {
    // d.x, d.y are pixel positions
    savePosition(cardId, d.x, d.y)
  }}
  onResizeStop={(e, dir, ref, delta, position) => {
    // ref.offsetWidth, ref.offsetHeight are pixel dimensions
    saveSize(cardId, ref.offsetWidth, ref.offsetHeight)
  }}
  bounds="parent"                              // Constrain to parent
  enableResizing={{
    top: true,
    right: true,
    bottom: true,
    left: true,
    topRight: true,
    bottomRight: true,
    bottomLeft: true,
    topLeft: true,
  }}
  style={{ touchAction: 'none' }}              // Critical for mobile
>
  <CardRenderer card={card} />
</Rnd>
```

### Bringing Card to Front on Drag
```typescript
// Track highest z-index
const [maxZIndex, setMaxZIndex] = useState(
  Math.max(...cards.map(c => c.content.scatterLayouts?.[themeId]?.zIndex || 0))
)

const handleDragStop = (cardId: string) => {
  const newZIndex = maxZIndex + 1
  updateCard(cardId, {
    content: {
      ...card.content,
      scatterLayouts: {
        ...card.content.scatterLayouts,
        [themeId]: {
          ...card.content.scatterLayouts[themeId],
          zIndex: newZIndex
        }
      }
    }
  })
  setMaxZIndex(newZIndex)
}
```

### Grid Overlay (Optional Alignment)
```typescript
// Claude discretion: 12x12 grid with subtle white lines
<div className="absolute inset-0 pointer-events-none z-10">
  <div
    className="w-full h-full opacity-30"
    style={{
      backgroundImage: `
        linear-gradient(to right, rgba(255,255,255,0.15) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,0.15) 1px, transparent 1px)
      `,
      backgroundSize: '8.333% 8.333%', // 12 columns/rows
    }}
  />
</div>
```

### Public Page Visitor Drag (Optional)
```typescript
// Source: dnd-kit activation constraints best practices
// Use existing @dnd-kit/core infrastructure for visitor drag
import { DndContext, MouseSensor, TouchSensor, useSensor, useSensors } from '@dnd-kit/core'

// Public page component
const visitorDragEnabled = pageSettings.scatterVisitorDrag

const sensors = useSensors(
  useSensor(MouseSensor, {
    activationConstraint: { distance: 8 } // 8px = click, more = drag
  }),
  useSensor(TouchSensor, {
    activationConstraint: {
      delay: 250,      // 250ms hold before drag (touch precision)
      tolerance: 5     // Allow 5px drift during hold
    }
  })
)

// Visitor positions stored in component state, not saved
const [visitorPositions, setVisitorPositions] = useState<Record<string, Position>>({})

const handleDragEnd = (event) => {
  const { active, delta } = event
  setVisitorPositions(prev => ({
    ...prev,
    [active.id]: {
      x: (prev[active.id]?.x || artistPosition.x) + delta.x,
      y: (prev[active.id]?.y || artistPosition.y) + delta.y
    }
  }))
}

// Positions reset on page refresh (ephemeral)
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| react-draggable + react-resizable separately | react-rnd (combines both) | ~2018 | Single component, better integration, less wiring. |
| Pixel-based positioning | Percentage-based responsive layouts | ~2020 | Mobile-first design, layout scales across devices. |
| Manual z-index layer controls | Automatic "last moved on top" | 2024+ design tools | Simpler UX, matches Figma/Canva behavior. |
| dnd-kit for all drag needs | dnd-kit for sortables, react-rnd for canvas | Current | Each library optimized for its use case. |

**Deprecated/outdated:**
- react-draggable alone: Still maintained but react-rnd adds resize handles with better integration.
- react-grid-layout for freeform: Grid-layout is for dashboard grids, not scatter/freeform positioning.

## Open Questions

Things that couldn't be fully resolved:

1. **Default Card Size on Scatter Activation**
   - What we know: Cards need initial width/height percentages when scatter mode first enabled for a theme.
   - What's unclear: Should default size match card's flow-layout visual size, or use fixed percentages like 25% width x 20% height?
   - Recommendation: Use card type-based defaults. Hero cards start at 40% width, small cards start at 25% width. Heights maintain aspect ratio based on card content.

2. **Grid Overlay Spacing**
   - What we know: Visual grid helps artists align cards optionally.
   - What's unclear: Grid spacing (8x8, 12x12, 16x16) and whether it should be configurable.
   - Recommendation: Start with 12x12 grid (8.333% spacing). Do not make configurable initially - adds UI complexity with minimal value.

3. **Resize Handle Visibility**
   - What we know: react-rnd provides resize handles on hover by default.
   - What's unclear: Should handles always be visible or only on selection/hover?
   - Recommendation: Handles visible on hover (react-rnd default behavior). Selected card gets highlighted border + always-visible handles.

## Sources

### Primary (HIGH confidence)
- [react-rnd GitHub](https://github.com/bokuweb/react-rnd) - Official documentation, examples, API reference
- [react-rnd npm](https://www.npmjs.com/package/react-rnd) - Installation, version compatibility
- [dnd-kit Touch Sensor docs](https://docs.dndkit.com/api-documentation/sensors/touch) - Activation constraints best practices
- [dnd-kit Mouse Sensor docs](https://docs.dndkit.com/api-documentation/sensors/mouse) - Distance vs delay activation

### Secondary (MEDIUM confidence)
- [Top 5 Drag-and-Drop Libraries for React in 2026](https://puckeditor.com/blog/top-5-drag-and-drop-libraries-for-react) - Library comparison, modern stack recommendations
- [React Rnd Essentials: Creating Responsive, Draggable Elements](https://www.dhiwise.com/post/guide-for-creating-responsive-elements-with-react-rnd) - Implementation patterns
- [Konva.js Responsive Canvas Demo](https://konvajs.org/docs/sandbox/Responsive_Canvas.html) - Percentage-based canvas positioning patterns
- [Understanding Success Criterion 2.5.7: Dragging Movements - W3C](https://www.w3.org/WAI/WCAG22/Understanding/dragging-movements.html) - Accessibility considerations for drag interactions

### Tertiary (LOW confidence)
- [react-rnd touch-action mobile issues](https://github.com/bokuweb/react-rnd/issues/391) - Community-reported mobile drag issues, requires verification
- [react-rnd bounds parent issues](https://github.com/bokuweb/react-rnd/issues/714) - Known limitations with parent bounds on resize, may be fixed in latest version

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - react-rnd is the established solution, actively maintained, proven in production
- Architecture: HIGH - Patterns verified from official docs and existing project structure
- Pitfalls: HIGH - Documented in react-rnd issues and dnd-kit discussions, verified solutions exist
- Percentage positioning: MEDIUM - Pattern is standard but requires testing with react-rnd's percentage support
- Mobile touch handling: MEDIUM - CSS touch-action solution is documented but needs testing with React 19

**Research date:** 2026-02-11
**Valid until:** ~30 days (stable libraries, infrequent breaking changes)

**Key decision points for planner:**
1. Store scatter positions in card.content.scatterLayouts[themeId], NOT database position_x/y columns
2. Use react-rnd for scatter cards, keep existing flow-grid unchanged
3. Default card sizes based on card type (hero=40%, square=25%, etc.)
4. Grid overlay: 12x12, non-configurable initially
5. Visitor drag uses dnd-kit sensors with distance: 8px activation
6. Always add touch-action: none to prevent mobile scroll conflicts
