# Phase 12.5: Billing & Subscriptions - Research

**Researched:** 2026-02-25
**Domain:** Stripe Billing + Supabase + Next.js App Router subscription management
**Confidence:** HIGH (core Stripe patterns), MEDIUM (schema design), HIGH (Next.js integration patterns)

---

## Summary

This phase implements Stripe-powered subscription billing for LinkLobby's Free / Pro / Artist tiers. The locked decisions specify Stripe Checkout (hosted page), a minimal in-app billing section with Stripe Customer Portal for heavy lifting, a soft-lock paywall model (pro features visible in editor but stripped from public page), and 7-day free trial.

The standard stack is well-established: `stripe` (server-side SDK) + `@stripe/stripe-js` (client-side, only needed if using Stripe Elements — not required for Checkout). Webhooks are the critical path for keeping subscription state in sync; the Next.js App Router uses `await request.text()` (not `.json()`) for raw body access required by signature verification. The Vercel `nextjs-subscription-payments` repo is the canonical reference architecture for this exact stack (Next.js + Supabase + Stripe).

The biggest implementation complexity is not Stripe itself but **plan gating across the editor**: every Pro feature must be wrapped in a check that either shows a Pro badge (editor view) or strips the feature (public page render). Database schema should store subscription state locally (synced via webhooks) rather than calling Stripe on every request.

**Primary recommendation:** Sync Stripe subscription data to Supabase via webhooks. Gate features by checking the local `subscriptions` table, never by calling the Stripe API at render time.

---

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `stripe` | ^17.x (latest) | Server-side Stripe SDK — checkout sessions, webhooks, customer portal | Official Stripe Node.js library |
| `@stripe/stripe-js` | ^5.x (latest) | Client-side Stripe.js loader | Required for Stripe Elements; minimal use with hosted Checkout |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `@stripe/react-stripe-js` | ^3.x | React wrappers for Stripe Elements | Only if building custom payment forms — NOT needed for hosted Checkout |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Stripe Checkout (hosted) | Stripe Elements (custom UI) | Elements gives full UI control but requires PCI compliance handling; Checkout is faster to ship and already decided |
| Supabase local subscription table | Call Stripe API on every request | Local table is fast and resilient; Stripe API adds latency and rate-limit risk |
| Stripe Customer Portal | Custom billing UI | Portal handles invoices, payment methods, cancellation — no custom code needed for these |

**Installation:**

```bash
npm install stripe @stripe/stripe-js
```

**Environment variables to add:**

```bash
STRIPE_SECRET_KEY=sk_live_...          # Server only — never expose
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_live_...  # Client-safe
STRIPE_WEBHOOK_SECRET=whsec_...        # Server only — from Stripe Dashboard or CLI
```

---

## Architecture Patterns

### Recommended Project Structure

```
src/
├── lib/
│   └── stripe/
│       ├── client.ts           # Singleton Stripe instance (server)
│       ├── plans.ts            # Plan definitions (tier names, price IDs, features)
│       └── subscription.ts     # Helper: get user's active plan from DB
├── app/
│   ├── api/
│   │   ├── billing/
│   │   │   ├── checkout/route.ts       # POST: create Checkout Session
│   │   │   └── portal/route.ts         # POST: create Customer Portal session
│   │   └── webhooks/
│   │       └── stripe/route.ts         # POST: handle Stripe events
│   ├── pricing/
│   │   └── page.tsx                    # Public pricing page (Free/Pro/Artist)
│   └── (dashboard)/
│       └── settings/
│           └── billing/
│               └── page.tsx            # Minimal in-app billing section
└── components/
    └── billing/
        ├── plan-badge.tsx              # 'Free'/'Pro'/'Artist' pill — sidebar + header
        ├── upgrade-modal.tsx           # Contextual upgrade prompt
        ├── pricing-table.tsx           # Feature comparison table
        └── pro-gate.tsx               # Wrapper: shows Pro badge or strips content
```

### Pattern 1: Stripe Client Singleton

**What:** One Stripe instance shared across all server-side calls. Never instantiate per-request.

```typescript
// src/lib/stripe/client.ts
import Stripe from 'stripe'

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2025-03-31.basil', // pin to a specific version
  typescript: true,
})
```

### Pattern 2: Create Checkout Session (Route Handler)

**What:** Server-side route handler that creates a Stripe Checkout Session for subscription.

```typescript
// src/app/api/billing/checkout/route.ts
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { stripe } from '@/lib/stripe/client'

export async function POST(request: Request) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

  const { priceId } = await request.json()

  // Look up or create Stripe customer
  const { data: customer } = await supabase
    .from('customers')
    .select('stripe_customer_id')
    .eq('user_id', user.id)
    .single()

  const customerId = customer?.stripe_customer_id ?? undefined

  const session = await stripe.checkout.sessions.create({
    customer: customerId,
    customer_email: customerId ? undefined : user.email,
    mode: 'subscription',
    line_items: [{ price: priceId, quantity: 1 }],
    // 7-day trial — no card required upfront (recommended: card-free trial for lower friction)
    subscription_data: {
      trial_period_days: 7,
      trial_settings: {
        end_behavior: { missing_payment_method: 'cancel' }
      },
      metadata: { user_id: user.id },
    },
    success_url: `${process.env.NEXT_PUBLIC_APP_URL}/settings/billing?success=true`,
    cancel_url: `${process.env.NEXT_PUBLIC_APP_URL}/pricing`,
    metadata: { user_id: user.id }, // Required to link session back to user in webhook
  })

  return NextResponse.json({ url: session.url })
}
```

### Pattern 3: Webhook Handler — Raw Body + Signature Verification

**Critical:** Use `await request.text()` not `await request.json()`. JSON parsing corrupts the raw body needed for signature verification.

```typescript
// src/app/api/webhooks/stripe/route.ts
import { NextResponse } from 'next/server'
import { stripe } from '@/lib/stripe/client'
import { createAdminClient } from '@/lib/supabase/admin' // service_role key

export async function POST(request: Request) {
  const body = await request.text()  // MUST be .text(), not .json()
  const sig = request.headers.get('stripe-signature')!

  let event: Stripe.Event
  try {
    event = stripe.webhooks.constructEvent(body, sig, process.env.STRIPE_WEBHOOK_SECRET!)
  } catch (err) {
    return NextResponse.json({ error: 'Webhook signature verification failed' }, { status: 400 })
  }

  // Idempotency: skip if already processed
  const supabase = createAdminClient()
  const { data: existing } = await supabase
    .from('webhook_events')
    .select('id')
    .eq('stripe_event_id', event.id)
    .single()

  if (existing) return NextResponse.json({ received: true })

  // Record event (idempotency key)
  await supabase.from('webhook_events').insert({ stripe_event_id: event.id })

  // Handle events
  switch (event.type) {
    case 'checkout.session.completed': {
      const session = event.data.object as Stripe.Checkout.Session
      if (session.mode === 'subscription') {
        await syncSubscription(session.subscription as string, session.metadata?.user_id)
      }
      break
    }
    case 'customer.subscription.created':
    case 'customer.subscription.updated':
    case 'customer.subscription.deleted': {
      const sub = event.data.object as Stripe.Subscription
      await syncSubscription(sub.id, sub.metadata?.user_id)
      break
    }
    case 'invoice.paid':
    case 'invoice.payment_failed': {
      const invoice = event.data.object as Stripe.Invoice
      if (invoice.subscription) {
        await syncSubscription(invoice.subscription as string)
      }
      break
    }
  }

  return NextResponse.json({ received: true })
}
```

### Pattern 4: Customer Portal Session

```typescript
// src/app/api/billing/portal/route.ts
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { stripe } from '@/lib/stripe/client'

export async function POST() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

  const { data: customer } = await supabase
    .from('customers')
    .select('stripe_customer_id')
    .eq('user_id', user.id)
    .single()

  if (!customer?.stripe_customer_id) {
    return NextResponse.json({ error: 'No billing account found' }, { status: 404 })
  }

  const session = await stripe.billingPortal.sessions.create({
    customer: customer.stripe_customer_id,
    return_url: `${process.env.NEXT_PUBLIC_APP_URL}/settings/billing`,
  })

  return NextResponse.json({ url: session.url })
}
```

### Pattern 5: Subscription Status Helper

```typescript
// src/lib/stripe/subscription.ts
import { createClient } from '@/lib/supabase/server'

export type PlanTier = 'free' | 'pro' | 'artist'

export async function getUserPlan(userId: string): Promise<PlanTier> {
  const supabase = await createClient()
  const { data } = await supabase
    .from('subscriptions')
    .select('status, plan_tier, current_period_end, trial_end, cancel_at_period_end')
    .eq('user_id', userId)
    .single()

  if (!data) return 'free'

  // Active or trialing = has access
  if (data.status === 'active' || data.status === 'trialing') {
    return data.plan_tier as PlanTier
  }

  // Canceled but still within billing period
  if (data.cancel_at_period_end && data.current_period_end > new Date().toISOString()) {
    return data.plan_tier as PlanTier
  }

  return 'free'
}

export function isPro(tier: PlanTier) {
  return tier === 'pro' || tier === 'artist'
}

export function isArtist(tier: PlanTier) {
  return tier === 'artist'
}
```

### Pattern 6: Pro Gate Component (Editor)

**What:** Wraps editor controls that are Pro-only. Shows a "Pro" badge overlay in editor but doesn't block interaction. On public page, the feature is stripped at render time (not via this component).

```typescript
// src/components/billing/pro-gate.tsx
'use client'

import { Crown } from 'lucide-react'
import { cn } from '@/lib/utils'

interface ProGateProps {
  children: React.ReactNode
  isPro: boolean
  className?: string
}

export function ProGate({ children, isPro, className }: ProGateProps) {
  if (isPro) return <>{children}</>

  return (
    <div className={cn('relative', className)}>
      {children}
      <div className="absolute top-1 right-1 z-10">
        <span className="flex items-center gap-1 rounded-full bg-amber-500 px-1.5 py-0.5 text-[10px] font-semibold text-white">
          <Crown className="h-2.5 w-2.5" />
          Pro
        </span>
      </div>
    </div>
  )
}
```

### Anti-Patterns to Avoid

- **Calling Stripe API at render time:** Never call `stripe.subscriptions.retrieve()` in a Server Component or middleware. Always read from local DB.
- **Using `request.json()` in webhook handler:** This consumes the body and corrupts the raw bytes needed for signature verification. Always use `request.text()`.
- **Storing subscription state only in Stripe:** Stripe is the source of truth but local DB is the cache. Gate access from local DB.
- **Blocking features immediately on cancellation:** Users keep access until `current_period_end`. Don't downgrade on the `customer.subscription.deleted` event alone — check the period end.
- **Skipping idempotency:** Stripe delivers webhooks at least once. Without idempotency checks, a retry fires duplicate email sends, duplicate DB inserts, etc.
- **Wrong webhook secret:** Dashboard webhook secret ≠ CLI webhook secret. Mixing them causes all verifications to fail.
- **JSON middleware eating body before webhook route:** Not an issue in Next.js App Router (no global middleware), but in Express this would break signature verification.

---

## Database Schema

### Tables to Create (Supabase Migration)

```sql
-- Stripe customer ID mapping (private — no RLS public access)
CREATE TABLE customers (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  stripe_customer_id TEXT UNIQUE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Subscription state (synced from Stripe via webhooks)
CREATE TABLE subscriptions (
  id TEXT PRIMARY KEY,                    -- Stripe subscription ID (sub_xxx)
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  plan_tier TEXT NOT NULL DEFAULT 'free', -- 'free' | 'pro' | 'artist'
  status TEXT NOT NULL,                   -- Stripe status enum (active, trialing, past_due, canceled, etc.)
  price_id TEXT,                          -- Stripe price ID
  current_period_start TIMESTAMPTZ,
  current_period_end TIMESTAMPTZ,
  trial_start TIMESTAMPTZ,
  trial_end TIMESTAMPTZ,
  cancel_at_period_end BOOLEAN DEFAULT FALSE,
  canceled_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Idempotency table to prevent duplicate webhook processing
CREATE TABLE webhook_events (
  stripe_event_id TEXT PRIMARY KEY,
  processed_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for fast user lookup
CREATE INDEX subscriptions_user_id_idx ON subscriptions(user_id);

-- RLS: users can only see their own subscription
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own subscription"
  ON subscriptions FOR SELECT
  USING (user_id = auth.uid());

ALTER TABLE customers ENABLE ROW LEVEL SECURITY;
-- No public policies on customers — accessed via service role in webhooks only
```

**Note:** The Vercel `nextjs-subscription-payments` schema also includes `products` and `prices` tables synced from Stripe. For LinkLobby, since we have a fixed 3-tier model with known price IDs (not a dynamic catalog), syncing products/prices to DB is optional — hardcode plan definitions in `src/lib/stripe/plans.ts` instead.

### Plan Definitions (Hardcoded)

```typescript
// src/lib/stripe/plans.ts
export const PLANS = {
  free: {
    tier: 'free' as const,
    name: 'Free',
    priceMonthly: null,
    priceAnnual: null,
    stripePriceIdMonthly: null,
    stripePriceIdAnnual: null,
    features: {
      removeBranding: false,
      emailCollection: false,
      qrCodes: false,
      facebookPixel: false,
      googleAnalytics: false,
      linkScheduling: false,
      releaseMode: false,
      customDomain: false,
      geoAnalytics: false,
      tourDates: false,
    }
  },
  pro: {
    tier: 'pro' as const,
    name: 'Pro',
    priceMonthly: 1200,   // cents
    priceAnnual: 11500,   // cents (~$115/yr, ~20% discount)
    stripePriceIdMonthly: process.env.STRIPE_PRO_MONTHLY_PRICE_ID!,
    stripePriceIdAnnual: process.env.STRIPE_PRO_ANNUAL_PRICE_ID!,
    features: {
      removeBranding: true,
      emailCollection: true,
      qrCodes: true,
      facebookPixel: true,
      googleAnalytics: true,
      linkScheduling: true,
      releaseMode: true,
      customDomain: false,
      geoAnalytics: false,
      tourDates: false,
    }
  },
  artist: {
    tier: 'artist' as const,
    name: 'Artist',
    priceMonthly: 2000,   // cents
    priceAnnual: 19200,   // cents
    stripePriceIdMonthly: process.env.STRIPE_ARTIST_MONTHLY_PRICE_ID!,
    stripePriceIdAnnual: process.env.STRIPE_ARTIST_ANNUAL_PRICE_ID!,
    features: {
      removeBranding: true,
      emailCollection: true,
      qrCodes: true,
      facebookPixel: true,
      googleAnalytics: true,
      linkScheduling: true,
      releaseMode: true,
      customDomain: true,
      geoAnalytics: true,
      tourDates: true,
    }
  }
} as const
```

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Invoice history | Custom invoice listing UI | Stripe Customer Portal | Portal has download links, pagination, formatting — free |
| Payment method management | Card update form | Stripe Customer Portal | PCI compliance, card validation, 3DS challenges all handled |
| Dunning/retry logic | Cron job that retries failed payments | Stripe's built-in Smart Retries | Stripe uses ML to pick optimal retry times; 15-25% better recovery |
| Proration calculation | Math on billing periods | Stripe handles automatically on plan changes | Edge cases (trial, annual vs monthly, mid-cycle) are numerous |
| Subscription email receipts | Transactional email for invoices | Stripe sends receipt emails automatically | Stripe handles receipt templating, tax lines, etc. |
| Webhook signature verification | Custom HMAC | `stripe.webhooks.constructEvent()` | Handles timing attacks, tolerates clock skew |

**Key insight:** Stripe Customer Portal replaces roughly 80% of what would otherwise be a custom billing UI. The only custom UI needed is: pricing page, plan badge, upgrade modal, and minimal billing info display in Settings.

---

## Common Pitfalls

### Pitfall 1: Webhook Body Parsing in Next.js App Router

**What goes wrong:** Calling `await request.json()` in the webhook route handler before `constructEvent()`. The body is consumed and the raw bytes are lost.
**Why it happens:** Developers follow normal API route patterns where `.json()` is standard.
**How to avoid:** Use `await request.text()` in the webhook handler specifically. Pass the string directly to `constructEvent()`.
**Warning signs:** `"No signatures found matching the expected signature for payload"` error in logs.

```typescript
// WRONG
const body = await request.json() // kills signature verification
// CORRECT
const body = await request.text() // preserves raw bytes
```

### Pitfall 2: Wrong Webhook Secret

**What goes wrong:** Using the Stripe Dashboard endpoint secret when testing with the CLI (or vice versa).
**Why it happens:** Stripe CLI generates its own `whsec_` secret for local testing that differs from the Dashboard's secret.
**How to avoid:** Two separate env vars: `STRIPE_WEBHOOK_SECRET_DEV` (CLI, local) and `STRIPE_WEBHOOK_SECRET` (production Dashboard). Switch based on `NODE_ENV`.
**Warning signs:** Webhook verification consistently fails locally but works in production (or vice versa).

### Pitfall 3: Missing `user_id` in Webhook Context

**What goes wrong:** The webhook receives a subscription event but can't link it to a LinkLobby user.
**Why it happens:** Stripe doesn't know about LinkLobby users — you must embed `user_id` in metadata when creating the Checkout Session or the Subscription.
**How to avoid:**
1. Pass `metadata: { user_id }` to `checkout.sessions.create()`
2. Pass `subscription_data.metadata: { user_id }` so it propagates to the subscription object
3. Alternatively, look up user by `stripe_customer_id` from the `customers` table
**Warning signs:** Webhook logs show events processed but no DB rows updated.

### Pitfall 4: Immediate Access Cutoff on Cancel

**What goes wrong:** Revoking Pro access the moment `customer.subscription.deleted` fires.
**Why it happens:** Treating "deleted" as "access revoked now."
**How to avoid:** When a user cancels, Stripe sends `customer.subscription.updated` with `cancel_at_period_end: true` first. Actual deletion fires at period end. Always check `current_period_end > now()` — if the period hasn't ended yet and `cancel_at_period_end` is true, the user still has paid access.
**Warning signs:** Users report losing Pro access immediately after canceling.

### Pitfall 5: Calling Stripe API in Middleware

**What goes wrong:** Checking subscription status by calling `stripe.subscriptions.list()` in Next.js middleware to gate routes.
**Why it happens:** Middleware seems like a natural place for auth/access checks.
**How to avoid:** Middleware runs on every request — Stripe API calls add 100-300ms latency and risk rate limiting. Read subscription status from Supabase (local DB) in middleware instead. Better yet: since the paywall model is soft-lock (Pro features visible in editor, just not live on public page), middleware-level gating is mostly unnecessary.
**Warning signs:** Editor feels slow; Stripe rate limit errors appear in logs.

### Pitfall 6: Trial Without Card — Edge Cases

**What goes wrong:** User starts no-card trial, trial ends, subscription auto-cancels silently. User doesn't realize they need to add a card.
**Why it happens:** `trial_settings.end_behavior.missing_payment_method = 'cancel'` silently terminates.
**How to avoid:**
1. Listen for `customer.subscription.trial_will_end` (fires 3 days before end) — send a "your trial ends in 3 days" email prompting card add
2. Show a persistent in-app banner during trial with days remaining and "Add payment method" CTA
**Warning signs:** Trial conversion rates near 0%.

### Pitfall 7: Supabase Admin Client vs Regular Client in Webhooks

**What goes wrong:** Webhook handler uses the regular Supabase client (anon key + RLS). RLS blocks inserts because there's no authenticated user in the webhook context.
**Why it happens:** Copy-pasting the regular client setup into the webhook handler.
**How to avoid:** Webhooks must use the Supabase service role client (`SUPABASE_SERVICE_ROLE_KEY`) which bypasses RLS.

```typescript
// src/lib/supabase/admin.ts
import { createClient } from '@supabase/supabase-js'
export function createAdminClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!, // server-only, never expose
  )
}
```

---

## Code Examples

### Create Checkout Session (client-side trigger)

```typescript
// Component button that initiates upgrade
async function handleUpgrade(priceId: string) {
  const response = await fetch('/api/billing/checkout', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ priceId }),
  })
  const { url } = await response.json()
  window.location.href = url // redirect to Stripe hosted page
}
```

### Sync Subscription Helper (called from webhook)

```typescript
async function syncSubscription(subscriptionId: string, userId?: string) {
  const sub = await stripe.subscriptions.retrieve(subscriptionId)
  const supabase = createAdminClient()

  // Resolve user_id from metadata or customer lookup
  const resolvedUserId = userId
    ?? sub.metadata?.user_id
    ?? await getUserIdByStripeCustomer(sub.customer as string)

  if (!resolvedUserId) {
    console.error('Could not resolve user_id for subscription', subscriptionId)
    return
  }

  // Determine plan tier from price ID
  const priceId = sub.items.data[0]?.price.id
  const tier = getPlanTierByPriceId(priceId) // 'pro' | 'artist'

  await supabase.from('subscriptions').upsert({
    id: sub.id,
    user_id: resolvedUserId,
    plan_tier: sub.status === 'active' || sub.status === 'trialing' ? tier : 'free',
    status: sub.status,
    price_id: priceId,
    current_period_start: new Date(sub.current_period_start * 1000).toISOString(),
    current_period_end: new Date(sub.current_period_end * 1000).toISOString(),
    trial_start: sub.trial_start ? new Date(sub.trial_start * 1000).toISOString() : null,
    trial_end: sub.trial_end ? new Date(sub.trial_end * 1000).toISOString() : null,
    cancel_at_period_end: sub.cancel_at_period_end,
    canceled_at: sub.canceled_at ? new Date(sub.canceled_at * 1000).toISOString() : null,
    updated_at: new Date().toISOString(),
  }, { onConflict: 'id' })

  // Also ensure customer mapping exists
  await supabase.from('customers').upsert({
    user_id: resolvedUserId,
    stripe_customer_id: sub.customer as string,
  }, { onConflict: 'user_id' })
}
```

### Plan Badge Component (sidebar)

```typescript
// src/components/billing/plan-badge.tsx
import Link from 'next/link'
import { cn } from '@/lib/utils'
import type { PlanTier } from '@/lib/stripe/subscription'

const tierStyles: Record<PlanTier, string> = {
  free: 'bg-muted text-muted-foreground',
  pro: 'bg-amber-500/20 text-amber-700 dark:text-amber-400',
  artist: 'bg-purple-500/20 text-purple-700 dark:text-purple-400',
}

const tierLabels: Record<PlanTier, string> = {
  free: 'Free',
  pro: 'Pro',
  artist: 'Artist',
}

export function PlanBadge({ tier }: { tier: PlanTier }) {
  return (
    <Link href="/pricing">
      <span className={cn(
        'inline-flex items-center rounded-full px-2 py-0.5 text-xs font-medium cursor-pointer hover:opacity-80 transition-opacity',
        tierStyles[tier]
      )}>
        {tierLabels[tier]}
      </span>
    </Link>
  )
}
```

### Public Page: Strip Pro Features at Render Time

```typescript
// In public page renderer — check plan before rendering pro features
const plan = await getUserPlan(page.user_id)
const hasProAccess = isPro(plan)

// Example: strip "Powered by LinkLobby" branding for Pro users
{!hasProAccess && <PoweredByFooter />}

// Example: strip email collection card from public page for free users
{hasProAccess && card.card_type === 'email_collection' && (
  <EmailCollectionCard card={card} />
)}
```

---

## Trial Period Recommendation (Claude's Discretion)

**Recommendation: No-card 7-day trial** (Stripe's `payment_method_collection: 'if_required'`)

Rationale:
- LinkLobby's core value (themes, templates, audio cards) is visible to free users already — the paid features (remove branding, email collection, pixels) require a bit of setup to appreciate. Requiring a card upfront would discourage exploring them.
- Artists are a skeptical audience — high friction at trial start kills conversion
- Stripe's `trial_settings.end_behavior.missing_payment_method: 'cancel'` cleanly handles no-shows
- 3-day-before-end email from `customer.subscription.trial_will_end` is a natural conversion moment

If conversion rates are low after launch, adding card-required trial is a quick Stripe Dashboard change (no code change needed).

## Theme Gating Recommendations (Claude's Discretion)

Pro-only themes should be the most visually distinctive and complex ones. Suggested split:

**Free themes:** Simpler themes that showcase the product without being the "wow" tier
- flow-grid themes, basic phone-home layouts, simpler system-settings themes

**Pro-only themes:** High-wow-factor differentiators
- Lanyard Badge (most distinctive)
- Any theme using 3D/WebGL (React Three Fiber themes)
- Departures Board (if implemented)
- Complex animated themes

The exact split should be decided during implementation, balancing "enough value to upgrade" vs "enough value to sign up free."

---

## Edge Cases and Handling

### Failed Payments

| Event | Action |
|-------|--------|
| `invoice.payment_failed` | Update `subscriptions.status` to `past_due` in DB. Show persistent in-app banner: "Payment failed — update your payment method." |
| `customer.subscription.updated` (status: past_due) | Same as above |
| Stripe Smart Retries | Stripe handles automatically (up to 4 attempts over configurable period). No code needed. |
| `customer.subscription.deleted` after retries fail | Downgrade user to free in DB. Send "Your subscription has been canceled" email. |

### Disputed Charges

**Recommendation:** Don't build custom dispute handling for v1. Stripe Dashboard provides dispute management UI. Add a webhook handler for `charge.dispute.created` that sends an internal Slack/email alert (LOW priority for v1).

### Grace Period on Downgrade

When `cancel_at_period_end: true`:
1. `status` stays `active` — user keeps Pro access until `current_period_end`
2. Show "Your subscription ends on [date]. Features will revert to Free." in billing section
3. At period end, Stripe sends `customer.subscription.deleted` — update DB to free tier
4. On next public page load, Pro features stripped, Free theme applied if using Pro-only theme

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| API routes for checkout | Server Actions also viable | Next.js 15+ | Route handlers still fine for webhooks (Stripe needs static URL); Server Actions work for checkout session creation |
| Stripe Elements (custom forms) | Stripe Checkout (hosted) more common for SaaS | 2022+ | Faster to ship, handles 3DS/regional methods automatically |
| Webhooks via separate microservice | Next.js route handler `/api/webhooks/stripe` | App Router era | Co-located, simpler deployment |
| Manual retry logic | Stripe Smart Retries | Always existed | Zero custom code for dunning |

**Deprecated/outdated:**
- Pages Router API routes (`pages/api/stripe.ts`): Still works but new projects use App Router route handlers
- `stripe@8.x` webhook construction: API has been stable but version-pin with `apiVersion` param is now standard practice

---

## Open Questions

1. **Stripe Product/Price ID creation process**
   - What we know: Price IDs must be created in Stripe Dashboard (or via API) before being embedded in code as env vars
   - What's unclear: Whether to create products/prices via Stripe Dashboard UI or via Stripe API in a setup script
   - Recommendation: Create in Stripe Dashboard for both test and live modes. Use `STRIPE_PRO_MONTHLY_PRICE_ID`, `STRIPE_PRO_ANNUAL_PRICE_ID`, etc. as env vars. Document the IDs.

2. **Supabase Admin Client setup**
   - What we know: Webhooks need service role access to bypass RLS
   - What's unclear: Whether a `SUPABASE_SERVICE_ROLE_KEY` env var is already configured
   - Recommendation: Add to env vars during setup. Verify it's not exposed to client (no `NEXT_PUBLIC_` prefix).

3. **Artist tier pricing**
   - What we know: ROADMAP says $20/mo, no annual pricing specified
   - What's unclear: Annual discount for Artist tier
   - Recommendation: Mirror Pro's ~20% discount: $192/year (~$16/mo effective). Can be adjusted.

4. **Branding footer feature (PREM-02)**
   - What we know: "Powered by LinkLobby" footer exists on public pages
   - What's unclear: Whether the footer is currently implemented
   - Recommendation: Check `src/components/public/public-page-renderer.tsx` — add footer if missing, gate it on Pro.

5. **Upgrade prompt triggers**
   - What we know: Contextual upgrade prompts when hitting Free limits
   - What's unclear: Which specific interactions should trigger prompts (clicking a Pro badge? Trying to publish with Pro theme? Toggling a Pro feature?)
   - Recommendation: Three triggers: (1) clicking a Pro badge in editor, (2) attempting to publish with a Pro-only theme, (3) navigating to `/pricing` from the plan badge in sidebar.

---

## Sources

### Primary (HIGH confidence)

- [Stripe Subscriptions Build Guide](https://docs.stripe.com/billing/subscriptions/build-subscriptions) — Integration methods, webhook events, subscription states
- [Stripe Checkout Quickstart (Next.js)](https://docs.stripe.com/checkout/quickstart?client=next) — Route handler patterns, session creation
- [Stripe Customer Portal Integration](https://docs.stripe.com/customer-management/integrate-customer-portal) — Portal session creation, configuration
- [Stripe Webhook Signature Verification](https://docs.stripe.com/webhooks/signature) — `constructEvent()`, common errors
- [Stripe Subscription Object](https://docs.stripe.com/api/subscriptions/object) — Status enum, field definitions
- [Stripe Trial Periods](https://docs.stripe.com/billing/subscriptions/trials) — trial_period_days, end_behavior, no-card trials
- [Vercel nextjs-subscription-payments webhook handler](https://github.com/vercel/nextjs-subscription-payments/blob/main/app/api/webhooks/route.ts) — Reference implementation

### Secondary (MEDIUM confidence)

- [Supabase SQL Stripe Subscriptions Schema](https://supabase-sql.vercel.app/stripe-subscriptions) — Verified DB table structure with RLS
- [Stripe + Next.js Complete 2025 Guide (Pedro Alonso)](https://www.pedroalonso.net/blog/stripe-nextjs-complete-guide-2025/) — Server Actions pattern, architecture overview
- [App Router webhook signature verification (Medium)](https://kitson-broadhurst.medium.com/next-js-app-router-stripe-webhook-signature-verification-ea9d59f3593f) — `request.text()` requirement confirmed

### Tertiary (LOW confidence)

- [SaaS trial credit card vs no-card (UserPilot)](https://userpilot.com/blog/credit-card-vs-no-credit-card/) — Trial strategy tradeoffs (WebSearch only, industry analysis)
- [Stripe dunning guide 2025](https://paymentsplugin.com/blog/stripe-dunning/) — Smart retry stats (WebSearch only)

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — Stripe SDK is well-documented, npm packages confirmed
- Webhook pattern: HIGH — Raw body / signature verification confirmed from official docs + multiple sources
- Database schema: HIGH — Based on Vercel reference schema + official Supabase SQL reference
- Trial recommendation: MEDIUM — Industry analysis from multiple sources, no single authoritative answer
- Theme gating specifics: LOW — Subjective product decision, no authoritative source

**Research date:** 2026-02-25
**Valid until:** 2026-04-25 (Stripe API versioning is stable; Next.js patterns change slowly)
