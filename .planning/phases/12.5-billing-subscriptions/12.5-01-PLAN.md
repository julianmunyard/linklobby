---
phase: 12.5-billing-subscriptions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/stripe/client.ts
  - src/lib/stripe/plans.ts
  - src/lib/stripe/subscription.ts
  - src/lib/supabase/admin.ts
  - src/app/api/webhooks/stripe/route.ts
  - src/app/api/billing/checkout/route.ts
  - src/app/api/billing/portal/route.ts
  - supabase/migrations/20260225_billing_tables.sql
autonomous: true

user_setup:
  - service: stripe
    why: "Payment processing — Stripe account needed for API keys and webhook endpoint"
    env_vars:
      - name: STRIPE_SECRET_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Secret key"
      - name: NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Publishable key"
      - name: STRIPE_WEBHOOK_SECRET
        source: "Stripe Dashboard -> Developers -> Webhooks -> Add endpoint -> Signing secret (for production). For local dev, run `stripe listen --forward-to localhost:3000/api/webhooks/stripe` and use the printed whsec_ value."
      - name: STRIPE_PRO_MONTHLY_PRICE_ID
        source: "Stripe Dashboard -> Products -> Create product 'Pro Monthly' ($12/mo recurring) -> copy price ID (price_xxx)"
      - name: STRIPE_PRO_ANNUAL_PRICE_ID
        source: "Stripe Dashboard -> Products -> Create product 'Pro Annual' ($115/yr recurring) -> copy price ID"
      - name: STRIPE_ARTIST_MONTHLY_PRICE_ID
        source: "Stripe Dashboard -> Products -> Create product 'Artist Monthly' ($20/mo recurring) -> copy price ID"
      - name: STRIPE_ARTIST_ANNUAL_PRICE_ID
        source: "Stripe Dashboard -> Products -> Create product 'Artist Annual' ($192/yr recurring) -> copy price ID"
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Supabase Dashboard -> Settings -> API -> service_role key (secret)"
    dashboard_config:
      - task: "Create Stripe products and prices for all 4 price points (Pro monthly/annual, Artist monthly/annual)"
        location: "Stripe Dashboard -> Products"
      - task: "Create webhook endpoint pointing to https://your-domain.com/api/webhooks/stripe with events: checkout.session.completed, customer.subscription.created, customer.subscription.updated, customer.subscription.deleted, invoice.paid, invoice.payment_failed, customer.subscription.trial_will_end"
        location: "Stripe Dashboard -> Developers -> Webhooks"

must_haves:
  truths:
    - "Stripe Checkout session can be created via POST /api/billing/checkout with a priceId"
    - "Stripe webhooks are verified with raw body signature and processed idempotently"
    - "Subscription state is synced from Stripe to local Supabase tables via webhooks"
    - "getUserPlan(userId) returns the correct tier (free/pro/artist) from local DB"
    - "Customer Portal session can be created via POST /api/billing/portal"
    - "Database tables (customers, subscriptions, webhook_events) exist with proper RLS"
  artifacts:
    - path: "src/lib/stripe/client.ts"
      provides: "Singleton Stripe server-side instance"
      exports: ["stripe"]
    - path: "src/lib/stripe/plans.ts"
      provides: "Plan definitions with tier names, price IDs, feature flags"
      exports: ["PLANS", "PlanFeatures", "getPlanTierByPriceId"]
    - path: "src/lib/stripe/subscription.ts"
      provides: "getUserPlan helper that reads from local DB"
      exports: ["getUserPlan", "isPro", "isArtist", "PlanTier"]
    - path: "src/lib/supabase/admin.ts"
      provides: "Service role Supabase client for webhook handlers"
      exports: ["createAdminClient"]
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Webhook handler with signature verification and subscription sync"
      exports: ["POST"]
    - path: "src/app/api/billing/checkout/route.ts"
      provides: "Checkout session creation endpoint"
      exports: ["POST"]
    - path: "src/app/api/billing/portal/route.ts"
      provides: "Customer Portal session creation endpoint"
      exports: ["POST"]
    - path: "supabase/migrations/20260225_billing_tables.sql"
      provides: "Database tables for customers, subscriptions, webhook_events"
      contains: "CREATE TABLE subscriptions"
  key_links:
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/stripe/client.ts"
      via: "imports stripe singleton for constructEvent"
      pattern: "import.*stripe.*from.*lib/stripe/client"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/supabase/admin.ts"
      via: "uses admin client to bypass RLS in webhook context"
      pattern: "createAdminClient"
    - from: "src/app/api/billing/checkout/route.ts"
      to: "src/lib/stripe/client.ts"
      via: "creates Checkout Session via Stripe SDK"
      pattern: "stripe.checkout.sessions.create"
    - from: "src/lib/stripe/subscription.ts"
      to: "subscriptions table"
      via: "reads plan_tier and status from local DB"
      pattern: "from.*subscriptions"
---

<objective>
Build the complete Stripe billing backend: server-side Stripe client, plan definitions, database schema, webhook handler with idempotent subscription sync, checkout session creation, and customer portal session creation.

Purpose: This is the foundation for all billing features. Without the webhook pipeline and local subscription state, no other billing plan can function. The checkout and portal routes enable the upgrade flow and billing management.
Output: Stripe client singleton, plan config, subscription helper, admin Supabase client, 3 API routes (webhook, checkout, portal), and database migration.
</objective>

<execution_context>
@/Users/julianmunyard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianmunyard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.5-billing-subscriptions/12.5-RESEARCH.md
@.planning/phases/12.5-billing-subscriptions/12.5-CONTEXT.md
@src/lib/supabase/server.ts
@src/lib/supabase/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Stripe SDK, create Stripe client, plan definitions, subscription helper, and admin Supabase client</name>
  <files>src/lib/stripe/client.ts, src/lib/stripe/plans.ts, src/lib/stripe/subscription.ts, src/lib/supabase/admin.ts</files>
  <action>
**Step 1: Install Stripe SDK.**

```bash
npm install stripe @stripe/stripe-js
```

Only `stripe` (server SDK) is needed now. `@stripe/stripe-js` is the client loader — installed for future use but not required for hosted Checkout (no Elements).

**Step 2: Create `src/lib/stripe/client.ts`.**

Singleton Stripe instance for server-side use. Pin the API version. Use `process.env.STRIPE_SECRET_KEY`. Add a comment that this file is server-only — never import from client components.

```typescript
import Stripe from 'stripe'

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2025-03-31.basil',
  typescript: true,
})
```

**Step 3: Create `src/lib/stripe/plans.ts`.**

Define the 3-tier plan structure with feature flags. This is the central config for what each tier can do. Include:
- `PlanTier` type: `'free' | 'pro' | 'artist'`
- `PlanFeatures` type: boolean map of all gated features (removeBranding, emailCollection, qrCodes, facebookPixel, googleAnalytics, linkScheduling, releaseMode, customDomain, geoAnalytics, tourDates, proThemes)
- `PLANS` constant: Record<PlanTier, { tier, name, priceMonthly (cents), priceAnnual (cents), stripePriceIdMonthly, stripePriceIdAnnual, features: PlanFeatures }>
- `getPlanTierByPriceId(priceId: string): PlanTier` — maps a Stripe price ID to a tier by checking against all plan price IDs. Returns 'free' if no match.
- Free tier: all features false, null prices. Pro: $12/mo ($1200 cents), $115/yr ($11500 cents). Artist: $20/mo ($2000 cents), $192/yr ($19200 cents).
- Price ID env vars: `STRIPE_PRO_MONTHLY_PRICE_ID`, `STRIPE_PRO_ANNUAL_PRICE_ID`, `STRIPE_ARTIST_MONTHLY_PRICE_ID`, `STRIPE_ARTIST_ANNUAL_PRICE_ID`.
- Add `proThemes: true` to Pro and Artist tiers (for theme gating in Plan 03).

Refer to the research file Pattern: Plan Definitions for the exact shape. Use `process.env.STRIPE_*_PRICE_ID!` with non-null assertions (env vars are required).

**Step 4: Create `src/lib/stripe/subscription.ts`.**

Helper to get a user's active plan tier from the local `subscriptions` table. Follow the research Pattern 5 exactly:
- `getUserPlan(userId: string): Promise<PlanTier>` — queries subscriptions table by user_id. Returns 'free' if no row, if status is not 'active'/'trialing', or if canceled past period end. Uses the server Supabase client (not admin — this reads via RLS as the user context).
- `isPro(tier: PlanTier): boolean` — true for 'pro' or 'artist'
- `isArtist(tier: PlanTier): boolean` — true only for 'artist'

Import `createClient` from `@/lib/supabase/server` and `PlanTier` from `./plans`.

**Step 5: Create `src/lib/supabase/admin.ts`.**

Service role client for webhook handlers (bypasses RLS). This is needed because webhook handlers have no auth user context.

```typescript
import { createClient } from '@supabase/supabase-js'

export function createAdminClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
  )
}
```

Add a comment: "Server-only. Uses service_role key to bypass RLS. Never import from client components."
  </action>
  <verify>
- `ls src/lib/stripe/client.ts src/lib/stripe/plans.ts src/lib/stripe/subscription.ts src/lib/supabase/admin.ts` — all exist
- `npx tsc --noEmit` — no type errors
- `grep "apiVersion" src/lib/stripe/client.ts` — version pinned
- `grep "getPlanTierByPriceId" src/lib/stripe/plans.ts` — helper exists
- `grep "getUserPlan" src/lib/stripe/subscription.ts` — helper exists
- `grep "createAdminClient" src/lib/supabase/admin.ts` — export exists
  </verify>
  <done>
Stripe client singleton created. Plan definitions with 3 tiers and feature flags exported. getUserPlan reads from local DB and returns correct tier. Admin Supabase client created for webhook use. All files type-check.
  </done>
</task>

<task type="auto">
  <name>Task 2: Database migration and API routes (webhook, checkout, portal)</name>
  <files>supabase/migrations/20260225_billing_tables.sql, src/app/api/webhooks/stripe/route.ts, src/app/api/billing/checkout/route.ts, src/app/api/billing/portal/route.ts</files>
  <action>
**Step 1: Create migration `supabase/migrations/20260225_billing_tables.sql`.**

Follow the research Database Schema exactly:

```sql
-- customers: user_id -> stripe_customer_id mapping
CREATE TABLE IF NOT EXISTS customers (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  stripe_customer_id TEXT UNIQUE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- subscriptions: full subscription state synced from Stripe
CREATE TABLE IF NOT EXISTS subscriptions (
  id TEXT PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  plan_tier TEXT NOT NULL DEFAULT 'free',
  status TEXT NOT NULL,
  price_id TEXT,
  current_period_start TIMESTAMPTZ,
  current_period_end TIMESTAMPTZ,
  trial_start TIMESTAMPTZ,
  trial_end TIMESTAMPTZ,
  cancel_at_period_end BOOLEAN DEFAULT FALSE,
  canceled_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- webhook_events: idempotency
CREATE TABLE IF NOT EXISTS webhook_events (
  stripe_event_id TEXT PRIMARY KEY,
  processed_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS subscriptions_user_id_idx ON subscriptions(user_id);

-- RLS
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own subscription" ON subscriptions FOR SELECT USING (user_id = auth.uid());

ALTER TABLE customers ENABLE ROW LEVEL SECURITY;
-- No public policies on customers — accessed via service role only

ALTER TABLE webhook_events ENABLE ROW LEVEL SECURITY;
-- No public policies — accessed via service role only
```

**Step 2: Create `src/app/api/webhooks/stripe/route.ts`.**

CRITICAL: Use `await request.text()` NOT `.json()` for the body. This is the most common mistake.

Follow research Pattern 3. Include:
1. `export const dynamic = 'force-dynamic'` at top (disable caching for webhook route).
2. Extract body via `await request.text()`, sig via `request.headers.get('stripe-signature')`.
3. Verify signature with `stripe.webhooks.constructEvent(body, sig, process.env.STRIPE_WEBHOOK_SECRET!)`. Catch errors and return 400.
4. Idempotency check: query `webhook_events` table for `event.id`. If exists, return `{ received: true }`. If not, insert.
5. Handle events in a switch:
   - `checkout.session.completed`: if mode is 'subscription', call `syncSubscription(session.subscription, session.metadata?.user_id)`
   - `customer.subscription.created`, `customer.subscription.updated`, `customer.subscription.deleted`: call `syncSubscription(sub.id, sub.metadata?.user_id)`
   - `invoice.paid`, `invoice.payment_failed`: if `invoice.subscription`, call `syncSubscription(invoice.subscription)`
   - `customer.subscription.trial_will_end`: log for now (email notification in Phase 12.7)
6. Return `{ received: true }` with 200.

Implement `syncSubscription(subscriptionId: string, userId?: string)` as a module-level async function:
- Retrieve full subscription from Stripe: `stripe.subscriptions.retrieve(subscriptionId)`
- Resolve user_id from: (a) passed userId param, (b) `sub.metadata?.user_id`, (c) lookup by `sub.customer` in customers table
- Determine tier via `getPlanTierByPriceId(sub.items.data[0]?.price.id)`
- Upsert into `subscriptions` table with all fields (id, user_id, plan_tier, status, price_id, period dates, trial dates, cancel_at_period_end, canceled_at, updated_at)
- Upsert into `customers` table to ensure mapping exists
- Use `createAdminClient()` for all DB operations (bypasses RLS)

Also implement `getUserIdByStripeCustomer(stripeCustomerId: string)` helper that queries customers table.

**Step 3: Create `src/app/api/billing/checkout/route.ts`.**

Follow research Pattern 2:
1. Authenticate user via Supabase server client
2. Parse `{ priceId }` from request body
3. Look up existing Stripe customer from `customers` table (use server Supabase client — user is authenticated so RLS doesn't apply here, but customers table has no SELECT policy for users. Use admin client for this lookup).
4. Create Checkout Session with:
   - `customer` (if exists) or `customer_email` (if new)
   - `mode: 'subscription'`
   - `line_items: [{ price: priceId, quantity: 1 }]`
   - `subscription_data.trial_period_days: 7` (no card required)
   - `subscription_data.trial_settings.end_behavior.missing_payment_method: 'cancel'`
   - `subscription_data.metadata: { user_id: user.id }`
   - `metadata: { user_id: user.id }`
   - `success_url` and `cancel_url` using `process.env.NEXT_PUBLIC_APP_URL`
   - `payment_method_collection: 'if_required'` for no-card trial
5. Return `{ url: session.url }`

NOTE: For the customer lookup, use `createAdminClient()` since the customers table has no SELECT RLS policy for regular users.

**Step 4: Create `src/app/api/billing/portal/route.ts`.**

Follow research Pattern 4:
1. Authenticate user
2. Look up `stripe_customer_id` from `customers` table (admin client)
3. If no customer found, return 404
4. Create portal session with `return_url` pointing to `/settings`
5. Return `{ url: session.url }`
  </action>
  <verify>
- `ls supabase/migrations/20260225_billing_tables.sql` — migration exists
- `grep "request.text()" src/app/api/webhooks/stripe/route.ts` — raw body used (NOT .json())
- `grep "constructEvent" src/app/api/webhooks/stripe/route.ts` — signature verification present
- `grep "webhook_events" src/app/api/webhooks/stripe/route.ts` — idempotency check present
- `grep "syncSubscription" src/app/api/webhooks/stripe/route.ts` — sync function exists
- `grep "createAdminClient" src/app/api/webhooks/stripe/route.ts` — admin client used
- `grep "checkout.sessions.create" src/app/api/billing/checkout/route.ts` — checkout session creation
- `grep "trial_period_days" src/app/api/billing/checkout/route.ts` — 7-day trial configured
- `grep "billingPortal.sessions.create" src/app/api/billing/portal/route.ts` — portal session creation
- `npx tsc --noEmit` — no type errors
  </verify>
  <done>
Database migration creates customers, subscriptions, and webhook_events tables with RLS. Webhook route handler verifies signatures with raw body, processes events idempotently, and syncs subscription state to local DB. Checkout route creates Stripe sessions with 7-day no-card trial. Portal route creates Customer Portal sessions. All routes use admin Supabase client where RLS would block access.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. All 4 Stripe library files exist under `src/lib/stripe/` and `src/lib/supabase/admin.ts`
3. All 3 API routes exist under `src/app/api/`
4. Migration file exists and contains CREATE TABLE for all 3 tables
5. Webhook handler uses `request.text()` (not `.json()`)
6. No Stripe API calls at render time — all gating uses local DB via `getUserPlan()`
</verification>

<success_criteria>
- Stripe SDK installed and singleton client created
- Plan definitions with feature flags for all 3 tiers
- getUserPlan reads subscription state from local Supabase table
- Webhook handler verifies signatures, deduplicates events, syncs to local DB
- Checkout route creates sessions with 7-day no-card trial
- Portal route creates Customer Portal sessions
- Database migration ready with proper RLS
- All files type-check
</success_criteria>

<output>
After completion, create `.planning/phases/12.5-billing-subscriptions/12.5-01-SUMMARY.md`
</output>
