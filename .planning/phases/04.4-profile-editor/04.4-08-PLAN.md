---
phase: 04.4-profile-editor
plan: 08
type: execute
wave: 3
depends_on: ["04.4-01", "04.4-04"]
files_modified:
  - supabase/migrations/20260126_add_profile_columns.sql
  - src/app/api/profile/route.ts
  - src/components/editor/editor-header.tsx
  - src/app/dashboard/edit/page.tsx
autonomous: true

must_haves:
  truths:
    - "Profile data persists to database on save"
    - "Profile data loads from database on page load"
    - "Auto-save triggers when hasChanges becomes true"
    - "Save button shows disabled state when no changes"
  artifacts:
    - path: "supabase/migrations/20260126_add_profile_columns.sql"
      provides: "Database schema for profile fields"
      contains: "title_style"
    - path: "src/app/api/profile/route.ts"
      provides: "Profile API routes"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/api/profile/route.ts"
      to: "supabase"
      via: "database queries"
      pattern: "supabase.*profiles.*update|supabase.*profiles.*select"
    - from: "src/components/editor/editor-header.tsx"
      to: "src/app/api/profile/route.ts"
      via: "fetch call on save"
      pattern: "fetch.*api/profile"
    - from: "src/app/dashboard/edit/page.tsx"
      to: "src/stores/profile-store.ts"
      via: "initializeProfile on load"
      pattern: "initializeProfile"
---

<objective>
Add database persistence for profile data (save/load profile to Supabase profiles table).

Purpose: Profile changes currently only exist in memory - this plan adds the database layer so changes persist across sessions.
Output: Migration adding profile columns, API routes for save/load, auto-save wiring in editor.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04.4-profile-editor/04.4-CONTEXT.md
@.planning/phases/04.4-profile-editor/04.4-01-SUMMARY.md
@.planning/phases/04.4-profile-editor/04.4-04-SUMMARY.md
@supabase/schema.sql
@src/stores/profile-store.ts
@src/app/api/cards/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration for profile columns</name>
  <files>supabase/migrations/20260126_add_profile_columns.sql</files>
  <action>
Create migration to add profile fields to existing profiles table:

```sql
-- Add profile header fields to profiles table
-- These columns support the Profile Editor feature (Phase 4.4)

-- Avatar URL already exists (avatar_url TEXT)
-- Display name already exists (display_name TEXT)

-- Add new columns for profile customization
ALTER TABLE public.profiles
  ADD COLUMN IF NOT EXISTS logo_url TEXT,
  ADD COLUMN IF NOT EXISTS title_style TEXT NOT NULL DEFAULT 'text',
  ADD COLUMN IF NOT EXISTS title_size TEXT NOT NULL DEFAULT 'large',
  ADD COLUMN IF NOT EXISTS profile_layout TEXT NOT NULL DEFAULT 'classic',
  ADD COLUMN IF NOT EXISTS show_social_icons BOOLEAN NOT NULL DEFAULT true,
  ADD COLUMN IF NOT EXISTS social_icons JSONB NOT NULL DEFAULT '[]'::jsonb;

-- Add check constraints for enum-like columns
ALTER TABLE public.profiles
  ADD CONSTRAINT profiles_title_style_check
    CHECK (title_style IN ('text', 'logo')),
  ADD CONSTRAINT profiles_title_size_check
    CHECK (title_size IN ('small', 'large')),
  ADD CONSTRAINT profiles_layout_check
    CHECK (profile_layout IN ('classic', 'hero'));

-- Comment on columns for documentation
COMMENT ON COLUMN public.profiles.logo_url IS 'URL to uploaded logo image (when title_style is logo)';
COMMENT ON COLUMN public.profiles.title_style IS 'How to display title: text (display_name) or logo (logo_url)';
COMMENT ON COLUMN public.profiles.title_size IS 'Title text size when title_style is text: small or large';
COMMENT ON COLUMN public.profiles.profile_layout IS 'Header layout style: classic (small circle) or hero (banner)';
COMMENT ON COLUMN public.profiles.show_social_icons IS 'Whether to show social icons row in header';
COMMENT ON COLUMN public.profiles.social_icons IS 'Array of {id, platform, url, sortKey} objects';
```

Note: User will need to run this migration manually in Supabase SQL Editor.
  </action>
  <verify>SQL syntax is valid (no TypeScript check needed - SQL file)</verify>
  <done>Migration file exists with all profile columns</done>
</task>

<task type="auto">
  <name>Task 2: Create profile API routes</name>
  <files>src/app/api/profile/route.ts</files>
  <action>
Create API routes for profile CRUD following cards/route.ts patterns:

1. Imports:
```typescript
import { createClient } from "@/lib/supabase/server"
import { NextResponse } from "next/server"
```

2. Helper function (copy from cards route):
```typescript
async function fetchUserProfile(supabase: ReturnType<typeof createClient>) {
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { profile: null, error: 'Unauthorized' }

  const { data: profile, error } = await supabase
    .from('profiles')
    .select('*')
    .eq('id', user.id)
    .single()

  if (error) return { profile: null, error: error.message }
  return { profile, error: null }
}
```

3. GET handler - load profile:
```typescript
export async function GET() {
  const supabase = await createClient()
  const { profile, error } = await fetchUserProfile(supabase)

  if (error) {
    return NextResponse.json({ error }, { status: error === 'Unauthorized' ? 401 : 500 })
  }

  // Map database columns to frontend types
  return NextResponse.json({
    displayName: profile.display_name,
    avatarUrl: profile.avatar_url,
    logoUrl: profile.logo_url,
    titleStyle: profile.title_style,
    titleSize: profile.title_size,
    profileLayout: profile.profile_layout,
    showSocialIcons: profile.show_social_icons,
    socialIcons: profile.social_icons || [],
  })
}
```

4. POST handler - save profile:
```typescript
export async function POST(request: Request) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const body = await request.json()

  // Map frontend types to database columns
  const { error } = await supabase
    .from('profiles')
    .update({
      display_name: body.displayName,
      avatar_url: body.avatarUrl,
      logo_url: body.logoUrl,
      title_style: body.titleStyle,
      title_size: body.titleSize,
      profile_layout: body.profileLayout,
      show_social_icons: body.showSocialIcons,
      social_icons: body.socialIcons,
      updated_at: new Date().toISOString(),
    })
    .eq('id', user.id)

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  return NextResponse.json({ success: true })
}
```
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>GET returns profile data, POST saves profile data</done>
</task>

<task type="auto">
  <name>Task 3: Wire auto-save and load into editor</name>
  <files>src/components/editor/editor-header.tsx, src/app/dashboard/edit/page.tsx</files>
  <action>
Wire profile persistence following existing cards hasChanges pattern:

**Part A: Add profile save to editor-header.tsx**

1. Import useProfileStore:
```typescript
import { useProfileStore } from "@/stores/profile-store"
```

2. Get profile state and actions:
```typescript
const profileHasChanges = useProfileStore((state) => state.hasChanges)
const profileSnapshot = useProfileStore((state) => state.getSnapshot)
const markProfileSaved = useProfileStore((state) => state.markSaved)
```

3. Update existing save handler to also save profile:
```typescript
const handleSave = async () => {
  setSaving(true)
  try {
    // Save cards (existing)
    if (cardHasChanges) {
      await saveCards()
      // ... existing card save logic
    }

    // Save profile (new)
    if (profileHasChanges) {
      const profile = profileSnapshot()
      const response = await fetch('/api/profile', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(profile),
      })
      if (!response.ok) throw new Error('Failed to save profile')
      markProfileSaved()
    }

    toast.success('Changes saved')
  } catch (error) {
    toast.error('Failed to save')
  } finally {
    setSaving(false)
  }
}
```

4. Update hasChanges check to include profile:
```typescript
const hasChanges = cardHasChanges || profileHasChanges
```

**Part B: Load profile on page mount in edit/page.tsx**

1. Import useProfileStore:
```typescript
import { useProfileStore } from "@/stores/profile-store"
```

2. Add useEffect to load profile (alongside existing card loading):
```typescript
useEffect(() => {
  async function loadProfile() {
    const response = await fetch('/api/profile')
    if (response.ok) {
      const data = await response.json()
      useProfileStore.getState().initializeProfile(data)
    }
  }
  loadProfile()
}, [])
```

Note: Use getState() pattern to avoid re-renders (same as quick-006 decision).
  </action>
  <verify>`npm run dev` - profile changes save and persist across page refresh</verify>
  <done>Profile saves on button click, loads on page mount, hasChanges tracks both cards and profile</done>
</task>

</tasks>

<verification>
- `npm run build` passes
- Migration file has valid SQL syntax
- API route handles GET and POST
- Profile loads on editor page mount
- Profile saves when Save button clicked
- hasChanges reflects both card and profile changes
</verification>

<success_criteria>
- Database has profile columns (after user runs migration)
- GET /api/profile returns profile data
- POST /api/profile saves profile data
- Editor loads profile from database on mount
- Save button saves both cards and profile
- Profile changes persist across browser refresh
</success_criteria>

<output>
After completion, create `.planning/phases/04.4-profile-editor/04.4-08-SUMMARY.md`
</output>
