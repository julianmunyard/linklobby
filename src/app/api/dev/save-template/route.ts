// DEV-ONLY route — writes a template .ts file and registers it in the index.
// Gated behind NEXT_PUBLIC_DEV_TOOLS=true. Not available in production.

import { NextResponse } from 'next/server'
import fs from 'fs'
import path from 'path'

export const runtime = 'nodejs'

export async function POST(req: Request) {
  // Gate: only available with dev tools enabled
  if (process.env.NEXT_PUBLIC_DEV_TOOLS !== 'true') {
    return NextResponse.json({ error: 'Dev tools not enabled' }, { status: 403 })
  }

  try {
    const body = await req.json()
    const { name, description, energyLabel, template } = body as {
      name: string
      description: string
      energyLabel: string
      template: Record<string, unknown>
    }

    if (!name || !template) {
      return NextResponse.json({ error: 'name and template required' }, { status: 400 })
    }

    // Generate slug from name: "Dark Minimal" → "dark-minimal"
    const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '')
    const themeId = template.themeId as string
    const templateId = `${themeId}-${slug}`

    // Variable name from slug: "dark-minimal" → "darkMinimal"
    const varName = slug.replace(/-([a-z])/g, (_, c: string) => c.toUpperCase())
    // Prefix with themeId camelCase
    const themePrefix = themeId.replace(/-([a-z])/g, (_, c: string) => c.toUpperCase())
    const exportName = `${themePrefix}${varName.charAt(0).toUpperCase()}${varName.slice(1)}`

    // Build the final template object
    const finalTemplate = {
      ...template,
      id: templateId,
      name,
      description,
      energyLabel: energyLabel || undefined,
      thumbnailPath: `/templates/${templateId}/thumbnail.jpg`,
    }

    // Create public/templates/{id}/ directory for assets
    const assetsDir = path.join(process.cwd(), 'public', 'templates', templateId)
    fs.mkdirSync(assetsDir, { recursive: true })

    // Generate a placeholder thumbnail (1x1 dark pixel JPEG — will be replaced by dev)
    const placeholderJpeg = Buffer.from(
      '/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMCwsKCwsM' +
      'DhEQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQU' +
      'FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAABAAEDASIAAhEBAxEB/8QAHwAAAQ' +
      'UFAQEBAAAAAAAAAAAAAAECAwQFBgcICf/EABUQAQAAAAAAAAAAAAAAAAAAAAj/xAAUAQEAAAAAAAAAAAAA' +
      'AAAAAAAB/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8ApsA//9k=',
      'base64'
    )
    const thumbPath = path.join(assetsDir, 'thumbnail.jpg')
    if (!fs.existsSync(thumbPath)) {
      fs.writeFileSync(thumbPath, placeholderJpeg)
    }

    // Write the template .ts file
    const themeDir = path.join(process.cwd(), 'src', 'lib', 'templates', 'data', themeId)
    fs.mkdirSync(themeDir, { recursive: true })

    const tsContent = `// Auto-generated by DevTemplateSaver
import type { TemplateDefinition } from '../../types'

export const ${exportName}: TemplateDefinition = ${JSON.stringify(finalTemplate, null, 2)} as const satisfies TemplateDefinition
`

    const tsFilePath = path.join(themeDir, `${slug}.ts`)
    fs.writeFileSync(tsFilePath, tsContent, 'utf-8')

    // Update the registry index.ts to import and register the new template
    const indexPath = path.join(process.cwd(), 'src', 'lib', 'templates', 'index.ts')
    let indexContent = fs.readFileSync(indexPath, 'utf-8')

    // Add import line before the ALL_TEMPLATES declaration
    const importLine = `import { ${exportName} } from './data/${themeId}/${slug}'`

    // Check if already imported (avoid duplicates on re-save)
    if (!indexContent.includes(exportName)) {
      // Insert import before ALL_TEMPLATES
      indexContent = indexContent.replace(
        'const ALL_TEMPLATES',
        `${importLine}\n\nconst ALL_TEMPLATES`
      )

      // Add to ALL_TEMPLATES array — insert before the closing bracket
      // Use [\s\S] instead of /s flag for cross-line matching
      indexContent = indexContent.replace(
        /const ALL_TEMPLATES: TemplateDefinition\[\] = \[([\s\S]*?)\]/,
        (match, inner) => {
          const trimmed = (inner as string).trimEnd()
          // Add comma after last entry if needed
          const separator = trimmed.endsWith(',') || trimmed.trim() === '' ? '' : ','
          return `const ALL_TEMPLATES: TemplateDefinition[] = [${trimmed}${separator}\n  ${exportName},\n]`
        }
      )

      fs.writeFileSync(indexPath, indexContent, 'utf-8')
    }

    return NextResponse.json({
      success: true,
      templateId,
      exportName,
      filePath: `src/lib/templates/data/${themeId}/${slug}.ts`,
      assetsDir: `public/templates/${templateId}/`,
      message: `Template "${name}" saved! HMR will pick it up — check the Templates tab.`,
    })
  } catch (error) {
    console.error('[dev/save-template] Error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    )
  }
}
